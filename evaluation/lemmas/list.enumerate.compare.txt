evaluation/lemmas/list.enumerate.bpl
  31  number of lemmas
  0  wrong
forall y₀: nat :: (y₀ == add(y₀, zero))
forall x₁: list :: (x₁ == append(x₁, nil))
forall y₀: list, y₁: nat, x₁: list :: (append(snoc(y₀, y₁), x₁) == append(append(y₀, nil), cons(y₁, x₁)))
forall y₀: nat, y₁: nat :: (succ(add(y₀, y₁)) == add(y₀, succ(y₁)))
forall y₀: list, x₁: nat :: (add(length(y₀), x₁) == add(add(x₁, zero), length(y₀)))
forall x₀: [nat]Bool, y₀: nat, y₁: list :: (filter(x₀, remove(y₀, y₁)) == remove(add(y₀, zero), filter(x₀, y₁)))
forall y₀: list, y₁: list, x₁: nat :: (snoc(append(y₀, y₁), x₁) == append(append(y₀, nil), snoc(y₁, x₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(add(y₁, y₀), add(x₁, zero)))
forall x₀: nat, y₀: [nat]Bool, y₁: list :: (add(x₀, countif(y₀, y₁)) == add(countif(y₀, y₁), add(x₀, zero)))
forall x₀: nat, y₀: nat, y₁: list :: (add(x₀, count(y₀, y₁)) == add(count(y₀, y₁), x₀))
forall y₀: list, y₁: nat :: (length(snoc(y₀, y₁)) == add(length(y₀), succ(zero)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), append(y₁, nil)))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(y₀, add(y₁, x₀)))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(y₁, add(y₀, x₀)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), y₁))
forall x₀: nat, y₀: list :: (cons(x₀, reverse(y₀)) == reverse(snoc(y₀, x₀)))
forall y₀: list :: (reverse(reverse(y₀)) == take(length(y₀), snoc(y₀, zero)))
forall x₀: list, y₀: list :: (append(x₀, reverse(y₀)) == append(drop(zero, x₀), reverse(y₀)))
forall y₀: list, x₁: list :: (count(length(y₀), x₁) == count(length(y₀), rotate(zero, x₁)))
forall y₀: nat, y₁: list, x₁: list :: (append(take(y₀, y₁), x₁) == append(take(y₀, y₁), rotate(zero, x₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(x₁, add(y₁, y₀)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(add(y₀, y₁), x₀))
forall y₀: list :: (reverse(reverse(y₀)) == rotate(zero, y₀))
forall y₀: list :: (length(reverse(y₀)) == length(append(y₀, nil)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(reverse(y₁)))
forall x₀: list, y₀: list, y₁: nat :: (append(x₀, snoc(y₀, y₁)) == snoc(append(x₀, y₀), add(y₁, zero)))
forall y₀: list :: (reverse(reverse(y₀)) == append(take(zero, y₀), rotate(zero, y₀)))
forall y₀: list :: (reverse(reverse(y₀)) == drop(zero, drop(zero, y₀)))
forall y₀: nat, x₁: nat :: (succ(add(y₀, x₁)) == add(x₁, succ(y₀)))
forall y₀: list :: (reverse(reverse(y₀)) == append(rotate(zero, y₀), take(zero, y₀)))
  28  nontrivial
forall y₀: nat :: (y₀ == add(y₀, zero))
forall x₁: list :: (x₁ == append(x₁, nil))
forall y₀: list, y₁: nat, x₁: list :: (append(snoc(y₀, y₁), x₁) == append(append(y₀, nil), cons(y₁, x₁)))
forall y₀: nat, y₁: nat :: (succ(add(y₀, y₁)) == add(y₀, succ(y₁)))
forall y₀: list, x₁: nat :: (add(length(y₀), x₁) == add(add(x₁, zero), length(y₀)))
forall x₀: [nat]Bool, y₀: nat, y₁: list :: (filter(x₀, remove(y₀, y₁)) == remove(add(y₀, zero), filter(x₀, y₁)))
forall y₀: list, y₁: list, x₁: nat :: (snoc(append(y₀, y₁), x₁) == append(append(y₀, nil), snoc(y₁, x₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(add(y₁, y₀), add(x₁, zero)))
forall x₀: nat, y₀: [nat]Bool, y₁: list :: (add(x₀, countif(y₀, y₁)) == add(countif(y₀, y₁), add(x₀, zero)))
forall x₀: nat, y₀: nat, y₁: list :: (add(x₀, count(y₀, y₁)) == add(count(y₀, y₁), x₀))
forall y₀: list, y₁: nat :: (length(snoc(y₀, y₁)) == add(length(y₀), succ(zero)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), append(y₁, nil)))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(y₀, add(y₁, x₀)))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(y₁, add(y₀, x₀)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), y₁))
forall x₀: nat, y₀: list :: (cons(x₀, reverse(y₀)) == reverse(snoc(y₀, x₀)))
forall y₀: list :: (reverse(reverse(y₀)) == take(length(y₀), snoc(y₀, zero)))
forall x₀: list, y₀: list :: (append(x₀, reverse(y₀)) == append(drop(zero, x₀), reverse(y₀)))
forall y₀: list, x₁: list :: (count(length(y₀), x₁) == count(length(y₀), rotate(zero, x₁)))
forall y₀: nat, y₁: list, x₁: list :: (append(take(y₀, y₁), x₁) == append(take(y₀, y₁), rotate(zero, x₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(x₁, add(y₁, y₀)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(add(y₀, y₁), x₀))
forall y₀: list :: (reverse(reverse(y₀)) == rotate(zero, y₀))
forall y₀: list :: (length(reverse(y₀)) == length(append(y₀, nil)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(reverse(y₁)))
forall x₀: list, y₀: list, y₁: nat :: (append(x₀, snoc(y₀, y₁)) == snoc(append(x₀, y₀), add(y₁, zero)))
forall y₀: list :: (reverse(reverse(y₀)) == append(take(zero, y₀), rotate(zero, y₀)))
forall y₀: list :: (reverse(reverse(y₀)) == drop(zero, drop(zero, y₀)))
forall y₀: nat, x₁: nat :: (succ(add(y₀, x₁)) == add(x₁, succ(y₀)))
forall y₀: list :: (reverse(reverse(y₀)) == append(rotate(zero, y₀), take(zero, y₀)))
  27  reduced greedily
forall y₀: nat :: (y₀ == add(y₀, zero))
forall x₁: list :: (x₁ == append(x₁, nil))
forall y₀: list, y₁: nat, x₁: list :: (append(snoc(y₀, y₁), x₁) == append(append(y₀, nil), cons(y₁, x₁)))
forall y₀: nat, y₁: nat :: (succ(add(y₀, y₁)) == add(y₀, succ(y₁)))
forall y₀: list, x₁: nat :: (add(length(y₀), x₁) == add(add(x₁, zero), length(y₀)))
forall x₀: [nat]Bool, y₀: nat, y₁: list :: (filter(x₀, remove(y₀, y₁)) == remove(add(y₀, zero), filter(x₀, y₁)))
forall y₀: list, y₁: list, x₁: nat :: (snoc(append(y₀, y₁), x₁) == append(append(y₀, nil), snoc(y₁, x₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(add(y₁, y₀), add(x₁, zero)))
forall x₀: nat, y₀: [nat]Bool, y₁: list :: (add(x₀, countif(y₀, y₁)) == add(countif(y₀, y₁), add(x₀, zero)))
forall x₀: nat, y₀: nat, y₁: list :: (add(x₀, count(y₀, y₁)) == add(count(y₀, y₁), x₀))
forall y₀: list, y₁: nat :: (length(snoc(y₀, y₁)) == add(length(y₀), succ(zero)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), append(y₁, nil)))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(y₀, add(y₁, x₀)))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(y₁, add(y₀, x₀)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), y₁))
forall x₀: nat, y₀: list :: (cons(x₀, reverse(y₀)) == reverse(snoc(y₀, x₀)))
forall y₀: list :: (reverse(reverse(y₀)) == take(length(y₀), snoc(y₀, zero)))
forall x₀: list, y₀: list :: (append(x₀, reverse(y₀)) == append(drop(zero, x₀), reverse(y₀)))
forall y₀: list, x₁: list :: (count(length(y₀), x₁) == count(length(y₀), rotate(zero, x₁)))
forall y₀: nat, y₁: list, x₁: list :: (append(take(y₀, y₁), x₁) == append(take(y₀, y₁), rotate(zero, x₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(x₁, add(y₁, y₀)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(add(y₀, y₁), x₀))
forall y₀: list :: (reverse(reverse(y₀)) == rotate(zero, y₀))
forall y₀: list :: (length(reverse(y₀)) == length(append(y₀, nil)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(reverse(y₁)))
forall x₀: list, y₀: list, y₁: nat :: (append(x₀, snoc(y₀, y₁)) == snoc(append(x₀, y₀), add(y₁, zero)))
forall y₀: list :: (reverse(reverse(y₀)) == append(take(zero, y₀), rotate(zero, y₀)))
forall y₀: list :: (reverse(reverse(y₀)) == drop(zero, drop(zero, y₀)))
forall y₀: nat, x₁: nat :: (succ(add(y₀, x₁)) == add(x₁, succ(y₀)))
forall y₀: list :: (reverse(reverse(y₀)) == append(rotate(zero, y₀), take(zero, y₀)))
  16  independent
forall y₀: nat :: (y₀ == add(y₀, zero))
forall x₁: list :: (x₁ == append(x₁, nil))
forall y₀: list, y₁: nat, x₁: list :: (append(snoc(y₀, y₁), x₁) == append(append(y₀, nil), cons(y₁, x₁)))
forall y₀: nat, y₁: nat :: (succ(add(y₀, y₁)) == add(y₀, succ(y₁)))
forall y₀: list, x₁: nat :: (add(length(y₀), x₁) == add(add(x₁, zero), length(y₀)))
forall x₀: [nat]Bool, y₀: nat, y₁: list :: (filter(x₀, remove(y₀, y₁)) == remove(add(y₀, zero), filter(x₀, y₁)))
forall y₀: list, y₁: list, x₁: nat :: (snoc(append(y₀, y₁), x₁) == append(append(y₀, nil), snoc(y₁, x₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(add(y₁, y₀), add(x₁, zero)))
forall x₀: nat, y₀: [nat]Bool, y₁: list :: (add(x₀, countif(y₀, y₁)) == add(countif(y₀, y₁), add(x₀, zero)))
forall x₀: nat, y₀: nat, y₁: list :: (add(x₀, count(y₀, y₁)) == add(count(y₀, y₁), x₀))
forall y₀: list, y₁: nat :: (length(snoc(y₀, y₁)) == add(length(y₀), succ(zero)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), append(y₁, nil)))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(y₀, add(y₁, x₀)))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(y₁, add(y₀, x₀)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), y₁))
forall x₀: nat, y₀: list :: (cons(x₀, reverse(y₀)) == reverse(snoc(y₀, x₀)))
forall y₀: list :: (reverse(reverse(y₀)) == take(length(y₀), snoc(y₀, zero)))
forall x₀: list, y₀: list :: (append(x₀, reverse(y₀)) == append(drop(zero, x₀), reverse(y₀)))
forall y₀: list, x₁: list :: (count(length(y₀), x₁) == count(length(y₀), rotate(zero, x₁)))
forall y₀: nat, y₁: list, x₁: list :: (append(take(y₀, y₁), x₁) == append(take(y₀, y₁), rotate(zero, x₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(x₁, add(y₁, y₀)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(add(y₀, y₁), x₀))
forall y₀: list :: (reverse(reverse(y₀)) == rotate(zero, y₀))
forall y₀: list :: (length(reverse(y₀)) == length(append(y₀, nil)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(reverse(y₁)))
forall x₀: list, y₀: list, y₁: nat :: (append(x₀, snoc(y₀, y₁)) == snoc(append(x₀, y₀), add(y₁, zero)))
forall y₀: list :: (reverse(reverse(y₀)) == append(take(zero, y₀), rotate(zero, y₀)))
forall y₀: list :: (reverse(reverse(y₀)) == drop(zero, drop(zero, y₀)))
forall y₀: nat, x₁: nat :: (succ(add(y₀, x₁)) == add(x₁, succ(y₀)))
forall y₀: list :: (reverse(reverse(y₀)) == append(rotate(zero, y₀), take(zero, y₀)))
  17  evaluation/lemmas/list.structural.bpl
forall y₀: nat :: (y₀ == add(y₀, zero))
forall x₁: list :: (x₁ == append(x₁, nil))
forall y₀: list, y₁: nat, x₁: list :: (append(snoc(y₀, y₁), x₁) == append(append(y₀, nil), cons(y₁, x₁)))
forall y₀: nat, y₁: nat :: (succ(add(y₀, y₁)) == add(y₀, succ(y₁)))
forall y₀: list, x₁: nat :: (add(length(y₀), x₁) == add(add(x₁, zero), length(y₀)))
forall x₀: [nat]Bool, y₀: nat, y₁: list :: (filter(x₀, remove(y₀, y₁)) == remove(add(y₀, zero), filter(x₀, y₁)))
forall y₀: list, y₁: list, x₁: nat :: (snoc(append(y₀, y₁), x₁) == append(append(y₀, nil), snoc(y₁, x₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(add(y₁, y₀), add(x₁, zero)))
forall x₀: nat, y₀: [nat]Bool, y₁: list :: (add(x₀, countif(y₀, y₁)) == add(countif(y₀, y₁), add(x₀, zero)))
forall x₀: nat, y₀: nat, y₁: list :: (add(x₀, count(y₀, y₁)) == add(count(y₀, y₁), x₀))
forall y₀: list, y₁: nat :: (length(snoc(y₀, y₁)) == add(length(y₀), succ(zero)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), append(y₁, nil)))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(y₀, add(y₁, x₀)))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(y₁, add(y₀, x₀)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), y₁))
forall x₀: nat, y₀: list :: (cons(x₀, reverse(y₀)) == reverse(snoc(y₀, x₀)))
forall y₀: list :: (reverse(reverse(y₀)) == take(length(y₀), snoc(y₀, zero)))
forall x₀: list, y₀: list :: (append(x₀, reverse(y₀)) == append(drop(zero, x₀), reverse(y₀)))
forall y₀: list, x₁: list :: (count(length(y₀), x₁) == count(length(y₀), rotate(zero, x₁)))
forall y₀: nat, y₁: list, x₁: list :: (append(take(y₀, y₁), x₁) == append(take(y₀, y₁), rotate(zero, x₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(x₁, add(y₁, y₀)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(add(y₀, y₁), x₀))
forall y₀: list :: (reverse(reverse(y₀)) == rotate(zero, y₀))
forall y₀: list :: (length(reverse(y₀)) == length(append(y₀, nil)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(reverse(y₁)))
forall x₀: list, y₀: list, y₁: nat :: (append(x₀, snoc(y₀, y₁)) == snoc(append(x₀, y₀), add(y₁, zero)))
forall y₀: list :: (reverse(reverse(y₀)) == append(take(zero, y₀), rotate(zero, y₀)))
forall y₀: list :: (reverse(reverse(y₀)) == drop(zero, drop(zero, y₀)))
forall y₀: nat, x₁: nat :: (succ(add(y₀, x₁)) == add(x₁, succ(y₀)))
forall y₀: list :: (reverse(reverse(y₀)) == append(rotate(zero, y₀), take(zero, y₀)))
  19  evaluation/lemmas/list.conditional.bpl
forall y₀: nat :: (y₀ == add(y₀, zero))
forall x₁: list :: (x₁ == append(x₁, nil))
forall y₀: list, y₁: nat, x₁: list :: (append(snoc(y₀, y₁), x₁) == append(append(y₀, nil), cons(y₁, x₁)))
forall y₀: nat, y₁: nat :: (succ(add(y₀, y₁)) == add(y₀, succ(y₁)))
forall y₀: list, x₁: nat :: (add(length(y₀), x₁) == add(add(x₁, zero), length(y₀)))
forall x₀: [nat]Bool, y₀: nat, y₁: list :: (filter(x₀, remove(y₀, y₁)) == remove(add(y₀, zero), filter(x₀, y₁)))
forall y₀: list, y₁: list, x₁: nat :: (snoc(append(y₀, y₁), x₁) == append(append(y₀, nil), snoc(y₁, x₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(add(y₁, y₀), add(x₁, zero)))
forall x₀: nat, y₀: [nat]Bool, y₁: list :: (add(x₀, countif(y₀, y₁)) == add(countif(y₀, y₁), add(x₀, zero)))
forall x₀: nat, y₀: nat, y₁: list :: (add(x₀, count(y₀, y₁)) == add(count(y₀, y₁), x₀))
forall y₀: list, y₁: nat :: (length(snoc(y₀, y₁)) == add(length(y₀), succ(zero)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), append(y₁, nil)))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(y₀, add(y₁, x₀)))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(y₁, add(y₀, x₀)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), y₁))
forall x₀: nat, y₀: list :: (cons(x₀, reverse(y₀)) == reverse(snoc(y₀, x₀)))
forall y₀: list :: (reverse(reverse(y₀)) == take(length(y₀), snoc(y₀, zero)))
forall x₀: list, y₀: list :: (append(x₀, reverse(y₀)) == append(drop(zero, x₀), reverse(y₀)))
forall y₀: list, x₁: list :: (count(length(y₀), x₁) == count(length(y₀), rotate(zero, x₁)))
forall y₀: nat, y₁: list, x₁: list :: (append(take(y₀, y₁), x₁) == append(take(y₀, y₁), rotate(zero, x₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(x₁, add(y₁, y₀)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(add(y₀, y₁), x₀))
forall y₀: list :: (reverse(reverse(y₀)) == rotate(zero, y₀))
forall y₀: list :: (length(reverse(y₀)) == length(append(y₀, nil)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(reverse(y₁)))
forall x₀: list, y₀: list, y₁: nat :: (append(x₀, snoc(y₀, y₁)) == snoc(append(x₀, y₀), add(y₁, zero)))
forall y₀: list :: (reverse(reverse(y₀)) == append(take(zero, y₀), rotate(zero, y₀)))
forall y₀: list :: (reverse(reverse(y₀)) == drop(zero, drop(zero, y₀)))
forall y₀: nat, x₁: nat :: (succ(add(y₀, x₁)) == add(x₁, succ(y₀)))
forall y₀: list :: (reverse(reverse(y₀)) == append(rotate(zero, y₀), take(zero, y₀)))
  26  evaluation/lemmas/list.th.log
