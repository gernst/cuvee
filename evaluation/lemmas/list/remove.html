<h1
id="benchmark-evaluationlemmaslistremove-comparison-for-structural">benchmark:
evaluation/lemmas/list/remove comparison for structural</h1>
<h2 id="lemmas-found-by-structural">lemmas found by structural</h2>
<h3 id="reduced">reduced</h3>
<pre><code>forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x: nat :: (add(x, zero) == x)</code></pre>
<h3 id="implied">implied</h3>
<h3 id="trivial">trivial</h3>
<pre><code>forall y₀: Bool :: (not_(not_(y₀)) &lt;==&gt; y₀)</code></pre>
<h2 id="unique-lemmas-found-by-structural">unique lemmas found by
structural</h2>
<h3 id="overall-unique">overall unique</h3>
<h3 id="unique-over-conditional">unique over conditional</h3>
<h3 id="unique-over-enumerate">unique over enumerate</h3>
<h3 id="unique-over-thesy">unique over thesy</h3>
<h2 id="lemmas-confirmed-by-conditional">lemmas confirmed by
conditional</h2>
<h3 id="reduced-1">reduced</h3>
<pre><code>forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x: nat :: (add(x, zero) == x)</code></pre>
<h3 id="implied-1">implied</h3>
<h3 id="trivial-1">trivial</h3>
<pre><code>forall y₀: Bool :: (not_(not_(y₀)) &lt;==&gt; y₀)</code></pre>
<h2 id="lemmas-confirmed-by-enumerate">lemmas confirmed by
enumerate</h2>
<h3 id="reduced-2">reduced</h3>
<pre><code>forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x: nat :: (add(x, zero) == x)</code></pre>
<h3 id="implied-2">implied</h3>
<h3 id="trivial-2">trivial</h3>
<pre><code>forall y₀: Bool :: (not_(not_(y₀)) &lt;==&gt; y₀)</code></pre>
<h2 id="lemmas-confirmed-by-thesy">lemmas confirmed by thesy</h2>
<h3 id="reduced-3">reduced</h3>
<pre><code>forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x: nat :: (add(x, zero) == x)</code></pre>
<h3 id="implied-3">implied</h3>
<h3 id="trivial-3">trivial</h3>
<pre><code>forall y₀: Bool :: (not_(not_(y₀)) &lt;==&gt; y₀)</code></pre>
<h1
id="benchmark-evaluationlemmaslistremove-comparison-for-conditional">benchmark:
evaluation/lemmas/list/remove comparison for conditional</h1>
<h2 id="lemmas-found-by-conditional">lemmas found by conditional</h2>
<h3 id="reduced-4">reduced</h3>
<pre><code>forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x₀: nat, x₁: list, x₂: nat :: (not_(contains(x₀, x₁)) ==&gt; (add(count(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: list :: (not_(contains(x₀, x₁)) ==&gt; (remove(x₀, x₁) == x₁))
forall x₀: nat, x₁: list :: (not_(contains(x₀, x₁)) ==&gt; (count(x₀, x₁) == zero))
forall x: nat :: (add(x, zero) == x)</code></pre>
<h3 id="implied-4">implied</h3>
<h3 id="trivial-4">trivial</h3>
<pre><code>forall y₀: Bool :: (not_(not_(y₀)) &lt;==&gt; y₀)</code></pre>
<h2 id="unique-lemmas-found-by-conditional">unique lemmas found by
conditional</h2>
<h3 id="overall-unique-1">overall unique</h3>
<pre><code>forall x₀: nat, x₁: list, x₂: nat :: (not_(contains(x₀, x₁)) ==&gt; (add(count(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: list :: (not_(contains(x₀, x₁)) ==&gt; (remove(x₀, x₁) == x₁))
forall x₀: nat, x₁: list :: (not_(contains(x₀, x₁)) ==&gt; (count(x₀, x₁) == zero))</code></pre>
<h3 id="unique-over-structural">unique over structural</h3>
<pre><code>forall x₀: nat, x₁: list, x₂: nat :: (not_(contains(x₀, x₁)) ==&gt; (add(count(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: list :: (not_(contains(x₀, x₁)) ==&gt; (remove(x₀, x₁) == x₁))
forall x₀: nat, x₁: list :: (not_(contains(x₀, x₁)) ==&gt; (count(x₀, x₁) == zero))</code></pre>
<h3 id="unique-over-enumerate-1">unique over enumerate</h3>
<pre><code>forall x₀: nat, x₁: list, x₂: nat :: (not_(contains(x₀, x₁)) ==&gt; (add(count(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: list :: (not_(contains(x₀, x₁)) ==&gt; (remove(x₀, x₁) == x₁))
forall x₀: nat, x₁: list :: (not_(contains(x₀, x₁)) ==&gt; (count(x₀, x₁) == zero))</code></pre>
<h3 id="unique-over-thesy-1">unique over thesy</h3>
<pre><code>forall x₀: nat, x₁: list, x₂: nat :: (not_(contains(x₀, x₁)) ==&gt; (add(count(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: list :: (not_(contains(x₀, x₁)) ==&gt; (remove(x₀, x₁) == x₁))
forall x₀: nat, x₁: list :: (not_(contains(x₀, x₁)) ==&gt; (count(x₀, x₁) == zero))</code></pre>
<h2 id="lemmas-confirmed-by-structural">lemmas confirmed by
structural</h2>
<h3 id="reduced-5">reduced</h3>
<pre><code>forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x: nat :: (add(x, zero) == x)</code></pre>
<h3 id="implied-5">implied</h3>
<h3 id="trivial-5">trivial</h3>
<pre><code>forall y₀: Bool :: (not_(not_(y₀)) &lt;==&gt; y₀)</code></pre>
<h2 id="lemmas-confirmed-by-enumerate-1">lemmas confirmed by
enumerate</h2>
<h3 id="reduced-6">reduced</h3>
<pre><code>forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x: nat :: (add(x, zero) == x)</code></pre>
<h3 id="implied-6">implied</h3>
<h3 id="trivial-6">trivial</h3>
<pre><code>forall y₀: Bool :: (not_(not_(y₀)) &lt;==&gt; y₀)</code></pre>
<h2 id="lemmas-confirmed-by-thesy-1">lemmas confirmed by thesy</h2>
<h3 id="reduced-7">reduced</h3>
<pre><code>forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x: nat :: (add(x, zero) == x)</code></pre>
<h3 id="implied-7">implied</h3>
<h3 id="trivial-7">trivial</h3>
<pre><code>forall y₀: Bool :: (not_(not_(y₀)) &lt;==&gt; y₀)</code></pre>
<h1
id="benchmark-evaluationlemmaslistremove-comparison-for-enumerate">benchmark:
evaluation/lemmas/list/remove comparison for enumerate</h1>
<h2 id="lemmas-found-by-enumerate">lemmas found by enumerate</h2>
<h3 id="reduced-8">reduced</h3>
<pre><code>forall x₀: nat :: (x₀ == add(x₀, zero))
forall y₀: nat, y₁: nat :: (succ(add(y₀, y₁)) == add(y₀, succ(y₁)))
forall y₀: list, x₁: nat :: (add(length(y₀), x₁) == add(add(x₁, zero), length(y₀)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(add(y₁, y₀), add(x₁, zero)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(sub(y₀, y₁), x₁) == add(x₁, sub(y₀, y₁)))
forall x₀: nat, y₀: nat, y₁: list :: (add(x₀, count(y₀, y₁)) == add(count(y₀, y₁), x₀))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(y₀, add(y₁, x₀)))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(y₁, add(y₀, x₀)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(add(y₀, x₁), y₁))
forall x₀: nat, y₀: nat :: (sub(x₀, succ(y₀)) == sub(sub(x₀, y₀), succ(zero)))
forall x₀: nat, y₀: nat, y₁: nat :: (sub(x₀, add(y₀, y₁)) == sub(sub(x₀, y₀), add(y₁, zero)))
forall y₀: nat, y₁: nat, x₁: nat :: (sub(sub(y₀, y₁), x₁) == sub(y₀, add(y₁, x₁)))
forall y₀: nat, x₁: nat :: (succ(add(y₀, x₁)) == add(x₁, succ(y₀)))</code></pre>
<h3 id="implied-8">implied</h3>
<pre><code>forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(add(x₀, y₀), y₁))</code></pre>
<h3 id="trivial-8">trivial</h3>
<h2 id="unique-lemmas-found-by-enumerate">unique lemmas found by
enumerate</h2>
<h3 id="overall-unique-2">overall unique</h3>
<pre><code>forall x₀: nat, y₀: nat :: (sub(x₀, succ(y₀)) == sub(sub(x₀, y₀), succ(zero)))
forall x₀: nat, y₀: nat, y₁: nat :: (sub(x₀, add(y₀, y₁)) == sub(sub(x₀, y₀), add(y₁, zero)))
forall y₀: nat, y₁: nat, x₁: nat :: (sub(sub(y₀, y₁), x₁) == sub(y₀, add(y₁, x₁)))</code></pre>
<h3 id="unique-over-structural-1">unique over structural</h3>
<pre><code>forall y₀: nat, y₁: nat :: (succ(add(y₀, y₁)) == add(y₀, succ(y₁)))
forall y₀: list, x₁: nat :: (add(length(y₀), x₁) == add(add(x₁, zero), length(y₀)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(add(y₁, y₀), add(x₁, zero)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(sub(y₀, y₁), x₁) == add(x₁, sub(y₀, y₁)))
forall x₀: nat, y₀: nat, y₁: list :: (add(x₀, count(y₀, y₁)) == add(count(y₀, y₁), x₀))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(y₀, add(y₁, x₀)))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(y₁, add(y₀, x₀)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(add(y₀, x₁), y₁))
forall x₀: nat, y₀: nat :: (sub(x₀, succ(y₀)) == sub(sub(x₀, y₀), succ(zero)))
forall x₀: nat, y₀: nat, y₁: nat :: (sub(x₀, add(y₀, y₁)) == sub(sub(x₀, y₀), add(y₁, zero)))
forall y₀: nat, y₁: nat, x₁: nat :: (sub(sub(y₀, y₁), x₁) == sub(y₀, add(y₁, x₁)))
forall y₀: nat, x₁: nat :: (succ(add(y₀, x₁)) == add(x₁, succ(y₀)))</code></pre>
<h3 id="unique-over-conditional-1">unique over conditional</h3>
<pre><code>forall y₀: nat, y₁: nat :: (succ(add(y₀, y₁)) == add(y₀, succ(y₁)))
forall y₀: list, x₁: nat :: (add(length(y₀), x₁) == add(add(x₁, zero), length(y₀)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(add(y₁, y₀), add(x₁, zero)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(sub(y₀, y₁), x₁) == add(x₁, sub(y₀, y₁)))
forall x₀: nat, y₀: nat, y₁: list :: (add(x₀, count(y₀, y₁)) == add(count(y₀, y₁), x₀))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(y₀, add(y₁, x₀)))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(y₁, add(y₀, x₀)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(add(y₀, x₁), y₁))
forall x₀: nat, y₀: nat :: (sub(x₀, succ(y₀)) == sub(sub(x₀, y₀), succ(zero)))
forall x₀: nat, y₀: nat, y₁: nat :: (sub(x₀, add(y₀, y₁)) == sub(sub(x₀, y₀), add(y₁, zero)))
forall y₀: nat, y₁: nat, x₁: nat :: (sub(sub(y₀, y₁), x₁) == sub(y₀, add(y₁, x₁)))
forall y₀: nat, x₁: nat :: (succ(add(y₀, x₁)) == add(x₁, succ(y₀)))</code></pre>
<h3 id="unique-over-thesy-2">unique over thesy</h3>
<pre><code>forall x₀: nat, y₀: nat :: (sub(x₀, succ(y₀)) == sub(sub(x₀, y₀), succ(zero)))
forall x₀: nat, y₀: nat, y₁: nat :: (sub(x₀, add(y₀, y₁)) == sub(sub(x₀, y₀), add(y₁, zero)))
forall y₀: nat, y₁: nat, x₁: nat :: (sub(sub(y₀, y₁), x₁) == sub(y₀, add(y₁, x₁)))</code></pre>
<h2 id="lemmas-confirmed-by-structural-1">lemmas confirmed by
structural</h2>
<h3 id="reduced-9">reduced</h3>
<pre><code>forall x₀: nat :: (x₀ == add(x₀, zero))</code></pre>
<h3 id="implied-9">implied</h3>
<pre><code>forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(add(x₀, y₀), y₁))</code></pre>
<h3 id="trivial-9">trivial</h3>
<h2 id="lemmas-confirmed-by-conditional-1">lemmas confirmed by
conditional</h2>
<h3 id="reduced-10">reduced</h3>
<pre><code>forall x₀: nat :: (x₀ == add(x₀, zero))</code></pre>
<h3 id="implied-10">implied</h3>
<pre><code>forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(add(x₀, y₀), y₁))</code></pre>
<h3 id="trivial-10">trivial</h3>
<h2 id="lemmas-confirmed-by-thesy-2">lemmas confirmed by thesy</h2>
<h3 id="reduced-11">reduced</h3>
<pre><code>forall x₀: nat :: (x₀ == add(x₀, zero))
forall y₀: nat, y₁: nat :: (succ(add(y₀, y₁)) == add(y₀, succ(y₁)))
forall y₀: list, x₁: nat :: (add(length(y₀), x₁) == add(add(x₁, zero), length(y₀)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(add(y₁, y₀), add(x₁, zero)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(sub(y₀, y₁), x₁) == add(x₁, sub(y₀, y₁)))
forall x₀: nat, y₀: nat, y₁: list :: (add(x₀, count(y₀, y₁)) == add(count(y₀, y₁), x₀))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(y₀, add(y₁, x₀)))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(y₁, add(y₀, x₀)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(add(y₀, x₁), y₁))
forall y₀: nat, x₁: nat :: (succ(add(y₀, x₁)) == add(x₁, succ(y₀)))</code></pre>
<h3 id="implied-11">implied</h3>
<pre><code>forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(add(x₀, y₀), y₁))</code></pre>
<h3 id="trivial-11">trivial</h3>
<h1
id="benchmark-evaluationlemmaslistremove-comparison-for-thesy">benchmark:
evaluation/lemmas/list/remove comparison for thesy</h1>
<h2 id="lemmas-found-by-thesy">lemmas found by thesy</h2>
<h3 id="reduced-12">reduced</h3>
<pre><code>forall ?ts_ph_nat_0: nat :: (add(?ts_ph_nat_0, zero) == ?ts_ph_nat_0)
forall ?ts_ph_nat_0: nat :: (sub(?ts_ph_nat_0, ?ts_ph_nat_0) == sub(zero, ?ts_ph_nat_0))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (add(?ts_ph_nat_0, succ(?ts_ph_nat_1)) == succ(add(?ts_ph_nat_0, ?ts_ph_nat_1)))
forall ?ts_ph_nat_0: nat :: (sub(?ts_ph_nat_0, succ(?ts_ph_nat_0)) == zero)
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat, ?ts_ph_nat_2: nat :: (add(?ts_ph_nat_0, add(?ts_ph_nat_1, ?ts_ph_nat_2)) == add(add(?ts_ph_nat_0, ?ts_ph_nat_1), ?ts_ph_nat_2))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (sub(add(?ts_ph_nat_0, ?ts_ph_nat_1), ?ts_ph_nat_0) == ?ts_ph_nat_1)
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (sub(?ts_ph_nat_0, add(?ts_ph_nat_0, ?ts_ph_nat_1)) == zero)
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (sub(add(?ts_ph_nat_0, ?ts_ph_nat_1), add(?ts_ph_nat_0, ?ts_ph_nat_0)) == sub(?ts_ph_nat_1, ?ts_ph_nat_0))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (sub(add(?ts_ph_nat_0, ?ts_ph_nat_0), add(?ts_ph_nat_0, ?ts_ph_nat_1)) == sub(?ts_ph_nat_0, ?ts_ph_nat_1))
forall ?ts_ph_nat_1: nat, ?ts_ph_nat_0: nat :: (add(?ts_ph_nat_1, ?ts_ph_nat_0) == add(?ts_ph_nat_0, ?ts_ph_nat_1))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (contains(?ts_ph_nat_1, remove(?ts_ph_nat_1, ?ts_ph_list_0)) &lt;==&gt; false)
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (count(?ts_ph_nat_1, remove(?ts_ph_nat_1, ?ts_ph_list_0)) == zero)
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (remove(?ts_ph_nat_1, remove(?ts_ph_nat_1, ?ts_ph_list_0)) == remove(?ts_ph_nat_1, ?ts_ph_list_0))</code></pre>
<h3 id="implied-12">implied</h3>
<pre><code>forall ?ts_ph_nat_0: nat :: (sub(zero, ?ts_ph_nat_0) == sub(?ts_ph_nat_0, ?ts_ph_nat_0))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (succ(add(?ts_ph_nat_0, ?ts_ph_nat_1)) == add(?ts_ph_nat_0, succ(?ts_ph_nat_1)))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat, ?ts_ph_nat_2: nat :: (add(add(?ts_ph_nat_0, ?ts_ph_nat_1), ?ts_ph_nat_2) == add(?ts_ph_nat_0, add(?ts_ph_nat_1, ?ts_ph_nat_2)))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (sub(succ(?ts_ph_nat_0), add(?ts_ph_nat_0, ?ts_ph_nat_1)) == sub(succ(zero), ?ts_ph_nat_1))
forall ?ts_ph_nat_1: nat, ?ts_ph_nat_0: nat :: (sub(?ts_ph_nat_1, ?ts_ph_nat_0) == sub(add(?ts_ph_nat_0, ?ts_ph_nat_1), add(?ts_ph_nat_0, ?ts_ph_nat_0)))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (sub(?ts_ph_nat_0, ?ts_ph_nat_1) == sub(add(?ts_ph_nat_0, ?ts_ph_nat_0), add(?ts_ph_nat_0, ?ts_ph_nat_1)))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (add(?ts_ph_nat_0, ?ts_ph_nat_1) == add(?ts_ph_nat_1, ?ts_ph_nat_0))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (remove(?ts_ph_nat_1, ?ts_ph_list_0) == remove(?ts_ph_nat_1, remove(?ts_ph_nat_1, ?ts_ph_list_0)))</code></pre>
<h3 id="trivial-12">trivial</h3>
<pre><code>forall ?ts_ph_nat_0: nat :: (sub(zero, ?ts_ph_nat_0) == zero)
forall ?ts_ph_nat_0: nat :: (sub(succ(zero), add(?ts_ph_nat_0, ?ts_ph_nat_0)) == sub(succ(zero), ?ts_ph_nat_0))
forall ?ts_ph_nat_0: nat :: (sub(succ(zero), ?ts_ph_nat_0) == sub(succ(zero), add(?ts_ph_nat_0, ?ts_ph_nat_0)))
forall ?ts_ph_nat_0: nat :: (sub(succ(zero), ?ts_ph_nat_0) == count(zero, cons(?ts_ph_nat_0, nil)))
forall ?ts_ph_nat_0: nat :: (count(zero, cons(?ts_ph_nat_0, nil)) == sub(succ(zero), ?ts_ph_nat_0))</code></pre>
<h2 id="unique-lemmas-found-by-thesy">unique lemmas found by thesy</h2>
<h3 id="overall-unique-3">overall unique</h3>
<pre><code>forall ?ts_ph_nat_0: nat :: (sub(?ts_ph_nat_0, ?ts_ph_nat_0) == sub(zero, ?ts_ph_nat_0))
forall ?ts_ph_nat_0: nat :: (sub(zero, ?ts_ph_nat_0) == sub(?ts_ph_nat_0, ?ts_ph_nat_0))
forall ?ts_ph_nat_0: nat :: (sub(?ts_ph_nat_0, succ(?ts_ph_nat_0)) == zero)
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (sub(add(?ts_ph_nat_0, ?ts_ph_nat_1), ?ts_ph_nat_0) == ?ts_ph_nat_1)
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (sub(?ts_ph_nat_0, add(?ts_ph_nat_0, ?ts_ph_nat_1)) == zero)
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (sub(succ(?ts_ph_nat_0), add(?ts_ph_nat_0, ?ts_ph_nat_1)) == sub(succ(zero), ?ts_ph_nat_1))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (sub(add(?ts_ph_nat_0, ?ts_ph_nat_1), add(?ts_ph_nat_0, ?ts_ph_nat_0)) == sub(?ts_ph_nat_1, ?ts_ph_nat_0))
forall ?ts_ph_nat_1: nat, ?ts_ph_nat_0: nat :: (sub(?ts_ph_nat_1, ?ts_ph_nat_0) == sub(add(?ts_ph_nat_0, ?ts_ph_nat_1), add(?ts_ph_nat_0, ?ts_ph_nat_0)))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (sub(add(?ts_ph_nat_0, ?ts_ph_nat_0), add(?ts_ph_nat_0, ?ts_ph_nat_1)) == sub(?ts_ph_nat_0, ?ts_ph_nat_1))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (sub(?ts_ph_nat_0, ?ts_ph_nat_1) == sub(add(?ts_ph_nat_0, ?ts_ph_nat_0), add(?ts_ph_nat_0, ?ts_ph_nat_1)))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (contains(?ts_ph_nat_1, remove(?ts_ph_nat_1, ?ts_ph_list_0)) &lt;==&gt; false)
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (count(?ts_ph_nat_1, remove(?ts_ph_nat_1, ?ts_ph_list_0)) == zero)
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (remove(?ts_ph_nat_1, remove(?ts_ph_nat_1, ?ts_ph_list_0)) == remove(?ts_ph_nat_1, ?ts_ph_list_0))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (remove(?ts_ph_nat_1, ?ts_ph_list_0) == remove(?ts_ph_nat_1, remove(?ts_ph_nat_1, ?ts_ph_list_0)))</code></pre>
<h3 id="unique-over-structural-2">unique over structural</h3>
<pre><code>forall ?ts_ph_nat_0: nat :: (sub(?ts_ph_nat_0, ?ts_ph_nat_0) == sub(zero, ?ts_ph_nat_0))
forall ?ts_ph_nat_0: nat :: (sub(zero, ?ts_ph_nat_0) == sub(?ts_ph_nat_0, ?ts_ph_nat_0))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (add(?ts_ph_nat_0, succ(?ts_ph_nat_1)) == succ(add(?ts_ph_nat_0, ?ts_ph_nat_1)))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (succ(add(?ts_ph_nat_0, ?ts_ph_nat_1)) == add(?ts_ph_nat_0, succ(?ts_ph_nat_1)))
forall ?ts_ph_nat_0: nat :: (sub(?ts_ph_nat_0, succ(?ts_ph_nat_0)) == zero)
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (sub(add(?ts_ph_nat_0, ?ts_ph_nat_1), ?ts_ph_nat_0) == ?ts_ph_nat_1)
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (sub(?ts_ph_nat_0, add(?ts_ph_nat_0, ?ts_ph_nat_1)) == zero)
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (sub(succ(?ts_ph_nat_0), add(?ts_ph_nat_0, ?ts_ph_nat_1)) == sub(succ(zero), ?ts_ph_nat_1))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (sub(add(?ts_ph_nat_0, ?ts_ph_nat_1), add(?ts_ph_nat_0, ?ts_ph_nat_0)) == sub(?ts_ph_nat_1, ?ts_ph_nat_0))
forall ?ts_ph_nat_1: nat, ?ts_ph_nat_0: nat :: (sub(?ts_ph_nat_1, ?ts_ph_nat_0) == sub(add(?ts_ph_nat_0, ?ts_ph_nat_1), add(?ts_ph_nat_0, ?ts_ph_nat_0)))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (sub(add(?ts_ph_nat_0, ?ts_ph_nat_0), add(?ts_ph_nat_0, ?ts_ph_nat_1)) == sub(?ts_ph_nat_0, ?ts_ph_nat_1))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (sub(?ts_ph_nat_0, ?ts_ph_nat_1) == sub(add(?ts_ph_nat_0, ?ts_ph_nat_0), add(?ts_ph_nat_0, ?ts_ph_nat_1)))
forall ?ts_ph_nat_1: nat, ?ts_ph_nat_0: nat :: (add(?ts_ph_nat_1, ?ts_ph_nat_0) == add(?ts_ph_nat_0, ?ts_ph_nat_1))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (add(?ts_ph_nat_0, ?ts_ph_nat_1) == add(?ts_ph_nat_1, ?ts_ph_nat_0))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (contains(?ts_ph_nat_1, remove(?ts_ph_nat_1, ?ts_ph_list_0)) &lt;==&gt; false)
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (count(?ts_ph_nat_1, remove(?ts_ph_nat_1, ?ts_ph_list_0)) == zero)
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (remove(?ts_ph_nat_1, remove(?ts_ph_nat_1, ?ts_ph_list_0)) == remove(?ts_ph_nat_1, ?ts_ph_list_0))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (remove(?ts_ph_nat_1, ?ts_ph_list_0) == remove(?ts_ph_nat_1, remove(?ts_ph_nat_1, ?ts_ph_list_0)))</code></pre>
<h3 id="unique-over-conditional-2">unique over conditional</h3>
<pre><code>forall ?ts_ph_nat_0: nat :: (sub(?ts_ph_nat_0, ?ts_ph_nat_0) == sub(zero, ?ts_ph_nat_0))
forall ?ts_ph_nat_0: nat :: (sub(zero, ?ts_ph_nat_0) == sub(?ts_ph_nat_0, ?ts_ph_nat_0))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (add(?ts_ph_nat_0, succ(?ts_ph_nat_1)) == succ(add(?ts_ph_nat_0, ?ts_ph_nat_1)))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (succ(add(?ts_ph_nat_0, ?ts_ph_nat_1)) == add(?ts_ph_nat_0, succ(?ts_ph_nat_1)))
forall ?ts_ph_nat_0: nat :: (sub(?ts_ph_nat_0, succ(?ts_ph_nat_0)) == zero)
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (sub(add(?ts_ph_nat_0, ?ts_ph_nat_1), ?ts_ph_nat_0) == ?ts_ph_nat_1)
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (sub(?ts_ph_nat_0, add(?ts_ph_nat_0, ?ts_ph_nat_1)) == zero)
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (sub(succ(?ts_ph_nat_0), add(?ts_ph_nat_0, ?ts_ph_nat_1)) == sub(succ(zero), ?ts_ph_nat_1))
forall ?ts_ph_nat_0: nat :: (sub(succ(zero), add(?ts_ph_nat_0, ?ts_ph_nat_0)) == sub(succ(zero), ?ts_ph_nat_0))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (sub(add(?ts_ph_nat_0, ?ts_ph_nat_1), add(?ts_ph_nat_0, ?ts_ph_nat_0)) == sub(?ts_ph_nat_1, ?ts_ph_nat_0))
forall ?ts_ph_nat_1: nat, ?ts_ph_nat_0: nat :: (sub(?ts_ph_nat_1, ?ts_ph_nat_0) == sub(add(?ts_ph_nat_0, ?ts_ph_nat_1), add(?ts_ph_nat_0, ?ts_ph_nat_0)))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (sub(add(?ts_ph_nat_0, ?ts_ph_nat_0), add(?ts_ph_nat_0, ?ts_ph_nat_1)) == sub(?ts_ph_nat_0, ?ts_ph_nat_1))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (sub(?ts_ph_nat_0, ?ts_ph_nat_1) == sub(add(?ts_ph_nat_0, ?ts_ph_nat_0), add(?ts_ph_nat_0, ?ts_ph_nat_1)))
forall ?ts_ph_nat_1: nat, ?ts_ph_nat_0: nat :: (add(?ts_ph_nat_1, ?ts_ph_nat_0) == add(?ts_ph_nat_0, ?ts_ph_nat_1))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (add(?ts_ph_nat_0, ?ts_ph_nat_1) == add(?ts_ph_nat_1, ?ts_ph_nat_0))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (contains(?ts_ph_nat_1, remove(?ts_ph_nat_1, ?ts_ph_list_0)) &lt;==&gt; false)
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (count(?ts_ph_nat_1, remove(?ts_ph_nat_1, ?ts_ph_list_0)) == zero)
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (remove(?ts_ph_nat_1, remove(?ts_ph_nat_1, ?ts_ph_list_0)) == remove(?ts_ph_nat_1, ?ts_ph_list_0))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (remove(?ts_ph_nat_1, ?ts_ph_list_0) == remove(?ts_ph_nat_1, remove(?ts_ph_nat_1, ?ts_ph_list_0)))</code></pre>
<h3 id="unique-over-enumerate-2">unique over enumerate</h3>
<pre><code>forall ?ts_ph_nat_0: nat :: (sub(?ts_ph_nat_0, ?ts_ph_nat_0) == sub(zero, ?ts_ph_nat_0))
forall ?ts_ph_nat_0: nat :: (sub(zero, ?ts_ph_nat_0) == sub(?ts_ph_nat_0, ?ts_ph_nat_0))
forall ?ts_ph_nat_0: nat :: (sub(?ts_ph_nat_0, succ(?ts_ph_nat_0)) == zero)
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (sub(add(?ts_ph_nat_0, ?ts_ph_nat_1), ?ts_ph_nat_0) == ?ts_ph_nat_1)
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (sub(?ts_ph_nat_0, add(?ts_ph_nat_0, ?ts_ph_nat_1)) == zero)
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (sub(succ(?ts_ph_nat_0), add(?ts_ph_nat_0, ?ts_ph_nat_1)) == sub(succ(zero), ?ts_ph_nat_1))
forall ?ts_ph_nat_0: nat :: (sub(succ(zero), add(?ts_ph_nat_0, ?ts_ph_nat_0)) == sub(succ(zero), ?ts_ph_nat_0))
forall ?ts_ph_nat_0: nat :: (sub(succ(zero), ?ts_ph_nat_0) == sub(succ(zero), add(?ts_ph_nat_0, ?ts_ph_nat_0)))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (sub(add(?ts_ph_nat_0, ?ts_ph_nat_1), add(?ts_ph_nat_0, ?ts_ph_nat_0)) == sub(?ts_ph_nat_1, ?ts_ph_nat_0))
forall ?ts_ph_nat_1: nat, ?ts_ph_nat_0: nat :: (sub(?ts_ph_nat_1, ?ts_ph_nat_0) == sub(add(?ts_ph_nat_0, ?ts_ph_nat_1), add(?ts_ph_nat_0, ?ts_ph_nat_0)))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (sub(add(?ts_ph_nat_0, ?ts_ph_nat_0), add(?ts_ph_nat_0, ?ts_ph_nat_1)) == sub(?ts_ph_nat_0, ?ts_ph_nat_1))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (sub(?ts_ph_nat_0, ?ts_ph_nat_1) == sub(add(?ts_ph_nat_0, ?ts_ph_nat_0), add(?ts_ph_nat_0, ?ts_ph_nat_1)))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (contains(?ts_ph_nat_1, remove(?ts_ph_nat_1, ?ts_ph_list_0)) &lt;==&gt; false)
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (count(?ts_ph_nat_1, remove(?ts_ph_nat_1, ?ts_ph_list_0)) == zero)
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (remove(?ts_ph_nat_1, remove(?ts_ph_nat_1, ?ts_ph_list_0)) == remove(?ts_ph_nat_1, ?ts_ph_list_0))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (remove(?ts_ph_nat_1, ?ts_ph_list_0) == remove(?ts_ph_nat_1, remove(?ts_ph_nat_1, ?ts_ph_list_0)))
forall ?ts_ph_nat_0: nat :: (sub(succ(zero), ?ts_ph_nat_0) == count(zero, cons(?ts_ph_nat_0, nil)))
forall ?ts_ph_nat_0: nat :: (count(zero, cons(?ts_ph_nat_0, nil)) == sub(succ(zero), ?ts_ph_nat_0))</code></pre>
<h2 id="lemmas-confirmed-by-structural-2">lemmas confirmed by
structural</h2>
<h3 id="reduced-13">reduced</h3>
<pre><code>forall ?ts_ph_nat_0: nat :: (add(?ts_ph_nat_0, zero) == ?ts_ph_nat_0)
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat, ?ts_ph_nat_2: nat :: (add(?ts_ph_nat_0, add(?ts_ph_nat_1, ?ts_ph_nat_2)) == add(add(?ts_ph_nat_0, ?ts_ph_nat_1), ?ts_ph_nat_2))</code></pre>
<h3 id="implied-13">implied</h3>
<pre><code>forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat, ?ts_ph_nat_2: nat :: (add(add(?ts_ph_nat_0, ?ts_ph_nat_1), ?ts_ph_nat_2) == add(?ts_ph_nat_0, add(?ts_ph_nat_1, ?ts_ph_nat_2)))</code></pre>
<h3 id="trivial-13">trivial</h3>
<pre><code>forall ?ts_ph_nat_0: nat :: (sub(zero, ?ts_ph_nat_0) == zero)
forall ?ts_ph_nat_0: nat :: (sub(succ(zero), add(?ts_ph_nat_0, ?ts_ph_nat_0)) == sub(succ(zero), ?ts_ph_nat_0))
forall ?ts_ph_nat_0: nat :: (sub(succ(zero), ?ts_ph_nat_0) == sub(succ(zero), add(?ts_ph_nat_0, ?ts_ph_nat_0)))
forall ?ts_ph_nat_0: nat :: (sub(succ(zero), ?ts_ph_nat_0) == count(zero, cons(?ts_ph_nat_0, nil)))
forall ?ts_ph_nat_0: nat :: (count(zero, cons(?ts_ph_nat_0, nil)) == sub(succ(zero), ?ts_ph_nat_0))</code></pre>
<h2 id="lemmas-confirmed-by-conditional-2">lemmas confirmed by
conditional</h2>
<h3 id="reduced-14">reduced</h3>
<pre><code>forall ?ts_ph_nat_0: nat :: (add(?ts_ph_nat_0, zero) == ?ts_ph_nat_0)
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat, ?ts_ph_nat_2: nat :: (add(?ts_ph_nat_0, add(?ts_ph_nat_1, ?ts_ph_nat_2)) == add(add(?ts_ph_nat_0, ?ts_ph_nat_1), ?ts_ph_nat_2))</code></pre>
<h3 id="implied-14">implied</h3>
<pre><code>forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat, ?ts_ph_nat_2: nat :: (add(add(?ts_ph_nat_0, ?ts_ph_nat_1), ?ts_ph_nat_2) == add(?ts_ph_nat_0, add(?ts_ph_nat_1, ?ts_ph_nat_2)))</code></pre>
<h3 id="trivial-14">trivial</h3>
<pre><code>forall ?ts_ph_nat_0: nat :: (sub(zero, ?ts_ph_nat_0) == zero)
forall ?ts_ph_nat_0: nat :: (sub(succ(zero), ?ts_ph_nat_0) == sub(succ(zero), add(?ts_ph_nat_0, ?ts_ph_nat_0)))
forall ?ts_ph_nat_0: nat :: (sub(succ(zero), ?ts_ph_nat_0) == count(zero, cons(?ts_ph_nat_0, nil)))
forall ?ts_ph_nat_0: nat :: (count(zero, cons(?ts_ph_nat_0, nil)) == sub(succ(zero), ?ts_ph_nat_0))</code></pre>
<h2 id="lemmas-confirmed-by-enumerate-2">lemmas confirmed by
enumerate</h2>
<h3 id="reduced-15">reduced</h3>
<pre><code>forall ?ts_ph_nat_0: nat :: (add(?ts_ph_nat_0, zero) == ?ts_ph_nat_0)
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (add(?ts_ph_nat_0, succ(?ts_ph_nat_1)) == succ(add(?ts_ph_nat_0, ?ts_ph_nat_1)))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat, ?ts_ph_nat_2: nat :: (add(?ts_ph_nat_0, add(?ts_ph_nat_1, ?ts_ph_nat_2)) == add(add(?ts_ph_nat_0, ?ts_ph_nat_1), ?ts_ph_nat_2))
forall ?ts_ph_nat_1: nat, ?ts_ph_nat_0: nat :: (add(?ts_ph_nat_1, ?ts_ph_nat_0) == add(?ts_ph_nat_0, ?ts_ph_nat_1))</code></pre>
<h3 id="implied-15">implied</h3>
<pre><code>forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (succ(add(?ts_ph_nat_0, ?ts_ph_nat_1)) == add(?ts_ph_nat_0, succ(?ts_ph_nat_1)))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat, ?ts_ph_nat_2: nat :: (add(add(?ts_ph_nat_0, ?ts_ph_nat_1), ?ts_ph_nat_2) == add(?ts_ph_nat_0, add(?ts_ph_nat_1, ?ts_ph_nat_2)))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (add(?ts_ph_nat_0, ?ts_ph_nat_1) == add(?ts_ph_nat_1, ?ts_ph_nat_0))</code></pre>
<h3 id="trivial-15">trivial</h3>
<pre><code>forall ?ts_ph_nat_0: nat :: (sub(zero, ?ts_ph_nat_0) == zero)</code></pre>
