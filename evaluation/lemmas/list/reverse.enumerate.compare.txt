evaluation/lemmas/list/reverse.enumerate.bpl
  24  number of lemmas
  0  wrong
forall x₁: list :: (x₁ == append(x₁, nil))
forall y₀: list :: (reverse(y₀) == nreverse(y₀, nil))
forall y₀: list, y₁: list, x₁: list :: (append(qreverse(y₀, y₁), x₁) == qreverse(y₀, append(y₁, x₁)))
forall x₀: list, y₀: list :: (qreverse(x₀, reverse(y₀)) == append(qreverse(x₀, nil), qreverse(y₀, nil)))
forall y₀: nat, y₁: list :: (append(reverse(y₁), cons(y₀, nil)) == qreverse(y₁, cons(y₀, nil)))
forall x₀: nat, y₀: list :: (cons(x₀, reverse(y₀)) == nreverse(y₀, cons(x₀, nil)))
forall x₀: list, y₀: list, y₁: list :: (qreverse(x₀, append(y₀, y₁)) == qreverse(qreverse(y₀, x₀), y₁))
forall y₀: list, y₁: list :: (reverse(nreverse(y₀, y₁)) == qreverse(reverse(y₀), reverse(y₁)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), append(y₁, nil)))
forall y₀: list, x₁: list :: (append(reverse(y₀), x₁) == qreverse(append(y₀, nil), x₁))
forall x₀: list, y₀: list :: (append(x₀, reverse(y₀)) == qreverse(reverse(x₀), qreverse(y₀, nil)))
forall x₀: list, y₀: list :: (nreverse(x₀, reverse(y₀)) == qreverse(append(y₀, nil), nreverse(x₀, nil)))
forall y₀: list, y₁: list, x₁: list :: (qreverse(append(y₀, y₁), x₁) == qreverse(y₁, qreverse(y₀, x₁)))
forall x₀: list, y₀: list, y₁: list :: (qreverse(x₀, nreverse(y₀, y₁)) == nreverse(nreverse(y₁, y₀), qreverse(x₀, nil)))
forall y₀: list, y₁: list, x₁: list :: (append(nreverse(y₀, y₁), x₁) == qreverse(qreverse(y₁, nil), qreverse(y₀, x₁)))
forall x₀: list, y₀: list, y₁: list :: (nreverse(x₀, append(y₀, y₁)) == append(append(y₀, y₁), nreverse(x₀, nil)))
forall x₀: list, y₀: nat, y₁: list :: (append(x₀, cons(y₀, y₁)) == qreverse(nreverse(x₀, nil), cons(y₀, y₁)))
forall x₀: nat, y₀: list, y₁: list :: (cons(x₀, append(y₀, y₁)) == nreverse(qreverse(y₁, nil), cons(x₀, y₀)))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == nreverse(append(y₀, nil), nreverse(y₁, nil)))
forall y₀: list, y₁: list, x₁: list :: (qreverse(nreverse(y₀, y₁), x₁) == append(y₀, qreverse(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (nreverse(append(y₀, y₁), x₁) == qreverse(nreverse(x₁, y₁), nreverse(y₀, nil)))
forall x₀: list, y₀: list, y₁: list :: (nreverse(x₀, qreverse(y₀, y₁)) == append(reverse(y₀), nreverse(x₀, y₁)))
forall x₀: list, y₀: list, y₁: list :: (qreverse(x₀, qreverse(y₀, y₁)) == nreverse(qreverse(y₁, y₀), qreverse(x₀, nil)))
forall y₀: list, y₁: list, x₁: list :: (append(nreverse(y₀, y₁), x₁) == nreverse(qreverse(x₁, y₀), y₁))
  24  nontrivial
forall x₁: list :: (x₁ == append(x₁, nil))
forall y₀: list :: (reverse(y₀) == nreverse(y₀, nil))
forall y₀: list, y₁: list, x₁: list :: (append(qreverse(y₀, y₁), x₁) == qreverse(y₀, append(y₁, x₁)))
forall x₀: list, y₀: list :: (qreverse(x₀, reverse(y₀)) == append(qreverse(x₀, nil), qreverse(y₀, nil)))
forall y₀: nat, y₁: list :: (append(reverse(y₁), cons(y₀, nil)) == qreverse(y₁, cons(y₀, nil)))
forall x₀: nat, y₀: list :: (cons(x₀, reverse(y₀)) == nreverse(y₀, cons(x₀, nil)))
forall x₀: list, y₀: list, y₁: list :: (qreverse(x₀, append(y₀, y₁)) == qreverse(qreverse(y₀, x₀), y₁))
forall y₀: list, y₁: list :: (reverse(nreverse(y₀, y₁)) == qreverse(reverse(y₀), reverse(y₁)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), append(y₁, nil)))
forall y₀: list, x₁: list :: (append(reverse(y₀), x₁) == qreverse(append(y₀, nil), x₁))
forall x₀: list, y₀: list :: (append(x₀, reverse(y₀)) == qreverse(reverse(x₀), qreverse(y₀, nil)))
forall x₀: list, y₀: list :: (nreverse(x₀, reverse(y₀)) == qreverse(append(y₀, nil), nreverse(x₀, nil)))
forall y₀: list, y₁: list, x₁: list :: (qreverse(append(y₀, y₁), x₁) == qreverse(y₁, qreverse(y₀, x₁)))
forall x₀: list, y₀: list, y₁: list :: (qreverse(x₀, nreverse(y₀, y₁)) == nreverse(nreverse(y₁, y₀), qreverse(x₀, nil)))
forall y₀: list, y₁: list, x₁: list :: (append(nreverse(y₀, y₁), x₁) == qreverse(qreverse(y₁, nil), qreverse(y₀, x₁)))
forall x₀: list, y₀: list, y₁: list :: (nreverse(x₀, append(y₀, y₁)) == append(append(y₀, y₁), nreverse(x₀, nil)))
forall x₀: list, y₀: nat, y₁: list :: (append(x₀, cons(y₀, y₁)) == qreverse(nreverse(x₀, nil), cons(y₀, y₁)))
forall x₀: nat, y₀: list, y₁: list :: (cons(x₀, append(y₀, y₁)) == nreverse(qreverse(y₁, nil), cons(x₀, y₀)))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == nreverse(append(y₀, nil), nreverse(y₁, nil)))
forall y₀: list, y₁: list, x₁: list :: (qreverse(nreverse(y₀, y₁), x₁) == append(y₀, qreverse(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (nreverse(append(y₀, y₁), x₁) == qreverse(nreverse(x₁, y₁), nreverse(y₀, nil)))
forall x₀: list, y₀: list, y₁: list :: (nreverse(x₀, qreverse(y₀, y₁)) == append(reverse(y₀), nreverse(x₀, y₁)))
forall x₀: list, y₀: list, y₁: list :: (qreverse(x₀, qreverse(y₀, y₁)) == nreverse(qreverse(y₁, y₀), qreverse(x₀, nil)))
forall y₀: list, y₁: list, x₁: list :: (append(nreverse(y₀, y₁), x₁) == nreverse(qreverse(x₁, y₀), y₁))
  8  reduced greedily
forall x₁: list :: (x₁ == append(x₁, nil))
forall y₀: list :: (reverse(y₀) == nreverse(y₀, nil))
forall y₀: list, y₁: list, x₁: list :: (append(qreverse(y₀, y₁), x₁) == qreverse(y₀, append(y₁, x₁)))
forall x₀: list, y₀: list :: (qreverse(x₀, reverse(y₀)) == append(qreverse(x₀, nil), qreverse(y₀, nil)))
forall y₀: nat, y₁: list :: (append(reverse(y₁), cons(y₀, nil)) == qreverse(y₁, cons(y₀, nil)))
forall x₀: nat, y₀: list :: (cons(x₀, reverse(y₀)) == nreverse(y₀, cons(x₀, nil)))
forall x₀: list, y₀: list, y₁: list :: (qreverse(x₀, append(y₀, y₁)) == qreverse(qreverse(y₀, x₀), y₁))
forall y₀: list, y₁: list :: (reverse(nreverse(y₀, y₁)) == qreverse(reverse(y₀), reverse(y₁)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), append(y₁, nil)))
forall y₀: list, x₁: list :: (append(reverse(y₀), x₁) == qreverse(append(y₀, nil), x₁))
forall x₀: list, y₀: list :: (append(x₀, reverse(y₀)) == qreverse(reverse(x₀), qreverse(y₀, nil)))
forall x₀: list, y₀: list :: (nreverse(x₀, reverse(y₀)) == qreverse(append(y₀, nil), nreverse(x₀, nil)))
forall y₀: list, y₁: list, x₁: list :: (qreverse(append(y₀, y₁), x₁) == qreverse(y₁, qreverse(y₀, x₁)))
forall x₀: list, y₀: list, y₁: list :: (qreverse(x₀, nreverse(y₀, y₁)) == nreverse(nreverse(y₁, y₀), qreverse(x₀, nil)))
forall y₀: list, y₁: list, x₁: list :: (append(nreverse(y₀, y₁), x₁) == qreverse(qreverse(y₁, nil), qreverse(y₀, x₁)))
forall x₀: list, y₀: list, y₁: list :: (nreverse(x₀, append(y₀, y₁)) == append(append(y₀, y₁), nreverse(x₀, nil)))
forall x₀: list, y₀: nat, y₁: list :: (append(x₀, cons(y₀, y₁)) == qreverse(nreverse(x₀, nil), cons(y₀, y₁)))
forall x₀: nat, y₀: list, y₁: list :: (cons(x₀, append(y₀, y₁)) == nreverse(qreverse(y₁, nil), cons(x₀, y₀)))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == nreverse(append(y₀, nil), nreverse(y₁, nil)))
forall y₀: list, y₁: list, x₁: list :: (qreverse(nreverse(y₀, y₁), x₁) == append(y₀, qreverse(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (nreverse(append(y₀, y₁), x₁) == qreverse(nreverse(x₁, y₁), nreverse(y₀, nil)))
forall x₀: list, y₀: list, y₁: list :: (nreverse(x₀, qreverse(y₀, y₁)) == append(reverse(y₀), nreverse(x₀, y₁)))
forall x₀: list, y₀: list, y₁: list :: (qreverse(x₀, qreverse(y₀, y₁)) == nreverse(qreverse(y₁, y₀), qreverse(x₀, nil)))
forall y₀: list, y₁: list, x₁: list :: (append(nreverse(y₀, y₁), x₁) == nreverse(qreverse(x₁, y₀), y₁))
  0  independent
forall x₁: list :: (x₁ == append(x₁, nil))
forall y₀: list :: (reverse(y₀) == nreverse(y₀, nil))
forall y₀: list, y₁: list, x₁: list :: (append(qreverse(y₀, y₁), x₁) == qreverse(y₀, append(y₁, x₁)))
forall x₀: list, y₀: list :: (qreverse(x₀, reverse(y₀)) == append(qreverse(x₀, nil), qreverse(y₀, nil)))
forall y₀: nat, y₁: list :: (append(reverse(y₁), cons(y₀, nil)) == qreverse(y₁, cons(y₀, nil)))
forall x₀: nat, y₀: list :: (cons(x₀, reverse(y₀)) == nreverse(y₀, cons(x₀, nil)))
forall x₀: list, y₀: list, y₁: list :: (qreverse(x₀, append(y₀, y₁)) == qreverse(qreverse(y₀, x₀), y₁))
forall y₀: list, y₁: list :: (reverse(nreverse(y₀, y₁)) == qreverse(reverse(y₀), reverse(y₁)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), append(y₁, nil)))
forall y₀: list, x₁: list :: (append(reverse(y₀), x₁) == qreverse(append(y₀, nil), x₁))
forall x₀: list, y₀: list :: (append(x₀, reverse(y₀)) == qreverse(reverse(x₀), qreverse(y₀, nil)))
forall x₀: list, y₀: list :: (nreverse(x₀, reverse(y₀)) == qreverse(append(y₀, nil), nreverse(x₀, nil)))
forall y₀: list, y₁: list, x₁: list :: (qreverse(append(y₀, y₁), x₁) == qreverse(y₁, qreverse(y₀, x₁)))
forall x₀: list, y₀: list, y₁: list :: (qreverse(x₀, nreverse(y₀, y₁)) == nreverse(nreverse(y₁, y₀), qreverse(x₀, nil)))
forall y₀: list, y₁: list, x₁: list :: (append(nreverse(y₀, y₁), x₁) == qreverse(qreverse(y₁, nil), qreverse(y₀, x₁)))
forall x₀: list, y₀: list, y₁: list :: (nreverse(x₀, append(y₀, y₁)) == append(append(y₀, y₁), nreverse(x₀, nil)))
forall x₀: list, y₀: nat, y₁: list :: (append(x₀, cons(y₀, y₁)) == qreverse(nreverse(x₀, nil), cons(y₀, y₁)))
forall x₀: nat, y₀: list, y₁: list :: (cons(x₀, append(y₀, y₁)) == nreverse(qreverse(y₁, nil), cons(x₀, y₀)))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == nreverse(append(y₀, nil), nreverse(y₁, nil)))
forall y₀: list, y₁: list, x₁: list :: (qreverse(nreverse(y₀, y₁), x₁) == append(y₀, qreverse(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (nreverse(append(y₀, y₁), x₁) == qreverse(nreverse(x₁, y₁), nreverse(y₀, nil)))
forall x₀: list, y₀: list, y₁: list :: (nreverse(x₀, qreverse(y₀, y₁)) == append(reverse(y₀), nreverse(x₀, y₁)))
forall x₀: list, y₀: list, y₁: list :: (qreverse(x₀, qreverse(y₀, y₁)) == nreverse(qreverse(y₁, y₀), qreverse(x₀, nil)))
forall y₀: list, y₁: list, x₁: list :: (append(nreverse(y₀, y₁), x₁) == nreverse(qreverse(x₁, y₀), y₁))
  0  evaluation/lemmas/list/reverse.structural.bpl
forall x₁: list :: (x₁ == append(x₁, nil))
forall y₀: list :: (reverse(y₀) == nreverse(y₀, nil))
forall y₀: list, y₁: list, x₁: list :: (append(qreverse(y₀, y₁), x₁) == qreverse(y₀, append(y₁, x₁)))
forall x₀: list, y₀: list :: (qreverse(x₀, reverse(y₀)) == append(qreverse(x₀, nil), qreverse(y₀, nil)))
forall y₀: nat, y₁: list :: (append(reverse(y₁), cons(y₀, nil)) == qreverse(y₁, cons(y₀, nil)))
forall x₀: nat, y₀: list :: (cons(x₀, reverse(y₀)) == nreverse(y₀, cons(x₀, nil)))
forall x₀: list, y₀: list, y₁: list :: (qreverse(x₀, append(y₀, y₁)) == qreverse(qreverse(y₀, x₀), y₁))
forall y₀: list, y₁: list :: (reverse(nreverse(y₀, y₁)) == qreverse(reverse(y₀), reverse(y₁)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), append(y₁, nil)))
forall y₀: list, x₁: list :: (append(reverse(y₀), x₁) == qreverse(append(y₀, nil), x₁))
forall x₀: list, y₀: list :: (append(x₀, reverse(y₀)) == qreverse(reverse(x₀), qreverse(y₀, nil)))
forall x₀: list, y₀: list :: (nreverse(x₀, reverse(y₀)) == qreverse(append(y₀, nil), nreverse(x₀, nil)))
forall y₀: list, y₁: list, x₁: list :: (qreverse(append(y₀, y₁), x₁) == qreverse(y₁, qreverse(y₀, x₁)))
forall x₀: list, y₀: list, y₁: list :: (qreverse(x₀, nreverse(y₀, y₁)) == nreverse(nreverse(y₁, y₀), qreverse(x₀, nil)))
forall y₀: list, y₁: list, x₁: list :: (append(nreverse(y₀, y₁), x₁) == qreverse(qreverse(y₁, nil), qreverse(y₀, x₁)))
forall x₀: list, y₀: list, y₁: list :: (nreverse(x₀, append(y₀, y₁)) == append(append(y₀, y₁), nreverse(x₀, nil)))
forall x₀: list, y₀: nat, y₁: list :: (append(x₀, cons(y₀, y₁)) == qreverse(nreverse(x₀, nil), cons(y₀, y₁)))
forall x₀: nat, y₀: list, y₁: list :: (cons(x₀, append(y₀, y₁)) == nreverse(qreverse(y₁, nil), cons(x₀, y₀)))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == nreverse(append(y₀, nil), nreverse(y₁, nil)))
forall y₀: list, y₁: list, x₁: list :: (qreverse(nreverse(y₀, y₁), x₁) == append(y₀, qreverse(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (nreverse(append(y₀, y₁), x₁) == qreverse(nreverse(x₁, y₁), nreverse(y₀, nil)))
forall x₀: list, y₀: list, y₁: list :: (nreverse(x₀, qreverse(y₀, y₁)) == append(reverse(y₀), nreverse(x₀, y₁)))
forall x₀: list, y₀: list, y₁: list :: (qreverse(x₀, qreverse(y₀, y₁)) == nreverse(qreverse(y₁, y₀), qreverse(x₀, nil)))
forall y₀: list, y₁: list, x₁: list :: (append(nreverse(y₀, y₁), x₁) == nreverse(qreverse(x₁, y₀), y₁))
  0  evaluation/lemmas/list/reverse.conditional.bpl
forall x₁: list :: (x₁ == append(x₁, nil))
forall y₀: list :: (reverse(y₀) == nreverse(y₀, nil))
forall y₀: list, y₁: list, x₁: list :: (append(qreverse(y₀, y₁), x₁) == qreverse(y₀, append(y₁, x₁)))
forall x₀: list, y₀: list :: (qreverse(x₀, reverse(y₀)) == append(qreverse(x₀, nil), qreverse(y₀, nil)))
forall y₀: nat, y₁: list :: (append(reverse(y₁), cons(y₀, nil)) == qreverse(y₁, cons(y₀, nil)))
forall x₀: nat, y₀: list :: (cons(x₀, reverse(y₀)) == nreverse(y₀, cons(x₀, nil)))
forall x₀: list, y₀: list, y₁: list :: (qreverse(x₀, append(y₀, y₁)) == qreverse(qreverse(y₀, x₀), y₁))
forall y₀: list, y₁: list :: (reverse(nreverse(y₀, y₁)) == qreverse(reverse(y₀), reverse(y₁)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), append(y₁, nil)))
forall y₀: list, x₁: list :: (append(reverse(y₀), x₁) == qreverse(append(y₀, nil), x₁))
forall x₀: list, y₀: list :: (append(x₀, reverse(y₀)) == qreverse(reverse(x₀), qreverse(y₀, nil)))
forall x₀: list, y₀: list :: (nreverse(x₀, reverse(y₀)) == qreverse(append(y₀, nil), nreverse(x₀, nil)))
forall y₀: list, y₁: list, x₁: list :: (qreverse(append(y₀, y₁), x₁) == qreverse(y₁, qreverse(y₀, x₁)))
forall x₀: list, y₀: list, y₁: list :: (qreverse(x₀, nreverse(y₀, y₁)) == nreverse(nreverse(y₁, y₀), qreverse(x₀, nil)))
forall y₀: list, y₁: list, x₁: list :: (append(nreverse(y₀, y₁), x₁) == qreverse(qreverse(y₁, nil), qreverse(y₀, x₁)))
forall x₀: list, y₀: list, y₁: list :: (nreverse(x₀, append(y₀, y₁)) == append(append(y₀, y₁), nreverse(x₀, nil)))
forall x₀: list, y₀: nat, y₁: list :: (append(x₀, cons(y₀, y₁)) == qreverse(nreverse(x₀, nil), cons(y₀, y₁)))
forall x₀: nat, y₀: list, y₁: list :: (cons(x₀, append(y₀, y₁)) == nreverse(qreverse(y₁, nil), cons(x₀, y₀)))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == nreverse(append(y₀, nil), nreverse(y₁, nil)))
forall y₀: list, y₁: list, x₁: list :: (qreverse(nreverse(y₀, y₁), x₁) == append(y₀, qreverse(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (nreverse(append(y₀, y₁), x₁) == qreverse(nreverse(x₁, y₁), nreverse(y₀, nil)))
forall x₀: list, y₀: list, y₁: list :: (nreverse(x₀, qreverse(y₀, y₁)) == append(reverse(y₀), nreverse(x₀, y₁)))
forall x₀: list, y₀: list, y₁: list :: (qreverse(x₀, qreverse(y₀, y₁)) == nreverse(qreverse(y₁, y₀), qreverse(x₀, nil)))
forall y₀: list, y₁: list, x₁: list :: (append(nreverse(y₀, y₁), x₁) == nreverse(qreverse(x₁, y₀), y₁))
  0  evaluation/lemmas/list/reverse.th.log
