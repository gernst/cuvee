evaluation/lemmas/list/rotate.enumerate.bpl
  20  number of lemmas
  0  wrong
forall y₀: nat, y₁: nat :: (succ(add(y₀, y₁)) == add(y₀, succ(y₁)))
forall x₀: list, y₀: nat, y₁: list :: (append(x₀, rotate(y₀, y₁)) == append(append(x₀, nil), rotate(y₀, y₁)))
forall x₀: list, y₀: nat, y₁: list :: (append(x₀, cons(y₀, y₁)) == append(rotate(zero, x₀), cons(y₀, y₁)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), y₁))
forall y₀: nat :: (y₀ == add(y₀, zero))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(add(y₀, x₁), y₁))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(x₁, add(y₁, y₀)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), rotate(zero, y₁)))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(add(x₀, y₀), y₁))
forall y₀: nat, y₁: nat :: (add(y₀, y₁) == add(y₁, y₀))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall y₀: nat, y₁: list, x₁: list :: (append(rotate(y₀, y₁), x₁) == append(rotate(y₀, y₁), append(x₁, nil)))
forall y₁: list, x₁: list :: (append(y₁, x₁) == append(y₁, rotate(zero, x₁)))
forall y₀: list :: (length(reverse(y₀)) == length(y₀))
forall x₁: list :: (x₁ == append(x₁, nil))
forall x₀: list, y₀: list :: (append(x₀, reverse(y₀)) == append(rotate(zero, x₀), reverse(y₀)))
forall y₀: nat, y₁: list :: (append(reverse(y₁), cons(y₀, nil)) == rotate(length(y₁), cons(y₀, y₁)))
forall x₀: list, y₀: list :: (append(x₀, reverse(y₀)) == rotate(length(y₀), append(y₀, x₀)))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == append(reverse(y₁), reverse(y₀)))
forall y₀: list :: (reverse(reverse(y₀)) == rotate(zero, rotate(zero, y₀)))
  17  nontrivial
forall y₀: nat, y₁: nat :: (succ(add(y₀, y₁)) == add(y₀, succ(y₁)))
forall x₀: list, y₀: nat, y₁: list :: (append(x₀, rotate(y₀, y₁)) == append(append(x₀, nil), rotate(y₀, y₁)))
forall x₀: list, y₀: nat, y₁: list :: (append(x₀, cons(y₀, y₁)) == append(rotate(zero, x₀), cons(y₀, y₁)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), y₁))
forall y₀: nat :: (y₀ == add(y₀, zero))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(add(y₀, x₁), y₁))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(x₁, add(y₁, y₀)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), rotate(zero, y₁)))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(add(x₀, y₀), y₁))
forall y₀: nat, y₁: nat :: (add(y₀, y₁) == add(y₁, y₀))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall y₀: nat, y₁: list, x₁: list :: (append(rotate(y₀, y₁), x₁) == append(rotate(y₀, y₁), append(x₁, nil)))
forall y₁: list, x₁: list :: (append(y₁, x₁) == append(y₁, rotate(zero, x₁)))
forall y₀: list :: (length(reverse(y₀)) == length(y₀))
forall x₁: list :: (x₁ == append(x₁, nil))
forall x₀: list, y₀: list :: (append(x₀, reverse(y₀)) == append(rotate(zero, x₀), reverse(y₀)))
forall y₀: nat, y₁: list :: (append(reverse(y₁), cons(y₀, nil)) == rotate(length(y₁), cons(y₀, y₁)))
forall x₀: list, y₀: list :: (append(x₀, reverse(y₀)) == rotate(length(y₀), append(y₀, x₀)))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == append(reverse(y₁), reverse(y₀)))
forall y₀: list :: (reverse(reverse(y₀)) == rotate(zero, rotate(zero, y₀)))
  17  reduced greedily
forall y₀: nat, y₁: nat :: (succ(add(y₀, y₁)) == add(y₀, succ(y₁)))
forall x₀: list, y₀: nat, y₁: list :: (append(x₀, rotate(y₀, y₁)) == append(append(x₀, nil), rotate(y₀, y₁)))
forall x₀: list, y₀: nat, y₁: list :: (append(x₀, cons(y₀, y₁)) == append(rotate(zero, x₀), cons(y₀, y₁)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), y₁))
forall y₀: nat :: (y₀ == add(y₀, zero))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(add(y₀, x₁), y₁))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(x₁, add(y₁, y₀)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), rotate(zero, y₁)))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(add(x₀, y₀), y₁))
forall y₀: nat, y₁: nat :: (add(y₀, y₁) == add(y₁, y₀))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall y₀: nat, y₁: list, x₁: list :: (append(rotate(y₀, y₁), x₁) == append(rotate(y₀, y₁), append(x₁, nil)))
forall y₁: list, x₁: list :: (append(y₁, x₁) == append(y₁, rotate(zero, x₁)))
forall y₀: list :: (length(reverse(y₀)) == length(y₀))
forall x₁: list :: (x₁ == append(x₁, nil))
forall x₀: list, y₀: list :: (append(x₀, reverse(y₀)) == append(rotate(zero, x₀), reverse(y₀)))
forall y₀: nat, y₁: list :: (append(reverse(y₁), cons(y₀, nil)) == rotate(length(y₁), cons(y₀, y₁)))
forall x₀: list, y₀: list :: (append(x₀, reverse(y₀)) == rotate(length(y₀), append(y₀, x₀)))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == append(reverse(y₁), reverse(y₀)))
forall y₀: list :: (reverse(reverse(y₀)) == rotate(zero, rotate(zero, y₀)))
  7  independent
forall y₀: nat, y₁: nat :: (succ(add(y₀, y₁)) == add(y₀, succ(y₁)))
forall x₀: list, y₀: nat, y₁: list :: (append(x₀, rotate(y₀, y₁)) == append(append(x₀, nil), rotate(y₀, y₁)))
forall x₀: list, y₀: nat, y₁: list :: (append(x₀, cons(y₀, y₁)) == append(rotate(zero, x₀), cons(y₀, y₁)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), y₁))
forall y₀: nat :: (y₀ == add(y₀, zero))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(add(y₀, x₁), y₁))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(x₁, add(y₁, y₀)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), rotate(zero, y₁)))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(add(x₀, y₀), y₁))
forall y₀: nat, y₁: nat :: (add(y₀, y₁) == add(y₁, y₀))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall y₀: nat, y₁: list, x₁: list :: (append(rotate(y₀, y₁), x₁) == append(rotate(y₀, y₁), append(x₁, nil)))
forall y₁: list, x₁: list :: (append(y₁, x₁) == append(y₁, rotate(zero, x₁)))
forall y₀: list :: (length(reverse(y₀)) == length(y₀))
forall x₁: list :: (x₁ == append(x₁, nil))
forall x₀: list, y₀: list :: (append(x₀, reverse(y₀)) == append(rotate(zero, x₀), reverse(y₀)))
forall y₀: nat, y₁: list :: (append(reverse(y₁), cons(y₀, nil)) == rotate(length(y₁), cons(y₀, y₁)))
forall x₀: list, y₀: list :: (append(x₀, reverse(y₀)) == rotate(length(y₀), append(y₀, x₀)))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == append(reverse(y₁), reverse(y₀)))
forall y₀: list :: (reverse(reverse(y₀)) == rotate(zero, rotate(zero, y₀)))
  11  evaluation/lemmas/list/rotate.structural.bpl
forall y₀: nat, y₁: nat :: (succ(add(y₀, y₁)) == add(y₀, succ(y₁)))
forall x₀: list, y₀: nat, y₁: list :: (append(x₀, rotate(y₀, y₁)) == append(append(x₀, nil), rotate(y₀, y₁)))
forall x₀: list, y₀: nat, y₁: list :: (append(x₀, cons(y₀, y₁)) == append(rotate(zero, x₀), cons(y₀, y₁)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), y₁))
forall y₀: nat :: (y₀ == add(y₀, zero))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(add(y₀, x₁), y₁))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(x₁, add(y₁, y₀)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), rotate(zero, y₁)))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(add(x₀, y₀), y₁))
forall y₀: nat, y₁: nat :: (add(y₀, y₁) == add(y₁, y₀))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall y₀: nat, y₁: list, x₁: list :: (append(rotate(y₀, y₁), x₁) == append(rotate(y₀, y₁), append(x₁, nil)))
forall y₁: list, x₁: list :: (append(y₁, x₁) == append(y₁, rotate(zero, x₁)))
forall y₀: list :: (length(reverse(y₀)) == length(y₀))
forall x₁: list :: (x₁ == append(x₁, nil))
forall x₀: list, y₀: list :: (append(x₀, reverse(y₀)) == append(rotate(zero, x₀), reverse(y₀)))
forall y₀: nat, y₁: list :: (append(reverse(y₁), cons(y₀, nil)) == rotate(length(y₁), cons(y₀, y₁)))
forall x₀: list, y₀: list :: (append(x₀, reverse(y₀)) == rotate(length(y₀), append(y₀, x₀)))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == append(reverse(y₁), reverse(y₀)))
forall y₀: list :: (reverse(reverse(y₀)) == rotate(zero, rotate(zero, y₀)))
  12  evaluation/lemmas/list/rotate.conditional.bpl
forall y₀: nat, y₁: nat :: (succ(add(y₀, y₁)) == add(y₀, succ(y₁)))
forall x₀: list, y₀: nat, y₁: list :: (append(x₀, rotate(y₀, y₁)) == append(append(x₀, nil), rotate(y₀, y₁)))
forall x₀: list, y₀: nat, y₁: list :: (append(x₀, cons(y₀, y₁)) == append(rotate(zero, x₀), cons(y₀, y₁)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), y₁))
forall y₀: nat :: (y₀ == add(y₀, zero))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(add(y₀, x₁), y₁))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(x₁, add(y₁, y₀)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), rotate(zero, y₁)))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(add(x₀, y₀), y₁))
forall y₀: nat, y₁: nat :: (add(y₀, y₁) == add(y₁, y₀))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall y₀: nat, y₁: list, x₁: list :: (append(rotate(y₀, y₁), x₁) == append(rotate(y₀, y₁), append(x₁, nil)))
forall y₁: list, x₁: list :: (append(y₁, x₁) == append(y₁, rotate(zero, x₁)))
forall y₀: list :: (length(reverse(y₀)) == length(y₀))
forall x₁: list :: (x₁ == append(x₁, nil))
forall x₀: list, y₀: list :: (append(x₀, reverse(y₀)) == append(rotate(zero, x₀), reverse(y₀)))
forall y₀: nat, y₁: list :: (append(reverse(y₁), cons(y₀, nil)) == rotate(length(y₁), cons(y₀, y₁)))
forall x₀: list, y₀: list :: (append(x₀, reverse(y₀)) == rotate(length(y₀), append(y₀, x₀)))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == append(reverse(y₁), reverse(y₀)))
forall y₀: list :: (reverse(reverse(y₀)) == rotate(zero, rotate(zero, y₀)))
  3  evaluation/lemmas/list/rotate.th.log
