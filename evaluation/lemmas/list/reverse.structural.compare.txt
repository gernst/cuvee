evaluation/lemmas/list/reverse.structural.bpl
  10  number of lemmas
  0  wrong
forall y₀: list :: (reverse(reverse(y₀)) == y₀)
forall y₀: list, x₁: list :: (append(reverse(y₀), x₁) == qreverse(y₀, x₁))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == qreverse(y₁, reverse(y₀)))
forall y₀: list, y₁: list :: (reverse(qreverse(y₀, y₁)) == qreverse(y₁, y₀))
forall y₀: list, y₁: list, x₁: list :: (nreverse(append(y₀, y₁), x₁) == append(x₁, qreverse(y₁, reverse(y₀))))
forall y₀: list, y₁: list, x₁: list :: (nreverse(qreverse(y₀, y₁), x₁) == append(x₁, qreverse(y₁, y₀)))
forall x₀: list, x₁: list :: (nreverse(x₀, x₁) == append(x₁, reverse(x₀)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(qreverse(y₀, y₁), x₁) == qreverse(y₀, append(y₁, x₁)))
forall x: list :: (append(x, nil) == x)
  10  nontrivial
forall y₀: list :: (reverse(reverse(y₀)) == y₀)
forall y₀: list, x₁: list :: (append(reverse(y₀), x₁) == qreverse(y₀, x₁))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == qreverse(y₁, reverse(y₀)))
forall y₀: list, y₁: list :: (reverse(qreverse(y₀, y₁)) == qreverse(y₁, y₀))
forall y₀: list, y₁: list, x₁: list :: (nreverse(append(y₀, y₁), x₁) == append(x₁, qreverse(y₁, reverse(y₀))))
forall y₀: list, y₁: list, x₁: list :: (nreverse(qreverse(y₀, y₁), x₁) == append(x₁, qreverse(y₁, y₀)))
forall x₀: list, x₁: list :: (nreverse(x₀, x₁) == append(x₁, reverse(x₀)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(qreverse(y₀, y₁), x₁) == qreverse(y₀, append(y₁, x₁)))
forall x: list :: (append(x, nil) == x)
  5  reduced greedily
forall y₀: list :: (reverse(reverse(y₀)) == y₀)
forall y₀: list, x₁: list :: (append(reverse(y₀), x₁) == qreverse(y₀, x₁))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == qreverse(y₁, reverse(y₀)))
forall y₀: list, y₁: list :: (reverse(qreverse(y₀, y₁)) == qreverse(y₁, y₀))
forall y₀: list, y₁: list, x₁: list :: (nreverse(append(y₀, y₁), x₁) == append(x₁, qreverse(y₁, reverse(y₀))))
forall y₀: list, y₁: list, x₁: list :: (nreverse(qreverse(y₀, y₁), x₁) == append(x₁, qreverse(y₁, y₀)))
forall x₀: list, x₁: list :: (nreverse(x₀, x₁) == append(x₁, reverse(x₀)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(qreverse(y₀, y₁), x₁) == qreverse(y₀, append(y₁, x₁)))
forall x: list :: (append(x, nil) == x)
  0  independent
forall y₀: list :: (reverse(reverse(y₀)) == y₀)
forall y₀: list, x₁: list :: (append(reverse(y₀), x₁) == qreverse(y₀, x₁))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == qreverse(y₁, reverse(y₀)))
forall y₀: list, y₁: list :: (reverse(qreverse(y₀, y₁)) == qreverse(y₁, y₀))
forall y₀: list, y₁: list, x₁: list :: (nreverse(append(y₀, y₁), x₁) == append(x₁, qreverse(y₁, reverse(y₀))))
forall y₀: list, y₁: list, x₁: list :: (nreverse(qreverse(y₀, y₁), x₁) == append(x₁, qreverse(y₁, y₀)))
forall x₀: list, x₁: list :: (nreverse(x₀, x₁) == append(x₁, reverse(x₀)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(qreverse(y₀, y₁), x₁) == qreverse(y₀, append(y₁, x₁)))
forall x: list :: (append(x, nil) == x)
  0  evaluation/lemmas/list/reverse.conditional.bpl
forall y₀: list :: (reverse(reverse(y₀)) == y₀)
forall y₀: list, x₁: list :: (append(reverse(y₀), x₁) == qreverse(y₀, x₁))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == qreverse(y₁, reverse(y₀)))
forall y₀: list, y₁: list :: (reverse(qreverse(y₀, y₁)) == qreverse(y₁, y₀))
forall y₀: list, y₁: list, x₁: list :: (nreverse(append(y₀, y₁), x₁) == append(x₁, qreverse(y₁, reverse(y₀))))
forall y₀: list, y₁: list, x₁: list :: (nreverse(qreverse(y₀, y₁), x₁) == append(x₁, qreverse(y₁, y₀)))
forall x₀: list, x₁: list :: (nreverse(x₀, x₁) == append(x₁, reverse(x₀)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(qreverse(y₀, y₁), x₁) == qreverse(y₀, append(y₁, x₁)))
forall x: list :: (append(x, nil) == x)
  0  evaluation/lemmas/list/reverse.enumerate.bpl
forall y₀: list :: (reverse(reverse(y₀)) == y₀)
forall y₀: list, x₁: list :: (append(reverse(y₀), x₁) == qreverse(y₀, x₁))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == qreverse(y₁, reverse(y₀)))
forall y₀: list, y₁: list :: (reverse(qreverse(y₀, y₁)) == qreverse(y₁, y₀))
forall y₀: list, y₁: list, x₁: list :: (nreverse(append(y₀, y₁), x₁) == append(x₁, qreverse(y₁, reverse(y₀))))
forall y₀: list, y₁: list, x₁: list :: (nreverse(qreverse(y₀, y₁), x₁) == append(x₁, qreverse(y₁, y₀)))
forall x₀: list, x₁: list :: (nreverse(x₀, x₁) == append(x₁, reverse(x₀)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(qreverse(y₀, y₁), x₁) == qreverse(y₀, append(y₁, x₁)))
forall x: list :: (append(x, nil) == x)
  0  evaluation/lemmas/list/reverse.th.log
