data nat = zero | succ(pred: nat);
data list = nil | cons(head: nat, tail: list);
function not_(x₀: Bool): Bool;
axiom (not_(false) <==> true);
axiom (not_(true) <==> false);
function length(x₀: list): nat;
axiom (length(nil) == zero);
axiom forall x: nat, xs: list :: (length(cons(x, xs)) == succ(length(xs)));
function filter(x₀: [nat]Bool, x₁: list): list;
axiom forall p: [nat]Bool :: (filter(p, nil) == nil);
axiom forall p: [nat]Bool, y: nat, ys: list :: (filter(p, cons(y, ys)) == (if p[y] then cons(y, filter(p, ys)) else filter(p, ys)));
function all(x₀: [nat]Bool, x₁: list): Bool;
axiom forall p: [nat]Bool :: (all(p, nil) <==> true);
axiom forall p: [nat]Bool, y: nat, ys: list :: (all(p, cons(y, ys)) <==> (p[y] && all(p, ys)));
function ex(x₀: [nat]Bool, x₁: list): Bool;
axiom forall p: [nat]Bool :: (ex(p, nil) <==> false);
axiom forall p: [nat]Bool, y: nat, ys: list :: (ex(p, cons(y, ys)) <==> (p[y] || ex(p, ys)));
function countif(x₀: [nat]Bool, x₁: list): nat;
axiom forall p: [nat]Bool :: (countif(p, nil) == zero);
axiom forall p: [nat]Bool, y: nat, ys: list :: (countif(p, cons(y, ys)) == (if p[y] then succ(countif(p, ys)) else countif(p, ys)));
lemma forall y₀: [nat]Bool, y₁: list :: (length(filter(y₀, y₁)) == countif(y₀, y₁));
lemma forall y₀: Bool :: (not_(not_(y₀)) <==> y₀);
