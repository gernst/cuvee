<h1
id="benchmark-evaluationlemmaslistmap-comparison-for-structural">benchmark:
evaluation/lemmas/list/map comparison for structural</h1>
<h2 id="lemmas-found-by-structural">lemmas found by structural</h2>
<h3 id="reduced">reduced</h3>
<pre><code>forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (take(x₀, map(y₀, y₁)) == map(y₀, take(x₀, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (drop(x₀, map(y₀, y₁)) == map(y₀, drop(x₀, y₁)))
forall x: list :: (append(x, nil) == x)</code></pre>
<h3 id="implied">implied</h3>
<h3 id="trivial">trivial</h3>
<h2 id="unique-lemmas-found-by-structural">unique lemmas found by
structural</h2>
<h3 id="overall-unique">overall unique</h3>
<h3 id="unique-over-conditional">unique over conditional</h3>
<h3 id="unique-over-enumerate">unique over enumerate</h3>
<pre><code>forall x₀: nat, y₀: [nat]nat, y₁: list :: (take(x₀, map(y₀, y₁)) == map(y₀, take(x₀, y₁)))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (drop(x₀, map(y₀, y₁)) == map(y₀, drop(x₀, y₁)))</code></pre>
<h3 id="unique-over-thesy">unique over thesy</h3>
<h2 id="lemmas-confirmed-by-conditional">lemmas confirmed by
conditional</h2>
<h3 id="reduced-1">reduced</h3>
<pre><code>forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (take(x₀, map(y₀, y₁)) == map(y₀, take(x₀, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (drop(x₀, map(y₀, y₁)) == map(y₀, drop(x₀, y₁)))
forall x: list :: (append(x, nil) == x)</code></pre>
<h3 id="implied-1">implied</h3>
<h3 id="trivial-1">trivial</h3>
<h2 id="lemmas-confirmed-by-enumerate">lemmas confirmed by
enumerate</h2>
<h3 id="reduced-2">reduced</h3>
<pre><code>forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall x: list :: (append(x, nil) == x)</code></pre>
<h3 id="implied-2">implied</h3>
<h3 id="trivial-2">trivial</h3>
<h2 id="lemmas-confirmed-by-thesy">lemmas confirmed by thesy</h2>
<h3 id="reduced-3">reduced</h3>
<pre><code>forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (take(x₀, map(y₀, y₁)) == map(y₀, take(x₀, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (drop(x₀, map(y₀, y₁)) == map(y₀, drop(x₀, y₁)))
forall x: list :: (append(x, nil) == x)</code></pre>
<h3 id="implied-3">implied</h3>
<h3 id="trivial-3">trivial</h3>
<h1
id="benchmark-evaluationlemmaslistmap-comparison-for-conditional">benchmark:
evaluation/lemmas/list/map comparison for conditional</h1>
<h2 id="lemmas-found-by-conditional">lemmas found by conditional</h2>
<h3 id="reduced-4">reduced</h3>
<pre><code>forall x₀: nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==&gt; (take(x₀, drop(x₁, x₂)) == nil))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall x₀: nat, x₁: list :: (lt(x₀, length(x₁)) ==&gt; (length(take(x₀, x₁)) == x₀))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall x₀: nat, x₁: list :: (lt(x₀, length(x₁)) ==&gt; (leq(x₀, length(x₁)) &lt;==&gt; true))
forall x₀: list, x₁: nat :: (lt(x₁, length(x₀)) ==&gt; (lt(length(x₀), x₁) &lt;==&gt; false))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (take(x₀, map(y₀, y₁)) == map(y₀, take(x₀, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (drop(x₀, map(y₀, y₁)) == map(y₀, drop(x₀, y₁)))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==&gt; (take(x₀, x₁) == x₁))
forall x: list :: (append(x, nil) == x)</code></pre>
<h3 id="implied-4">implied</h3>
<pre><code>forall x₀: nat, x₁: list, x₂: list :: (leq(length(x₁), x₀) ==&gt; (append(drop(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==&gt; (length(drop(x₀, x₁)) == zero))
forall x₀: nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==&gt; (drop(x₀, drop(x₁, x₂)) == nil))
forall x₀: [nat]nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==&gt; (map(x₀, drop(x₁, x₂)) == nil))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==&gt; (drop(x₀, x₁) == nil))</code></pre>
<h3 id="trivial-4">trivial</h3>
<h2 id="unique-lemmas-found-by-conditional">unique lemmas found by
conditional</h2>
<h3 id="overall-unique-1">overall unique</h3>
<pre><code>forall x₀: nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==&gt; (take(x₀, drop(x₁, x₂)) == nil))
forall x₀: nat, x₁: list, x₂: list :: (leq(length(x₁), x₀) ==&gt; (append(drop(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: list :: (lt(x₀, length(x₁)) ==&gt; (length(take(x₀, x₁)) == x₀))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==&gt; (length(drop(x₀, x₁)) == zero))
forall x₀: nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==&gt; (drop(x₀, drop(x₁, x₂)) == nil))
forall x₀: [nat]nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==&gt; (map(x₀, drop(x₁, x₂)) == nil))
forall x₀: nat, x₁: list :: (lt(x₀, length(x₁)) ==&gt; (leq(x₀, length(x₁)) &lt;==&gt; true))
forall x₀: list, x₁: nat :: (lt(x₁, length(x₀)) ==&gt; (lt(length(x₀), x₁) &lt;==&gt; false))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==&gt; (take(x₀, x₁) == x₁))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==&gt; (drop(x₀, x₁) == nil))</code></pre>
<h3 id="unique-over-structural">unique over structural</h3>
<pre><code>forall x₀: nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==&gt; (take(x₀, drop(x₁, x₂)) == nil))
forall x₀: nat, x₁: list, x₂: list :: (leq(length(x₁), x₀) ==&gt; (append(drop(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: list :: (lt(x₀, length(x₁)) ==&gt; (length(take(x₀, x₁)) == x₀))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==&gt; (length(drop(x₀, x₁)) == zero))
forall x₀: nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==&gt; (drop(x₀, drop(x₁, x₂)) == nil))
forall x₀: [nat]nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==&gt; (map(x₀, drop(x₁, x₂)) == nil))
forall x₀: nat, x₁: list :: (lt(x₀, length(x₁)) ==&gt; (leq(x₀, length(x₁)) &lt;==&gt; true))
forall x₀: list, x₁: nat :: (lt(x₁, length(x₀)) ==&gt; (lt(length(x₀), x₁) &lt;==&gt; false))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==&gt; (take(x₀, x₁) == x₁))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==&gt; (drop(x₀, x₁) == nil))</code></pre>
<h3 id="unique-over-enumerate-1">unique over enumerate</h3>
<pre><code>forall x₀: nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==&gt; (take(x₀, drop(x₁, x₂)) == nil))
forall x₀: nat, x₁: list, x₂: list :: (leq(length(x₁), x₀) ==&gt; (append(drop(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: list :: (lt(x₀, length(x₁)) ==&gt; (length(take(x₀, x₁)) == x₀))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==&gt; (length(drop(x₀, x₁)) == zero))
forall x₀: nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==&gt; (drop(x₀, drop(x₁, x₂)) == nil))
forall x₀: [nat]nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==&gt; (map(x₀, drop(x₁, x₂)) == nil))
forall x₀: nat, x₁: list :: (lt(x₀, length(x₁)) ==&gt; (leq(x₀, length(x₁)) &lt;==&gt; true))
forall x₀: list, x₁: nat :: (lt(x₁, length(x₀)) ==&gt; (lt(length(x₀), x₁) &lt;==&gt; false))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (take(x₀, map(y₀, y₁)) == map(y₀, take(x₀, y₁)))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (drop(x₀, map(y₀, y₁)) == map(y₀, drop(x₀, y₁)))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==&gt; (take(x₀, x₁) == x₁))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==&gt; (drop(x₀, x₁) == nil))</code></pre>
<h3 id="unique-over-thesy-1">unique over thesy</h3>
<pre><code>forall x₀: nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==&gt; (take(x₀, drop(x₁, x₂)) == nil))
forall x₀: nat, x₁: list, x₂: list :: (leq(length(x₁), x₀) ==&gt; (append(drop(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: list :: (lt(x₀, length(x₁)) ==&gt; (length(take(x₀, x₁)) == x₀))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==&gt; (length(drop(x₀, x₁)) == zero))
forall x₀: nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==&gt; (drop(x₀, drop(x₁, x₂)) == nil))
forall x₀: [nat]nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==&gt; (map(x₀, drop(x₁, x₂)) == nil))
forall x₀: nat, x₁: list :: (lt(x₀, length(x₁)) ==&gt; (leq(x₀, length(x₁)) &lt;==&gt; true))
forall x₀: list, x₁: nat :: (lt(x₁, length(x₀)) ==&gt; (lt(length(x₀), x₁) &lt;==&gt; false))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==&gt; (take(x₀, x₁) == x₁))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==&gt; (drop(x₀, x₁) == nil))</code></pre>
<h2 id="lemmas-confirmed-by-structural">lemmas confirmed by
structural</h2>
<h3 id="reduced-5">reduced</h3>
<pre><code>forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (take(x₀, map(y₀, y₁)) == map(y₀, take(x₀, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (drop(x₀, map(y₀, y₁)) == map(y₀, drop(x₀, y₁)))
forall x: list :: (append(x, nil) == x)</code></pre>
<h3 id="implied-5">implied</h3>
<h3 id="trivial-5">trivial</h3>
<h2 id="lemmas-confirmed-by-enumerate-1">lemmas confirmed by
enumerate</h2>
<h3 id="reduced-6">reduced</h3>
<pre><code>forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall x: list :: (append(x, nil) == x)</code></pre>
<h3 id="implied-6">implied</h3>
<h3 id="trivial-6">trivial</h3>
<h2 id="lemmas-confirmed-by-thesy-1">lemmas confirmed by thesy</h2>
<h3 id="reduced-7">reduced</h3>
<pre><code>forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (take(x₀, map(y₀, y₁)) == map(y₀, take(x₀, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (drop(x₀, map(y₀, y₁)) == map(y₀, drop(x₀, y₁)))
forall x: list :: (append(x, nil) == x)</code></pre>
<h3 id="implied-7">implied</h3>
<h3 id="trivial-7">trivial</h3>
<h1
id="benchmark-evaluationlemmaslistmap-comparison-for-enumerate">benchmark:
evaluation/lemmas/list/map comparison for enumerate</h1>
<h2 id="lemmas-found-by-enumerate">lemmas found by enumerate</h2>
<h3 id="reduced-8">reduced</h3>
<pre><code>forall x₁: list :: (x₁ == append(x₁, nil))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), append(y₁, nil)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), y₁))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(drop(zero, y₀), append(y₁, x₁)))
forall x₀: nat, y₀: nat, y₁: list :: (take(x₀, take(y₀, y₁)) == take(y₀, take(x₀, y₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall y₀: nat, x₁: nat :: (leq(succ(y₀), x₁) &lt;==&gt; lt(y₀, x₁))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))</code></pre>
<h3 id="implied-8">implied</h3>
<pre><code>forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(drop(zero, y₁)))</code></pre>
<h3 id="trivial-8">trivial</h3>
<pre><code>forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(append(y₀, y₁), drop(zero, x₁)))
forall y₀: [nat]nat, y₁: list, x₁: list :: (append(map(y₀, y₁), x₁) == append(map(y₀, y₁), drop(zero, x₁)))
forall x₀: list, y₀: nat, y₁: list :: (append(x₀, drop(y₀, y₁)) == append(drop(zero, x₀), drop(y₀, y₁)))
forall y₀: nat, y₁: list, x₁: list :: (append(take(y₀, y₁), x₁) == append(take(y₀, y₁), drop(zero, x₁)))
forall y₀: list, x₁: list :: (drop(length(y₀), x₁) == drop(length(y₀), drop(zero, x₁)))
forall y₀: list, x₁: list :: (take(length(y₀), x₁) == take(length(y₀), drop(zero, x₁)))
forall y₀: list, y₁: list :: (append(y₀, y₁) == append(y₀, drop(zero, y₁)))
forall y₀: nat, x₁: list :: (take(succ(y₀), x₁) == take(succ(y₀), drop(zero, x₁)))</code></pre>
<h2 id="unique-lemmas-found-by-enumerate">unique lemmas found by
enumerate</h2>
<h3 id="overall-unique-2">overall unique</h3>
<pre><code>forall x₀: nat, y₀: nat, y₁: list :: (take(x₀, take(y₀, y₁)) == take(y₀, take(x₀, y₁)))</code></pre>
<h3 id="unique-over-structural-1">unique over structural</h3>
<pre><code>forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(drop(zero, y₀), append(y₁, x₁)))
forall x₀: nat, y₀: nat, y₁: list :: (take(x₀, take(y₀, y₁)) == take(y₀, take(x₀, y₁)))
forall y₀: nat, x₁: nat :: (leq(succ(y₀), x₁) &lt;==&gt; lt(y₀, x₁))</code></pre>
<h3 id="unique-over-conditional-1">unique over conditional</h3>
<pre><code>forall x₀: nat, y₀: nat, y₁: list :: (take(x₀, take(y₀, y₁)) == take(y₀, take(x₀, y₁)))
forall x₀: list, y₀: nat, y₁: list :: (append(x₀, drop(y₀, y₁)) == append(drop(zero, x₀), drop(y₀, y₁)))
forall y₀: nat, y₁: list, x₁: list :: (append(take(y₀, y₁), x₁) == append(take(y₀, y₁), drop(zero, x₁)))
forall y₀: nat, x₁: nat :: (leq(succ(y₀), x₁) &lt;==&gt; lt(y₀, x₁))
forall y₀: list, x₁: list :: (take(length(y₀), x₁) == take(length(y₀), drop(zero, x₁)))
forall y₀: nat, x₁: list :: (take(succ(y₀), x₁) == take(succ(y₀), drop(zero, x₁)))</code></pre>
<h3 id="unique-over-thesy-2">unique over thesy</h3>
<pre><code>forall x₀: nat, y₀: nat, y₁: list :: (take(x₀, take(y₀, y₁)) == take(y₀, take(x₀, y₁)))</code></pre>
<h2 id="lemmas-confirmed-by-structural-1">lemmas confirmed by
structural</h2>
<h3 id="reduced-9">reduced</h3>
<pre><code>forall x₁: list :: (x₁ == append(x₁, nil))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), append(y₁, nil)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), y₁))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(drop(zero, y₀), append(y₁, x₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))</code></pre>
<h3 id="implied-9">implied</h3>
<pre><code>forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(drop(zero, y₁)))</code></pre>
<h3 id="trivial-9">trivial</h3>
<pre><code>forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(append(y₀, y₁), drop(zero, x₁)))
forall y₀: [nat]nat, y₁: list, x₁: list :: (append(map(y₀, y₁), x₁) == append(map(y₀, y₁), drop(zero, x₁)))
forall x₀: list, y₀: nat, y₁: list :: (append(x₀, drop(y₀, y₁)) == append(drop(zero, x₀), drop(y₀, y₁)))
forall y₀: nat, y₁: list, x₁: list :: (append(take(y₀, y₁), x₁) == append(take(y₀, y₁), drop(zero, x₁)))
forall y₀: list, x₁: list :: (drop(length(y₀), x₁) == drop(length(y₀), drop(zero, x₁)))
forall y₀: list, x₁: list :: (take(length(y₀), x₁) == take(length(y₀), drop(zero, x₁)))
forall y₀: list, y₁: list :: (append(y₀, y₁) == append(y₀, drop(zero, y₁)))
forall y₀: nat, x₁: list :: (take(succ(y₀), x₁) == take(succ(y₀), drop(zero, x₁)))</code></pre>
<h2 id="lemmas-confirmed-by-conditional-1">lemmas confirmed by
conditional</h2>
<h3 id="reduced-10">reduced</h3>
<pre><code>forall x₁: list :: (x₁ == append(x₁, nil))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), append(y₁, nil)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), y₁))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(drop(zero, y₀), append(y₁, x₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))</code></pre>
<h3 id="implied-10">implied</h3>
<pre><code>forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(drop(zero, y₁)))</code></pre>
<h3 id="trivial-10">trivial</h3>
<pre><code>forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(append(y₀, y₁), drop(zero, x₁)))
forall y₀: [nat]nat, y₁: list, x₁: list :: (append(map(y₀, y₁), x₁) == append(map(y₀, y₁), drop(zero, x₁)))
forall y₀: list, x₁: list :: (drop(length(y₀), x₁) == drop(length(y₀), drop(zero, x₁)))
forall y₀: list, y₁: list :: (append(y₀, y₁) == append(y₀, drop(zero, y₁)))</code></pre>
<h2 id="lemmas-confirmed-by-thesy-2">lemmas confirmed by thesy</h2>
<h3 id="reduced-11">reduced</h3>
<pre><code>forall x₁: list :: (x₁ == append(x₁, nil))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), append(y₁, nil)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), y₁))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(drop(zero, y₀), append(y₁, x₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall y₀: nat, x₁: nat :: (leq(succ(y₀), x₁) &lt;==&gt; lt(y₀, x₁))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))</code></pre>
<h3 id="implied-11">implied</h3>
<pre><code>forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(drop(zero, y₁)))</code></pre>
<h3 id="trivial-11">trivial</h3>
<pre><code>forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(append(y₀, y₁), drop(zero, x₁)))
forall y₀: [nat]nat, y₁: list, x₁: list :: (append(map(y₀, y₁), x₁) == append(map(y₀, y₁), drop(zero, x₁)))
forall x₀: list, y₀: nat, y₁: list :: (append(x₀, drop(y₀, y₁)) == append(drop(zero, x₀), drop(y₀, y₁)))
forall y₀: nat, y₁: list, x₁: list :: (append(take(y₀, y₁), x₁) == append(take(y₀, y₁), drop(zero, x₁)))
forall y₀: list, x₁: list :: (drop(length(y₀), x₁) == drop(length(y₀), drop(zero, x₁)))
forall y₀: list, x₁: list :: (take(length(y₀), x₁) == take(length(y₀), drop(zero, x₁)))
forall y₀: list, y₁: list :: (append(y₀, y₁) == append(y₀, drop(zero, y₁)))
forall y₀: nat, x₁: list :: (take(succ(y₀), x₁) == take(succ(y₀), drop(zero, x₁)))</code></pre>
<h1
id="benchmark-evaluationlemmaslistmap-comparison-for-thesy">benchmark:
evaluation/lemmas/list/map comparison for thesy</h1>
<h2 id="lemmas-found-by-thesy">lemmas found by thesy</h2>
<h3 id="reduced-12">reduced</h3>
<pre><code>forall ?ts_ph_list_0: list :: (drop(zero, ?ts_ph_list_0) == append(?ts_ph_list_0, nil))
forall ?ts_ph_nat_0: nat :: (lt(?ts_ph_nat_0, ?ts_ph_nat_0) &lt;==&gt; false)
forall ?ts_ph_nat_0: nat :: (leq(?ts_ph_nat_0, ?ts_ph_nat_0) &lt;==&gt; true)
forall ?ts_ph_POfn_nat_natPC_1: [nat]nat, ?ts_ph_list_0: list :: (length(map(?ts_ph_POfn_nat_natPC_1, ?ts_ph_list_0)) == length(?ts_ph_list_0))
forall ?ts_ph_list_0: list :: (take(length(?ts_ph_list_0), ?ts_ph_list_0) == ?ts_ph_list_0)
forall ?ts_ph_list_0: list :: (drop(length(?ts_ph_list_0), ?ts_ph_list_0) == nil)
forall ?ts_ph_nat_0: nat :: (lt(succ(?ts_ph_nat_0), ?ts_ph_nat_0) &lt;==&gt; false)
forall ?ts_ph_nat_0: nat :: (leq(?ts_ph_nat_0, succ(?ts_ph_nat_0)) &lt;==&gt; lt(?ts_ph_nat_0, succ(?ts_ph_nat_0)))
forall ?ts_ph_nat_0: nat :: (lt(succ(?ts_ph_nat_0), ?ts_ph_nat_0) &lt;==&gt; leq(succ(?ts_ph_nat_0), ?ts_ph_nat_0))
forall ?ts_ph_list_0: list, ?ts_ph_list_1: list, ?ts_ph_list_2: list :: (append(append(?ts_ph_list_0, ?ts_ph_list_1), ?ts_ph_list_2) == append(?ts_ph_list_0, append(?ts_ph_list_1, ?ts_ph_list_2)))
forall ?ts_ph_list_0: list, ?ts_ph_nat_1: nat :: (leq(length(?ts_ph_list_0), ?ts_ph_nat_1) &lt;==&gt; lt(length(?ts_ph_list_0), succ(?ts_ph_nat_1)))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (lt(?ts_ph_nat_1, length(?ts_ph_list_0)) &lt;==&gt; leq(succ(?ts_ph_nat_1), length(?ts_ph_list_0)))
forall ?ts_ph_list_0: list, ?ts_ph_list_1: list :: (drop(length(?ts_ph_list_0), append(?ts_ph_list_0, ?ts_ph_list_1)) == ?ts_ph_list_1)
forall ?ts_ph_list_0: list, ?ts_ph_list_1: list :: (take(length(?ts_ph_list_0), append(?ts_ph_list_0, ?ts_ph_list_1)) == take(length(?ts_ph_list_0), ?ts_ph_list_0))
forall ?ts_ph_list_0: list :: (take(succ(zero), ?ts_ph_list_0) == take(succ(zero), append(?ts_ph_list_0, ?ts_ph_list_0)))
forall ?ts_ph_POfn_nat_natPC_0: [nat]nat, ?ts_ph_list_0: list, ?ts_ph_list_1: list :: (map(?ts_ph_POfn_nat_natPC_0, append(?ts_ph_list_0, ?ts_ph_list_1)) == append(map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_0), map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_1)))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (leq(?ts_ph_nat_0, ?ts_ph_nat_1) &lt;==&gt; lt(?ts_ph_nat_0, succ(?ts_ph_nat_1)))
forall ?ts_ph_nat_1: nat, ?ts_ph_POfn_nat_natPC_1: [nat]nat, ?ts_ph_list_0: list :: (drop(?ts_ph_nat_1, map(?ts_ph_POfn_nat_natPC_1, ?ts_ph_list_0)) == map(?ts_ph_POfn_nat_natPC_1, drop(?ts_ph_nat_1, ?ts_ph_list_0)))
forall ?ts_ph_nat_1: nat, ?ts_ph_POfn_nat_natPC_1: [nat]nat, ?ts_ph_list_0: list :: (take(?ts_ph_nat_1, map(?ts_ph_POfn_nat_natPC_1, ?ts_ph_list_0)) == map(?ts_ph_POfn_nat_natPC_1, take(?ts_ph_nat_1, ?ts_ph_list_0)))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (drop(?ts_ph_nat_1, take(?ts_ph_nat_1, ?ts_ph_list_0)) == nil)
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (take(?ts_ph_nat_1, ?ts_ph_list_0) == take(?ts_ph_nat_1, take(?ts_ph_nat_1, ?ts_ph_list_0)))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (drop(succ(?ts_ph_nat_1), take(?ts_ph_nat_1, ?ts_ph_list_0)) == nil)
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (take(?ts_ph_nat_1, ?ts_ph_list_0) == take(succ(?ts_ph_nat_1), take(?ts_ph_nat_1, ?ts_ph_list_0)))
forall ?ts_ph_list_0: list, ?ts_ph_nat_1: nat :: (drop(length(?ts_ph_list_0), take(?ts_ph_nat_1, ?ts_ph_list_0)) == nil)
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (take(?ts_ph_nat_1, ?ts_ph_list_0) == take(length(?ts_ph_list_0), take(?ts_ph_nat_1, ?ts_ph_list_0)))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (drop(?ts_ph_nat_1, ?ts_ph_list_0) == take(length(?ts_ph_list_0), drop(?ts_ph_nat_1, ?ts_ph_list_0)))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (drop(succ(zero), drop(?ts_ph_nat_1, ?ts_ph_list_0)) == drop(succ(?ts_ph_nat_1), ?ts_ph_list_0))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (append(take(?ts_ph_nat_1, ?ts_ph_list_0), drop(?ts_ph_nat_1, ?ts_ph_list_0)) == ?ts_ph_list_0)</code></pre>
<h3 id="implied-12">implied</h3>
<pre><code>forall ?ts_ph_list_0: list :: (append(?ts_ph_list_0, nil) == drop(zero, ?ts_ph_list_0))
forall ?ts_ph_nat_0: nat :: (lt(?ts_ph_nat_0, succ(?ts_ph_nat_0)) &lt;==&gt; leq(?ts_ph_nat_0, succ(?ts_ph_nat_0)))
forall ?ts_ph_nat_0: nat :: (leq(succ(?ts_ph_nat_0), ?ts_ph_nat_0) &lt;==&gt; lt(succ(?ts_ph_nat_0), ?ts_ph_nat_0))
forall ?ts_ph_list_0: list, ?ts_ph_list_1: list, ?ts_ph_list_2: list :: (append(?ts_ph_list_0, append(?ts_ph_list_1, ?ts_ph_list_2)) == append(append(?ts_ph_list_0, ?ts_ph_list_1), ?ts_ph_list_2))
forall ?ts_ph_list_0: list, ?ts_ph_nat_1: nat :: (lt(length(?ts_ph_list_0), succ(?ts_ph_nat_1)) &lt;==&gt; leq(length(?ts_ph_list_0), ?ts_ph_nat_1))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (leq(succ(?ts_ph_nat_1), length(?ts_ph_list_0)) &lt;==&gt; lt(?ts_ph_nat_1, length(?ts_ph_list_0)))
forall ?ts_ph_list_0: list, ?ts_ph_POfn_nat_natPC_1: [nat]nat :: (drop(length(?ts_ph_list_0), map(?ts_ph_POfn_nat_natPC_1, ?ts_ph_list_0)) == drop(length(?ts_ph_list_0), ?ts_ph_list_0))
forall ?ts_ph_list_0: list, ?ts_ph_POfn_nat_natPC_0: [nat]nat :: (take(length(?ts_ph_list_0), map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_0)) == map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_0))
forall ?ts_ph_POfn_nat_natPC_0: [nat]nat, ?ts_ph_list_0: list :: (map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_0) == take(length(?ts_ph_list_0), map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_0)))
forall ?ts_ph_POfn_nat_natPC_0: [nat]nat, ?ts_ph_list_0: list, ?ts_ph_list_1: list :: (append(map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_0), map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_1)) == map(?ts_ph_POfn_nat_natPC_0, append(?ts_ph_list_0, ?ts_ph_list_1)))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (lt(?ts_ph_nat_0, succ(?ts_ph_nat_1)) &lt;==&gt; leq(?ts_ph_nat_0, ?ts_ph_nat_1))
forall ?ts_ph_POfn_nat_natPC_1: [nat]nat, ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (map(?ts_ph_POfn_nat_natPC_1, drop(?ts_ph_nat_1, ?ts_ph_list_0)) == drop(?ts_ph_nat_1, map(?ts_ph_POfn_nat_natPC_1, ?ts_ph_list_0)))
forall ?ts_ph_POfn_nat_natPC_1: [nat]nat, ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (map(?ts_ph_POfn_nat_natPC_1, take(?ts_ph_nat_1, ?ts_ph_list_0)) == take(?ts_ph_nat_1, map(?ts_ph_POfn_nat_natPC_1, ?ts_ph_list_0)))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (take(?ts_ph_nat_1, take(?ts_ph_nat_1, ?ts_ph_list_0)) == take(?ts_ph_nat_1, ?ts_ph_list_0))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (take(succ(?ts_ph_nat_1), take(?ts_ph_nat_1, ?ts_ph_list_0)) == take(?ts_ph_nat_1, ?ts_ph_list_0))
forall ?ts_ph_list_0: list, ?ts_ph_nat_1: nat :: (take(length(?ts_ph_list_0), take(?ts_ph_nat_1, ?ts_ph_list_0)) == take(?ts_ph_nat_1, ?ts_ph_list_0))
forall ?ts_ph_list_0: list, ?ts_ph_nat_1: nat :: (take(length(?ts_ph_list_0), drop(?ts_ph_nat_1, ?ts_ph_list_0)) == drop(?ts_ph_nat_1, ?ts_ph_list_0))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (drop(succ(?ts_ph_nat_1), ?ts_ph_list_0) == drop(succ(zero), drop(?ts_ph_nat_1, ?ts_ph_list_0)))</code></pre>
<h3 id="trivial-12">trivial</h3>
<pre><code>forall ?ts_ph_list_0: list :: (drop(zero, ?ts_ph_list_0) == ?ts_ph_list_0)
forall ?ts_ph_list_0: list :: (take(zero, ?ts_ph_list_0) == nil)
forall ?ts_ph_nat_0: nat :: (lt(?ts_ph_nat_0, succ(zero)) &lt;==&gt; leq(?ts_ph_nat_0, zero))
forall ?ts_ph_nat_0: nat :: (leq(?ts_ph_nat_0, zero) &lt;==&gt; lt(?ts_ph_nat_0, succ(zero)))
forall ?ts_ph_nat_0: nat :: (leq(succ(zero), ?ts_ph_nat_0) &lt;==&gt; lt(zero, ?ts_ph_nat_0))
forall ?ts_ph_nat_0: nat :: (lt(zero, ?ts_ph_nat_0) &lt;==&gt; leq(succ(zero), ?ts_ph_nat_0))
forall ?ts_ph_nat_0: nat, ?ts_ph_list_1: list :: (drop(?ts_ph_nat_0, cons(?ts_ph_nat_0, ?ts_ph_list_1)) == drop(?ts_ph_nat_0, cons(zero, ?ts_ph_list_1)))
forall ?ts_ph_nat_0: nat, ?ts_ph_list_1: list :: (drop(?ts_ph_nat_0, cons(zero, ?ts_ph_list_1)) == drop(?ts_ph_nat_0, cons(?ts_ph_nat_0, ?ts_ph_list_1)))
forall ?ts_ph_list_0: list :: (take(succ(zero), append(?ts_ph_list_0, ?ts_ph_list_0)) == take(succ(zero), ?ts_ph_list_0))</code></pre>
<h2 id="unique-lemmas-found-by-thesy">unique lemmas found by thesy</h2>
<h3 id="overall-unique-3">overall unique</h3>
<pre><code>forall ?ts_ph_nat_0: nat :: (lt(?ts_ph_nat_0, ?ts_ph_nat_0) &lt;==&gt; false)
forall ?ts_ph_nat_0: nat :: (leq(?ts_ph_nat_0, ?ts_ph_nat_0) &lt;==&gt; true)
forall ?ts_ph_list_0: list :: (take(length(?ts_ph_list_0), ?ts_ph_list_0) == ?ts_ph_list_0)
forall ?ts_ph_list_0: list :: (drop(length(?ts_ph_list_0), ?ts_ph_list_0) == nil)
forall ?ts_ph_nat_0: nat :: (lt(succ(?ts_ph_nat_0), ?ts_ph_nat_0) &lt;==&gt; false)
forall ?ts_ph_nat_0: nat :: (leq(?ts_ph_nat_0, succ(?ts_ph_nat_0)) &lt;==&gt; lt(?ts_ph_nat_0, succ(?ts_ph_nat_0)))
forall ?ts_ph_nat_0: nat :: (lt(?ts_ph_nat_0, succ(?ts_ph_nat_0)) &lt;==&gt; leq(?ts_ph_nat_0, succ(?ts_ph_nat_0)))
forall ?ts_ph_nat_0: nat :: (lt(succ(?ts_ph_nat_0), ?ts_ph_nat_0) &lt;==&gt; leq(succ(?ts_ph_nat_0), ?ts_ph_nat_0))
forall ?ts_ph_nat_0: nat :: (leq(succ(?ts_ph_nat_0), ?ts_ph_nat_0) &lt;==&gt; lt(succ(?ts_ph_nat_0), ?ts_ph_nat_0))
forall ?ts_ph_nat_0: nat, ?ts_ph_list_1: list :: (drop(?ts_ph_nat_0, cons(zero, ?ts_ph_list_1)) == drop(?ts_ph_nat_0, cons(?ts_ph_nat_0, ?ts_ph_list_1)))
forall ?ts_ph_list_0: list, ?ts_ph_list_1: list :: (drop(length(?ts_ph_list_0), append(?ts_ph_list_0, ?ts_ph_list_1)) == ?ts_ph_list_1)
forall ?ts_ph_list_0: list, ?ts_ph_POfn_nat_natPC_1: [nat]nat :: (drop(length(?ts_ph_list_0), map(?ts_ph_POfn_nat_natPC_1, ?ts_ph_list_0)) == drop(length(?ts_ph_list_0), ?ts_ph_list_0))
forall ?ts_ph_list_0: list, ?ts_ph_list_1: list :: (take(length(?ts_ph_list_0), append(?ts_ph_list_0, ?ts_ph_list_1)) == take(length(?ts_ph_list_0), ?ts_ph_list_0))
forall ?ts_ph_list_0: list, ?ts_ph_POfn_nat_natPC_0: [nat]nat :: (take(length(?ts_ph_list_0), map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_0)) == map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_0))
forall ?ts_ph_POfn_nat_natPC_0: [nat]nat, ?ts_ph_list_0: list :: (map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_0) == take(length(?ts_ph_list_0), map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_0)))
forall ?ts_ph_list_0: list :: (take(succ(zero), append(?ts_ph_list_0, ?ts_ph_list_0)) == take(succ(zero), ?ts_ph_list_0))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (drop(?ts_ph_nat_1, take(?ts_ph_nat_1, ?ts_ph_list_0)) == nil)
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (take(?ts_ph_nat_1, ?ts_ph_list_0) == take(?ts_ph_nat_1, take(?ts_ph_nat_1, ?ts_ph_list_0)))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (take(?ts_ph_nat_1, take(?ts_ph_nat_1, ?ts_ph_list_0)) == take(?ts_ph_nat_1, ?ts_ph_list_0))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (drop(succ(?ts_ph_nat_1), take(?ts_ph_nat_1, ?ts_ph_list_0)) == nil)
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (take(?ts_ph_nat_1, ?ts_ph_list_0) == take(succ(?ts_ph_nat_1), take(?ts_ph_nat_1, ?ts_ph_list_0)))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (take(succ(?ts_ph_nat_1), take(?ts_ph_nat_1, ?ts_ph_list_0)) == take(?ts_ph_nat_1, ?ts_ph_list_0))
forall ?ts_ph_list_0: list, ?ts_ph_nat_1: nat :: (drop(length(?ts_ph_list_0), take(?ts_ph_nat_1, ?ts_ph_list_0)) == nil)
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (take(?ts_ph_nat_1, ?ts_ph_list_0) == take(length(?ts_ph_list_0), take(?ts_ph_nat_1, ?ts_ph_list_0)))
forall ?ts_ph_list_0: list, ?ts_ph_nat_1: nat :: (take(length(?ts_ph_list_0), take(?ts_ph_nat_1, ?ts_ph_list_0)) == take(?ts_ph_nat_1, ?ts_ph_list_0))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (drop(?ts_ph_nat_1, ?ts_ph_list_0) == take(length(?ts_ph_list_0), drop(?ts_ph_nat_1, ?ts_ph_list_0)))
forall ?ts_ph_list_0: list, ?ts_ph_nat_1: nat :: (take(length(?ts_ph_list_0), drop(?ts_ph_nat_1, ?ts_ph_list_0)) == drop(?ts_ph_nat_1, ?ts_ph_list_0))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (drop(succ(zero), drop(?ts_ph_nat_1, ?ts_ph_list_0)) == drop(succ(?ts_ph_nat_1), ?ts_ph_list_0))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (drop(succ(?ts_ph_nat_1), ?ts_ph_list_0) == drop(succ(zero), drop(?ts_ph_nat_1, ?ts_ph_list_0)))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (append(take(?ts_ph_nat_1, ?ts_ph_list_0), drop(?ts_ph_nat_1, ?ts_ph_list_0)) == ?ts_ph_list_0)</code></pre>
<h3 id="unique-over-structural-2">unique over structural</h3>
<pre><code>forall ?ts_ph_nat_0: nat :: (lt(?ts_ph_nat_0, ?ts_ph_nat_0) &lt;==&gt; false)
forall ?ts_ph_nat_0: nat :: (leq(?ts_ph_nat_0, ?ts_ph_nat_0) &lt;==&gt; true)
forall ?ts_ph_list_0: list :: (take(length(?ts_ph_list_0), ?ts_ph_list_0) == ?ts_ph_list_0)
forall ?ts_ph_list_0: list :: (drop(length(?ts_ph_list_0), ?ts_ph_list_0) == nil)
forall ?ts_ph_nat_0: nat :: (lt(succ(?ts_ph_nat_0), ?ts_ph_nat_0) &lt;==&gt; false)
forall ?ts_ph_nat_0: nat :: (leq(?ts_ph_nat_0, succ(?ts_ph_nat_0)) &lt;==&gt; lt(?ts_ph_nat_0, succ(?ts_ph_nat_0)))
forall ?ts_ph_nat_0: nat :: (lt(?ts_ph_nat_0, succ(?ts_ph_nat_0)) &lt;==&gt; leq(?ts_ph_nat_0, succ(?ts_ph_nat_0)))
forall ?ts_ph_nat_0: nat :: (lt(succ(?ts_ph_nat_0), ?ts_ph_nat_0) &lt;==&gt; leq(succ(?ts_ph_nat_0), ?ts_ph_nat_0))
forall ?ts_ph_nat_0: nat :: (leq(succ(?ts_ph_nat_0), ?ts_ph_nat_0) &lt;==&gt; lt(succ(?ts_ph_nat_0), ?ts_ph_nat_0))
forall ?ts_ph_list_0: list, ?ts_ph_nat_1: nat :: (leq(length(?ts_ph_list_0), ?ts_ph_nat_1) &lt;==&gt; lt(length(?ts_ph_list_0), succ(?ts_ph_nat_1)))
forall ?ts_ph_list_0: list, ?ts_ph_nat_1: nat :: (lt(length(?ts_ph_list_0), succ(?ts_ph_nat_1)) &lt;==&gt; leq(length(?ts_ph_list_0), ?ts_ph_nat_1))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (lt(?ts_ph_nat_1, length(?ts_ph_list_0)) &lt;==&gt; leq(succ(?ts_ph_nat_1), length(?ts_ph_list_0)))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (leq(succ(?ts_ph_nat_1), length(?ts_ph_list_0)) &lt;==&gt; lt(?ts_ph_nat_1, length(?ts_ph_list_0)))
forall ?ts_ph_nat_0: nat, ?ts_ph_list_1: list :: (drop(?ts_ph_nat_0, cons(zero, ?ts_ph_list_1)) == drop(?ts_ph_nat_0, cons(?ts_ph_nat_0, ?ts_ph_list_1)))
forall ?ts_ph_list_0: list, ?ts_ph_list_1: list :: (drop(length(?ts_ph_list_0), append(?ts_ph_list_0, ?ts_ph_list_1)) == ?ts_ph_list_1)
forall ?ts_ph_list_0: list, ?ts_ph_POfn_nat_natPC_1: [nat]nat :: (drop(length(?ts_ph_list_0), map(?ts_ph_POfn_nat_natPC_1, ?ts_ph_list_0)) == drop(length(?ts_ph_list_0), ?ts_ph_list_0))
forall ?ts_ph_list_0: list, ?ts_ph_list_1: list :: (take(length(?ts_ph_list_0), append(?ts_ph_list_0, ?ts_ph_list_1)) == take(length(?ts_ph_list_0), ?ts_ph_list_0))
forall ?ts_ph_list_0: list, ?ts_ph_POfn_nat_natPC_0: [nat]nat :: (take(length(?ts_ph_list_0), map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_0)) == map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_0))
forall ?ts_ph_POfn_nat_natPC_0: [nat]nat, ?ts_ph_list_0: list :: (map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_0) == take(length(?ts_ph_list_0), map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_0)))
forall ?ts_ph_list_0: list :: (take(succ(zero), append(?ts_ph_list_0, ?ts_ph_list_0)) == take(succ(zero), ?ts_ph_list_0))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (leq(?ts_ph_nat_0, ?ts_ph_nat_1) &lt;==&gt; lt(?ts_ph_nat_0, succ(?ts_ph_nat_1)))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (lt(?ts_ph_nat_0, succ(?ts_ph_nat_1)) &lt;==&gt; leq(?ts_ph_nat_0, ?ts_ph_nat_1))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (drop(?ts_ph_nat_1, take(?ts_ph_nat_1, ?ts_ph_list_0)) == nil)
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (take(?ts_ph_nat_1, ?ts_ph_list_0) == take(?ts_ph_nat_1, take(?ts_ph_nat_1, ?ts_ph_list_0)))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (take(?ts_ph_nat_1, take(?ts_ph_nat_1, ?ts_ph_list_0)) == take(?ts_ph_nat_1, ?ts_ph_list_0))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (drop(succ(?ts_ph_nat_1), take(?ts_ph_nat_1, ?ts_ph_list_0)) == nil)
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (take(?ts_ph_nat_1, ?ts_ph_list_0) == take(succ(?ts_ph_nat_1), take(?ts_ph_nat_1, ?ts_ph_list_0)))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (take(succ(?ts_ph_nat_1), take(?ts_ph_nat_1, ?ts_ph_list_0)) == take(?ts_ph_nat_1, ?ts_ph_list_0))
forall ?ts_ph_list_0: list, ?ts_ph_nat_1: nat :: (drop(length(?ts_ph_list_0), take(?ts_ph_nat_1, ?ts_ph_list_0)) == nil)
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (take(?ts_ph_nat_1, ?ts_ph_list_0) == take(length(?ts_ph_list_0), take(?ts_ph_nat_1, ?ts_ph_list_0)))
forall ?ts_ph_list_0: list, ?ts_ph_nat_1: nat :: (take(length(?ts_ph_list_0), take(?ts_ph_nat_1, ?ts_ph_list_0)) == take(?ts_ph_nat_1, ?ts_ph_list_0))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (drop(?ts_ph_nat_1, ?ts_ph_list_0) == take(length(?ts_ph_list_0), drop(?ts_ph_nat_1, ?ts_ph_list_0)))
forall ?ts_ph_list_0: list, ?ts_ph_nat_1: nat :: (take(length(?ts_ph_list_0), drop(?ts_ph_nat_1, ?ts_ph_list_0)) == drop(?ts_ph_nat_1, ?ts_ph_list_0))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (drop(succ(zero), drop(?ts_ph_nat_1, ?ts_ph_list_0)) == drop(succ(?ts_ph_nat_1), ?ts_ph_list_0))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (drop(succ(?ts_ph_nat_1), ?ts_ph_list_0) == drop(succ(zero), drop(?ts_ph_nat_1, ?ts_ph_list_0)))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (append(take(?ts_ph_nat_1, ?ts_ph_list_0), drop(?ts_ph_nat_1, ?ts_ph_list_0)) == ?ts_ph_list_0)</code></pre>
<h3 id="unique-over-conditional-2">unique over conditional</h3>
<pre><code>forall ?ts_ph_list_0: list :: (take(zero, ?ts_ph_list_0) == nil)
forall ?ts_ph_list_0: list :: (drop(zero, ?ts_ph_list_0) == append(?ts_ph_list_0, nil))
forall ?ts_ph_nat_0: nat :: (lt(?ts_ph_nat_0, ?ts_ph_nat_0) &lt;==&gt; false)
forall ?ts_ph_nat_0: nat :: (leq(?ts_ph_nat_0, ?ts_ph_nat_0) &lt;==&gt; true)
forall ?ts_ph_list_0: list :: (take(length(?ts_ph_list_0), ?ts_ph_list_0) == ?ts_ph_list_0)
forall ?ts_ph_list_0: list :: (drop(length(?ts_ph_list_0), ?ts_ph_list_0) == nil)
forall ?ts_ph_nat_0: nat :: (lt(succ(?ts_ph_nat_0), ?ts_ph_nat_0) &lt;==&gt; false)
forall ?ts_ph_nat_0: nat :: (leq(?ts_ph_nat_0, succ(?ts_ph_nat_0)) &lt;==&gt; lt(?ts_ph_nat_0, succ(?ts_ph_nat_0)))
forall ?ts_ph_nat_0: nat :: (lt(?ts_ph_nat_0, succ(?ts_ph_nat_0)) &lt;==&gt; leq(?ts_ph_nat_0, succ(?ts_ph_nat_0)))
forall ?ts_ph_nat_0: nat :: (lt(succ(?ts_ph_nat_0), ?ts_ph_nat_0) &lt;==&gt; leq(succ(?ts_ph_nat_0), ?ts_ph_nat_0))
forall ?ts_ph_nat_0: nat :: (leq(succ(?ts_ph_nat_0), ?ts_ph_nat_0) &lt;==&gt; lt(succ(?ts_ph_nat_0), ?ts_ph_nat_0))
forall ?ts_ph_list_0: list, ?ts_ph_nat_1: nat :: (leq(length(?ts_ph_list_0), ?ts_ph_nat_1) &lt;==&gt; lt(length(?ts_ph_list_0), succ(?ts_ph_nat_1)))
forall ?ts_ph_list_0: list, ?ts_ph_nat_1: nat :: (lt(length(?ts_ph_list_0), succ(?ts_ph_nat_1)) &lt;==&gt; leq(length(?ts_ph_list_0), ?ts_ph_nat_1))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (lt(?ts_ph_nat_1, length(?ts_ph_list_0)) &lt;==&gt; leq(succ(?ts_ph_nat_1), length(?ts_ph_list_0)))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (leq(succ(?ts_ph_nat_1), length(?ts_ph_list_0)) &lt;==&gt; lt(?ts_ph_nat_1, length(?ts_ph_list_0)))
forall ?ts_ph_nat_0: nat, ?ts_ph_list_1: list :: (drop(?ts_ph_nat_0, cons(?ts_ph_nat_0, ?ts_ph_list_1)) == drop(?ts_ph_nat_0, cons(zero, ?ts_ph_list_1)))
forall ?ts_ph_nat_0: nat, ?ts_ph_list_1: list :: (drop(?ts_ph_nat_0, cons(zero, ?ts_ph_list_1)) == drop(?ts_ph_nat_0, cons(?ts_ph_nat_0, ?ts_ph_list_1)))
forall ?ts_ph_list_0: list, ?ts_ph_list_1: list :: (drop(length(?ts_ph_list_0), append(?ts_ph_list_0, ?ts_ph_list_1)) == ?ts_ph_list_1)
forall ?ts_ph_list_0: list, ?ts_ph_POfn_nat_natPC_1: [nat]nat :: (drop(length(?ts_ph_list_0), map(?ts_ph_POfn_nat_natPC_1, ?ts_ph_list_0)) == drop(length(?ts_ph_list_0), ?ts_ph_list_0))
forall ?ts_ph_list_0: list, ?ts_ph_list_1: list :: (take(length(?ts_ph_list_0), append(?ts_ph_list_0, ?ts_ph_list_1)) == take(length(?ts_ph_list_0), ?ts_ph_list_0))
forall ?ts_ph_list_0: list, ?ts_ph_POfn_nat_natPC_0: [nat]nat :: (take(length(?ts_ph_list_0), map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_0)) == map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_0))
forall ?ts_ph_POfn_nat_natPC_0: [nat]nat, ?ts_ph_list_0: list :: (map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_0) == take(length(?ts_ph_list_0), map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_0)))
forall ?ts_ph_list_0: list :: (take(succ(zero), ?ts_ph_list_0) == take(succ(zero), append(?ts_ph_list_0, ?ts_ph_list_0)))
forall ?ts_ph_list_0: list :: (take(succ(zero), append(?ts_ph_list_0, ?ts_ph_list_0)) == take(succ(zero), ?ts_ph_list_0))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (leq(?ts_ph_nat_0, ?ts_ph_nat_1) &lt;==&gt; lt(?ts_ph_nat_0, succ(?ts_ph_nat_1)))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (lt(?ts_ph_nat_0, succ(?ts_ph_nat_1)) &lt;==&gt; leq(?ts_ph_nat_0, ?ts_ph_nat_1))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (drop(?ts_ph_nat_1, take(?ts_ph_nat_1, ?ts_ph_list_0)) == nil)
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (take(?ts_ph_nat_1, ?ts_ph_list_0) == take(?ts_ph_nat_1, take(?ts_ph_nat_1, ?ts_ph_list_0)))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (take(?ts_ph_nat_1, take(?ts_ph_nat_1, ?ts_ph_list_0)) == take(?ts_ph_nat_1, ?ts_ph_list_0))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (drop(succ(?ts_ph_nat_1), take(?ts_ph_nat_1, ?ts_ph_list_0)) == nil)
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (take(?ts_ph_nat_1, ?ts_ph_list_0) == take(succ(?ts_ph_nat_1), take(?ts_ph_nat_1, ?ts_ph_list_0)))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (take(succ(?ts_ph_nat_1), take(?ts_ph_nat_1, ?ts_ph_list_0)) == take(?ts_ph_nat_1, ?ts_ph_list_0))
forall ?ts_ph_list_0: list, ?ts_ph_nat_1: nat :: (drop(length(?ts_ph_list_0), take(?ts_ph_nat_1, ?ts_ph_list_0)) == nil)
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (take(?ts_ph_nat_1, ?ts_ph_list_0) == take(length(?ts_ph_list_0), take(?ts_ph_nat_1, ?ts_ph_list_0)))
forall ?ts_ph_list_0: list, ?ts_ph_nat_1: nat :: (take(length(?ts_ph_list_0), take(?ts_ph_nat_1, ?ts_ph_list_0)) == take(?ts_ph_nat_1, ?ts_ph_list_0))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (drop(?ts_ph_nat_1, ?ts_ph_list_0) == take(length(?ts_ph_list_0), drop(?ts_ph_nat_1, ?ts_ph_list_0)))
forall ?ts_ph_list_0: list, ?ts_ph_nat_1: nat :: (take(length(?ts_ph_list_0), drop(?ts_ph_nat_1, ?ts_ph_list_0)) == drop(?ts_ph_nat_1, ?ts_ph_list_0))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (drop(succ(zero), drop(?ts_ph_nat_1, ?ts_ph_list_0)) == drop(succ(?ts_ph_nat_1), ?ts_ph_list_0))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (drop(succ(?ts_ph_nat_1), ?ts_ph_list_0) == drop(succ(zero), drop(?ts_ph_nat_1, ?ts_ph_list_0)))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (append(take(?ts_ph_nat_1, ?ts_ph_list_0), drop(?ts_ph_nat_1, ?ts_ph_list_0)) == ?ts_ph_list_0)</code></pre>
<h3 id="unique-over-enumerate-2">unique over enumerate</h3>
<pre><code>forall ?ts_ph_list_0: list :: (drop(zero, ?ts_ph_list_0) == ?ts_ph_list_0)
forall ?ts_ph_list_0: list :: (take(zero, ?ts_ph_list_0) == nil)
forall ?ts_ph_nat_0: nat :: (lt(?ts_ph_nat_0, ?ts_ph_nat_0) &lt;==&gt; false)
forall ?ts_ph_nat_0: nat :: (leq(?ts_ph_nat_0, ?ts_ph_nat_0) &lt;==&gt; true)
forall ?ts_ph_list_0: list :: (take(length(?ts_ph_list_0), ?ts_ph_list_0) == ?ts_ph_list_0)
forall ?ts_ph_list_0: list :: (drop(length(?ts_ph_list_0), ?ts_ph_list_0) == nil)
forall ?ts_ph_nat_0: nat :: (lt(succ(?ts_ph_nat_0), ?ts_ph_nat_0) &lt;==&gt; false)
forall ?ts_ph_nat_0: nat :: (leq(?ts_ph_nat_0, succ(?ts_ph_nat_0)) &lt;==&gt; lt(?ts_ph_nat_0, succ(?ts_ph_nat_0)))
forall ?ts_ph_nat_0: nat :: (lt(?ts_ph_nat_0, succ(?ts_ph_nat_0)) &lt;==&gt; leq(?ts_ph_nat_0, succ(?ts_ph_nat_0)))
forall ?ts_ph_nat_0: nat :: (lt(succ(?ts_ph_nat_0), ?ts_ph_nat_0) &lt;==&gt; leq(succ(?ts_ph_nat_0), ?ts_ph_nat_0))
forall ?ts_ph_nat_0: nat :: (leq(succ(?ts_ph_nat_0), ?ts_ph_nat_0) &lt;==&gt; lt(succ(?ts_ph_nat_0), ?ts_ph_nat_0))
forall ?ts_ph_nat_0: nat, ?ts_ph_list_1: list :: (drop(?ts_ph_nat_0, cons(?ts_ph_nat_0, ?ts_ph_list_1)) == drop(?ts_ph_nat_0, cons(zero, ?ts_ph_list_1)))
forall ?ts_ph_nat_0: nat, ?ts_ph_list_1: list :: (drop(?ts_ph_nat_0, cons(zero, ?ts_ph_list_1)) == drop(?ts_ph_nat_0, cons(?ts_ph_nat_0, ?ts_ph_list_1)))
forall ?ts_ph_list_0: list, ?ts_ph_list_1: list :: (drop(length(?ts_ph_list_0), append(?ts_ph_list_0, ?ts_ph_list_1)) == ?ts_ph_list_1)
forall ?ts_ph_list_0: list, ?ts_ph_POfn_nat_natPC_1: [nat]nat :: (drop(length(?ts_ph_list_0), map(?ts_ph_POfn_nat_natPC_1, ?ts_ph_list_0)) == drop(length(?ts_ph_list_0), ?ts_ph_list_0))
forall ?ts_ph_list_0: list, ?ts_ph_list_1: list :: (take(length(?ts_ph_list_0), append(?ts_ph_list_0, ?ts_ph_list_1)) == take(length(?ts_ph_list_0), ?ts_ph_list_0))
forall ?ts_ph_list_0: list, ?ts_ph_POfn_nat_natPC_0: [nat]nat :: (take(length(?ts_ph_list_0), map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_0)) == map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_0))
forall ?ts_ph_POfn_nat_natPC_0: [nat]nat, ?ts_ph_list_0: list :: (map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_0) == take(length(?ts_ph_list_0), map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_0)))
forall ?ts_ph_list_0: list :: (take(succ(zero), ?ts_ph_list_0) == take(succ(zero), append(?ts_ph_list_0, ?ts_ph_list_0)))
forall ?ts_ph_list_0: list :: (take(succ(zero), append(?ts_ph_list_0, ?ts_ph_list_0)) == take(succ(zero), ?ts_ph_list_0))
forall ?ts_ph_nat_1: nat, ?ts_ph_POfn_nat_natPC_1: [nat]nat, ?ts_ph_list_0: list :: (drop(?ts_ph_nat_1, map(?ts_ph_POfn_nat_natPC_1, ?ts_ph_list_0)) == map(?ts_ph_POfn_nat_natPC_1, drop(?ts_ph_nat_1, ?ts_ph_list_0)))
forall ?ts_ph_POfn_nat_natPC_1: [nat]nat, ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (map(?ts_ph_POfn_nat_natPC_1, drop(?ts_ph_nat_1, ?ts_ph_list_0)) == drop(?ts_ph_nat_1, map(?ts_ph_POfn_nat_natPC_1, ?ts_ph_list_0)))
forall ?ts_ph_nat_1: nat, ?ts_ph_POfn_nat_natPC_1: [nat]nat, ?ts_ph_list_0: list :: (take(?ts_ph_nat_1, map(?ts_ph_POfn_nat_natPC_1, ?ts_ph_list_0)) == map(?ts_ph_POfn_nat_natPC_1, take(?ts_ph_nat_1, ?ts_ph_list_0)))
forall ?ts_ph_POfn_nat_natPC_1: [nat]nat, ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (map(?ts_ph_POfn_nat_natPC_1, take(?ts_ph_nat_1, ?ts_ph_list_0)) == take(?ts_ph_nat_1, map(?ts_ph_POfn_nat_natPC_1, ?ts_ph_list_0)))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (drop(?ts_ph_nat_1, take(?ts_ph_nat_1, ?ts_ph_list_0)) == nil)
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (take(?ts_ph_nat_1, ?ts_ph_list_0) == take(?ts_ph_nat_1, take(?ts_ph_nat_1, ?ts_ph_list_0)))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (take(?ts_ph_nat_1, take(?ts_ph_nat_1, ?ts_ph_list_0)) == take(?ts_ph_nat_1, ?ts_ph_list_0))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (drop(succ(?ts_ph_nat_1), take(?ts_ph_nat_1, ?ts_ph_list_0)) == nil)
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (take(?ts_ph_nat_1, ?ts_ph_list_0) == take(succ(?ts_ph_nat_1), take(?ts_ph_nat_1, ?ts_ph_list_0)))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (take(succ(?ts_ph_nat_1), take(?ts_ph_nat_1, ?ts_ph_list_0)) == take(?ts_ph_nat_1, ?ts_ph_list_0))
forall ?ts_ph_list_0: list, ?ts_ph_nat_1: nat :: (drop(length(?ts_ph_list_0), take(?ts_ph_nat_1, ?ts_ph_list_0)) == nil)
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (take(?ts_ph_nat_1, ?ts_ph_list_0) == take(length(?ts_ph_list_0), take(?ts_ph_nat_1, ?ts_ph_list_0)))
forall ?ts_ph_list_0: list, ?ts_ph_nat_1: nat :: (take(length(?ts_ph_list_0), take(?ts_ph_nat_1, ?ts_ph_list_0)) == take(?ts_ph_nat_1, ?ts_ph_list_0))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (drop(?ts_ph_nat_1, ?ts_ph_list_0) == take(length(?ts_ph_list_0), drop(?ts_ph_nat_1, ?ts_ph_list_0)))
forall ?ts_ph_list_0: list, ?ts_ph_nat_1: nat :: (take(length(?ts_ph_list_0), drop(?ts_ph_nat_1, ?ts_ph_list_0)) == drop(?ts_ph_nat_1, ?ts_ph_list_0))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (drop(succ(zero), drop(?ts_ph_nat_1, ?ts_ph_list_0)) == drop(succ(?ts_ph_nat_1), ?ts_ph_list_0))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (drop(succ(?ts_ph_nat_1), ?ts_ph_list_0) == drop(succ(zero), drop(?ts_ph_nat_1, ?ts_ph_list_0)))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (append(take(?ts_ph_nat_1, ?ts_ph_list_0), drop(?ts_ph_nat_1, ?ts_ph_list_0)) == ?ts_ph_list_0)</code></pre>
<h2 id="lemmas-confirmed-by-structural-2">lemmas confirmed by
structural</h2>
<h3 id="reduced-13">reduced</h3>
<pre><code>forall ?ts_ph_list_0: list :: (drop(zero, ?ts_ph_list_0) == append(?ts_ph_list_0, nil))
forall ?ts_ph_POfn_nat_natPC_1: [nat]nat, ?ts_ph_list_0: list :: (length(map(?ts_ph_POfn_nat_natPC_1, ?ts_ph_list_0)) == length(?ts_ph_list_0))
forall ?ts_ph_list_0: list, ?ts_ph_list_1: list, ?ts_ph_list_2: list :: (append(append(?ts_ph_list_0, ?ts_ph_list_1), ?ts_ph_list_2) == append(?ts_ph_list_0, append(?ts_ph_list_1, ?ts_ph_list_2)))
forall ?ts_ph_POfn_nat_natPC_0: [nat]nat, ?ts_ph_list_0: list, ?ts_ph_list_1: list :: (map(?ts_ph_POfn_nat_natPC_0, append(?ts_ph_list_0, ?ts_ph_list_1)) == append(map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_0), map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_1)))
forall ?ts_ph_nat_1: nat, ?ts_ph_POfn_nat_natPC_1: [nat]nat, ?ts_ph_list_0: list :: (drop(?ts_ph_nat_1, map(?ts_ph_POfn_nat_natPC_1, ?ts_ph_list_0)) == map(?ts_ph_POfn_nat_natPC_1, drop(?ts_ph_nat_1, ?ts_ph_list_0)))
forall ?ts_ph_nat_1: nat, ?ts_ph_POfn_nat_natPC_1: [nat]nat, ?ts_ph_list_0: list :: (take(?ts_ph_nat_1, map(?ts_ph_POfn_nat_natPC_1, ?ts_ph_list_0)) == map(?ts_ph_POfn_nat_natPC_1, take(?ts_ph_nat_1, ?ts_ph_list_0)))</code></pre>
<h3 id="implied-13">implied</h3>
<pre><code>forall ?ts_ph_list_0: list :: (append(?ts_ph_list_0, nil) == drop(zero, ?ts_ph_list_0))
forall ?ts_ph_list_0: list, ?ts_ph_list_1: list, ?ts_ph_list_2: list :: (append(?ts_ph_list_0, append(?ts_ph_list_1, ?ts_ph_list_2)) == append(append(?ts_ph_list_0, ?ts_ph_list_1), ?ts_ph_list_2))
forall ?ts_ph_POfn_nat_natPC_0: [nat]nat, ?ts_ph_list_0: list, ?ts_ph_list_1: list :: (append(map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_0), map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_1)) == map(?ts_ph_POfn_nat_natPC_0, append(?ts_ph_list_0, ?ts_ph_list_1)))
forall ?ts_ph_POfn_nat_natPC_1: [nat]nat, ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (map(?ts_ph_POfn_nat_natPC_1, drop(?ts_ph_nat_1, ?ts_ph_list_0)) == drop(?ts_ph_nat_1, map(?ts_ph_POfn_nat_natPC_1, ?ts_ph_list_0)))
forall ?ts_ph_POfn_nat_natPC_1: [nat]nat, ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (map(?ts_ph_POfn_nat_natPC_1, take(?ts_ph_nat_1, ?ts_ph_list_0)) == take(?ts_ph_nat_1, map(?ts_ph_POfn_nat_natPC_1, ?ts_ph_list_0)))</code></pre>
<h3 id="trivial-13">trivial</h3>
<pre><code>forall ?ts_ph_list_0: list :: (drop(zero, ?ts_ph_list_0) == ?ts_ph_list_0)
forall ?ts_ph_list_0: list :: (take(zero, ?ts_ph_list_0) == nil)
forall ?ts_ph_nat_0: nat :: (lt(?ts_ph_nat_0, succ(zero)) &lt;==&gt; leq(?ts_ph_nat_0, zero))
forall ?ts_ph_nat_0: nat :: (leq(?ts_ph_nat_0, zero) &lt;==&gt; lt(?ts_ph_nat_0, succ(zero)))
forall ?ts_ph_nat_0: nat :: (leq(succ(zero), ?ts_ph_nat_0) &lt;==&gt; lt(zero, ?ts_ph_nat_0))
forall ?ts_ph_nat_0: nat :: (lt(zero, ?ts_ph_nat_0) &lt;==&gt; leq(succ(zero), ?ts_ph_nat_0))
forall ?ts_ph_nat_0: nat, ?ts_ph_list_1: list :: (drop(?ts_ph_nat_0, cons(?ts_ph_nat_0, ?ts_ph_list_1)) == drop(?ts_ph_nat_0, cons(zero, ?ts_ph_list_1)))
forall ?ts_ph_list_0: list :: (take(succ(zero), ?ts_ph_list_0) == take(succ(zero), append(?ts_ph_list_0, ?ts_ph_list_0)))</code></pre>
<h2 id="lemmas-confirmed-by-conditional-2">lemmas confirmed by
conditional</h2>
<h3 id="reduced-14">reduced</h3>
<pre><code>forall ?ts_ph_list_0: list :: (drop(zero, ?ts_ph_list_0) == append(?ts_ph_list_0, nil))
forall ?ts_ph_POfn_nat_natPC_1: [nat]nat, ?ts_ph_list_0: list :: (length(map(?ts_ph_POfn_nat_natPC_1, ?ts_ph_list_0)) == length(?ts_ph_list_0))
forall ?ts_ph_list_0: list, ?ts_ph_list_1: list, ?ts_ph_list_2: list :: (append(append(?ts_ph_list_0, ?ts_ph_list_1), ?ts_ph_list_2) == append(?ts_ph_list_0, append(?ts_ph_list_1, ?ts_ph_list_2)))
forall ?ts_ph_POfn_nat_natPC_0: [nat]nat, ?ts_ph_list_0: list, ?ts_ph_list_1: list :: (map(?ts_ph_POfn_nat_natPC_0, append(?ts_ph_list_0, ?ts_ph_list_1)) == append(map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_0), map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_1)))
forall ?ts_ph_nat_1: nat, ?ts_ph_POfn_nat_natPC_1: [nat]nat, ?ts_ph_list_0: list :: (drop(?ts_ph_nat_1, map(?ts_ph_POfn_nat_natPC_1, ?ts_ph_list_0)) == map(?ts_ph_POfn_nat_natPC_1, drop(?ts_ph_nat_1, ?ts_ph_list_0)))
forall ?ts_ph_nat_1: nat, ?ts_ph_POfn_nat_natPC_1: [nat]nat, ?ts_ph_list_0: list :: (take(?ts_ph_nat_1, map(?ts_ph_POfn_nat_natPC_1, ?ts_ph_list_0)) == map(?ts_ph_POfn_nat_natPC_1, take(?ts_ph_nat_1, ?ts_ph_list_0)))</code></pre>
<h3 id="implied-14">implied</h3>
<pre><code>forall ?ts_ph_list_0: list, ?ts_ph_list_1: list, ?ts_ph_list_2: list :: (append(?ts_ph_list_0, append(?ts_ph_list_1, ?ts_ph_list_2)) == append(append(?ts_ph_list_0, ?ts_ph_list_1), ?ts_ph_list_2))
forall ?ts_ph_POfn_nat_natPC_0: [nat]nat, ?ts_ph_list_0: list, ?ts_ph_list_1: list :: (append(map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_0), map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_1)) == map(?ts_ph_POfn_nat_natPC_0, append(?ts_ph_list_0, ?ts_ph_list_1)))
forall ?ts_ph_POfn_nat_natPC_1: [nat]nat, ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (map(?ts_ph_POfn_nat_natPC_1, drop(?ts_ph_nat_1, ?ts_ph_list_0)) == drop(?ts_ph_nat_1, map(?ts_ph_POfn_nat_natPC_1, ?ts_ph_list_0)))
forall ?ts_ph_POfn_nat_natPC_1: [nat]nat, ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (map(?ts_ph_POfn_nat_natPC_1, take(?ts_ph_nat_1, ?ts_ph_list_0)) == take(?ts_ph_nat_1, map(?ts_ph_POfn_nat_natPC_1, ?ts_ph_list_0)))</code></pre>
<h3 id="trivial-14">trivial</h3>
<pre><code>forall ?ts_ph_list_0: list :: (drop(zero, ?ts_ph_list_0) == ?ts_ph_list_0)
forall ?ts_ph_list_0: list :: (append(?ts_ph_list_0, nil) == drop(zero, ?ts_ph_list_0))
forall ?ts_ph_nat_0: nat :: (lt(?ts_ph_nat_0, succ(zero)) &lt;==&gt; leq(?ts_ph_nat_0, zero))
forall ?ts_ph_nat_0: nat :: (leq(?ts_ph_nat_0, zero) &lt;==&gt; lt(?ts_ph_nat_0, succ(zero)))
forall ?ts_ph_nat_0: nat :: (leq(succ(zero), ?ts_ph_nat_0) &lt;==&gt; lt(zero, ?ts_ph_nat_0))
forall ?ts_ph_nat_0: nat :: (lt(zero, ?ts_ph_nat_0) &lt;==&gt; leq(succ(zero), ?ts_ph_nat_0))</code></pre>
<h2 id="lemmas-confirmed-by-enumerate-2">lemmas confirmed by
enumerate</h2>
<h3 id="reduced-15">reduced</h3>
<pre><code>forall ?ts_ph_list_0: list :: (drop(zero, ?ts_ph_list_0) == append(?ts_ph_list_0, nil))
forall ?ts_ph_POfn_nat_natPC_1: [nat]nat, ?ts_ph_list_0: list :: (length(map(?ts_ph_POfn_nat_natPC_1, ?ts_ph_list_0)) == length(?ts_ph_list_0))
forall ?ts_ph_list_0: list, ?ts_ph_list_1: list, ?ts_ph_list_2: list :: (append(append(?ts_ph_list_0, ?ts_ph_list_1), ?ts_ph_list_2) == append(?ts_ph_list_0, append(?ts_ph_list_1, ?ts_ph_list_2)))
forall ?ts_ph_list_0: list, ?ts_ph_nat_1: nat :: (leq(length(?ts_ph_list_0), ?ts_ph_nat_1) &lt;==&gt; lt(length(?ts_ph_list_0), succ(?ts_ph_nat_1)))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (lt(?ts_ph_nat_1, length(?ts_ph_list_0)) &lt;==&gt; leq(succ(?ts_ph_nat_1), length(?ts_ph_list_0)))
forall ?ts_ph_list_0: list :: (take(succ(zero), ?ts_ph_list_0) == take(succ(zero), append(?ts_ph_list_0, ?ts_ph_list_0)))
forall ?ts_ph_POfn_nat_natPC_0: [nat]nat, ?ts_ph_list_0: list, ?ts_ph_list_1: list :: (map(?ts_ph_POfn_nat_natPC_0, append(?ts_ph_list_0, ?ts_ph_list_1)) == append(map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_0), map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_1)))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (leq(?ts_ph_nat_0, ?ts_ph_nat_1) &lt;==&gt; lt(?ts_ph_nat_0, succ(?ts_ph_nat_1)))</code></pre>
<h3 id="implied-15">implied</h3>
<pre><code>forall ?ts_ph_list_0: list :: (append(?ts_ph_list_0, nil) == drop(zero, ?ts_ph_list_0))
forall ?ts_ph_list_0: list, ?ts_ph_list_1: list, ?ts_ph_list_2: list :: (append(?ts_ph_list_0, append(?ts_ph_list_1, ?ts_ph_list_2)) == append(append(?ts_ph_list_0, ?ts_ph_list_1), ?ts_ph_list_2))
forall ?ts_ph_list_0: list, ?ts_ph_nat_1: nat :: (lt(length(?ts_ph_list_0), succ(?ts_ph_nat_1)) &lt;==&gt; leq(length(?ts_ph_list_0), ?ts_ph_nat_1))
forall ?ts_ph_nat_1: nat, ?ts_ph_list_0: list :: (leq(succ(?ts_ph_nat_1), length(?ts_ph_list_0)) &lt;==&gt; lt(?ts_ph_nat_1, length(?ts_ph_list_0)))
forall ?ts_ph_POfn_nat_natPC_0: [nat]nat, ?ts_ph_list_0: list, ?ts_ph_list_1: list :: (append(map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_0), map(?ts_ph_POfn_nat_natPC_0, ?ts_ph_list_1)) == map(?ts_ph_POfn_nat_natPC_0, append(?ts_ph_list_0, ?ts_ph_list_1)))
forall ?ts_ph_nat_0: nat, ?ts_ph_nat_1: nat :: (lt(?ts_ph_nat_0, succ(?ts_ph_nat_1)) &lt;==&gt; leq(?ts_ph_nat_0, ?ts_ph_nat_1))</code></pre>
<h3 id="trivial-15">trivial</h3>
<pre><code>forall ?ts_ph_nat_0: nat :: (lt(?ts_ph_nat_0, succ(zero)) &lt;==&gt; leq(?ts_ph_nat_0, zero))
forall ?ts_ph_nat_0: nat :: (leq(?ts_ph_nat_0, zero) &lt;==&gt; lt(?ts_ph_nat_0, succ(zero)))
forall ?ts_ph_nat_0: nat :: (leq(succ(zero), ?ts_ph_nat_0) &lt;==&gt; lt(zero, ?ts_ph_nat_0))
forall ?ts_ph_nat_0: nat :: (lt(zero, ?ts_ph_nat_0) &lt;==&gt; leq(succ(zero), ?ts_ph_nat_0))</code></pre>
