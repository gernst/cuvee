evaluation/lemmas/list/map.conditional.bpl
  16  number of lemmas
  0  wrong
forall x₀: nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (take(x₀, drop(x₁, x₂)) == nil))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall x₀: nat, x₁: list, x₂: list :: (leq(length(x₁), x₀) ==> (append(drop(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: list :: (lt(x₀, length(x₁)) ==> (length(take(x₀, x₁)) == x₀))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (length(drop(x₀, x₁)) == zero))
forall x₀: nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (drop(x₀, drop(x₁, x₂)) == nil))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall x₀: [nat]nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (map(x₀, drop(x₁, x₂)) == nil))
forall x₀: nat, x₁: list :: (lt(x₀, length(x₁)) ==> (leq(x₀, length(x₁)) <==> true))
forall x₀: list, x₁: nat :: (lt(x₁, length(x₀)) ==> (lt(length(x₀), x₁) <==> false))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (take(x₀, map(y₀, y₁)) == map(y₀, take(x₀, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (drop(x₀, map(y₀, y₁)) == map(y₀, drop(x₀, y₁)))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (take(x₀, x₁) == x₁))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (drop(x₀, x₁) == nil))
forall x: list :: (append(x, nil) == x)
  16  nontrivial
forall x₀: nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (take(x₀, drop(x₁, x₂)) == nil))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall x₀: nat, x₁: list, x₂: list :: (leq(length(x₁), x₀) ==> (append(drop(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: list :: (lt(x₀, length(x₁)) ==> (length(take(x₀, x₁)) == x₀))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (length(drop(x₀, x₁)) == zero))
forall x₀: nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (drop(x₀, drop(x₁, x₂)) == nil))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall x₀: [nat]nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (map(x₀, drop(x₁, x₂)) == nil))
forall x₀: nat, x₁: list :: (lt(x₀, length(x₁)) ==> (leq(x₀, length(x₁)) <==> true))
forall x₀: list, x₁: nat :: (lt(x₁, length(x₀)) ==> (lt(length(x₀), x₁) <==> false))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (take(x₀, map(y₀, y₁)) == map(y₀, take(x₀, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (drop(x₀, map(y₀, y₁)) == map(y₀, drop(x₀, y₁)))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (take(x₀, x₁) == x₁))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (drop(x₀, x₁) == nil))
forall x: list :: (append(x, nil) == x)
  11  reduced greedily
forall x₀: nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (take(x₀, drop(x₁, x₂)) == nil))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall x₀: nat, x₁: list, x₂: list :: (leq(length(x₁), x₀) ==> (append(drop(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: list :: (lt(x₀, length(x₁)) ==> (length(take(x₀, x₁)) == x₀))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (length(drop(x₀, x₁)) == zero))
forall x₀: nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (drop(x₀, drop(x₁, x₂)) == nil))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall x₀: [nat]nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (map(x₀, drop(x₁, x₂)) == nil))
forall x₀: nat, x₁: list :: (lt(x₀, length(x₁)) ==> (leq(x₀, length(x₁)) <==> true))
forall x₀: list, x₁: nat :: (lt(x₁, length(x₀)) ==> (lt(length(x₀), x₁) <==> false))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (take(x₀, map(y₀, y₁)) == map(y₀, take(x₀, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (drop(x₀, map(y₀, y₁)) == map(y₀, drop(x₀, y₁)))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (take(x₀, x₁) == x₁))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (drop(x₀, x₁) == nil))
forall x: list :: (append(x, nil) == x)
  10  independent
forall x₀: nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (take(x₀, drop(x₁, x₂)) == nil))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall x₀: nat, x₁: list, x₂: list :: (leq(length(x₁), x₀) ==> (append(drop(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: list :: (lt(x₀, length(x₁)) ==> (length(take(x₀, x₁)) == x₀))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (length(drop(x₀, x₁)) == zero))
forall x₀: nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (drop(x₀, drop(x₁, x₂)) == nil))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall x₀: [nat]nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (map(x₀, drop(x₁, x₂)) == nil))
forall x₀: nat, x₁: list :: (lt(x₀, length(x₁)) ==> (leq(x₀, length(x₁)) <==> true))
forall x₀: list, x₁: nat :: (lt(x₁, length(x₀)) ==> (lt(length(x₀), x₁) <==> false))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (take(x₀, map(y₀, y₁)) == map(y₀, take(x₀, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (drop(x₀, map(y₀, y₁)) == map(y₀, drop(x₀, y₁)))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (take(x₀, x₁) == x₁))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (drop(x₀, x₁) == nil))
forall x: list :: (append(x, nil) == x)
  10  evaluation/lemmas/list/map.structural.bpl
forall x₀: nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (take(x₀, drop(x₁, x₂)) == nil))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall x₀: nat, x₁: list, x₂: list :: (leq(length(x₁), x₀) ==> (append(drop(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: list :: (lt(x₀, length(x₁)) ==> (length(take(x₀, x₁)) == x₀))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (length(drop(x₀, x₁)) == zero))
forall x₀: nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (drop(x₀, drop(x₁, x₂)) == nil))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall x₀: [nat]nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (map(x₀, drop(x₁, x₂)) == nil))
forall x₀: nat, x₁: list :: (lt(x₀, length(x₁)) ==> (leq(x₀, length(x₁)) <==> true))
forall x₀: list, x₁: nat :: (lt(x₁, length(x₀)) ==> (lt(length(x₀), x₁) <==> false))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (take(x₀, map(y₀, y₁)) == map(y₀, take(x₀, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (drop(x₀, map(y₀, y₁)) == map(y₀, drop(x₀, y₁)))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (take(x₀, x₁) == x₁))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (drop(x₀, x₁) == nil))
forall x: list :: (append(x, nil) == x)
  12  evaluation/lemmas/list/map.enumerate.bpl
forall x₀: nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (take(x₀, drop(x₁, x₂)) == nil))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall x₀: nat, x₁: list, x₂: list :: (leq(length(x₁), x₀) ==> (append(drop(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: list :: (lt(x₀, length(x₁)) ==> (length(take(x₀, x₁)) == x₀))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (length(drop(x₀, x₁)) == zero))
forall x₀: nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (drop(x₀, drop(x₁, x₂)) == nil))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall x₀: [nat]nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (map(x₀, drop(x₁, x₂)) == nil))
forall x₀: nat, x₁: list :: (lt(x₀, length(x₁)) ==> (leq(x₀, length(x₁)) <==> true))
forall x₀: list, x₁: nat :: (lt(x₁, length(x₀)) ==> (lt(length(x₀), x₁) <==> false))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (take(x₀, map(y₀, y₁)) == map(y₀, take(x₀, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (drop(x₀, map(y₀, y₁)) == map(y₀, drop(x₀, y₁)))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (take(x₀, x₁) == x₁))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (drop(x₀, x₁) == nil))
forall x: list :: (append(x, nil) == x)
  10  evaluation/lemmas/list/map.th.log
