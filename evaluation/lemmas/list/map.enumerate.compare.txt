evaluation/lemmas/list/map.enumerate.bpl
  17  number of lemmas
  0  wrong
forall x₁: list :: (x₁ == append(x₁, nil))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), append(y₁, nil)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), y₁))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(drop(zero, y₀), append(y₁, x₁)))
forall x₀: nat, y₀: nat, y₁: list :: (take(x₀, take(y₀, y₁)) == take(y₀, take(x₀, y₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(append(y₀, y₁), drop(zero, x₁)))
forall y₀: [nat]nat, y₁: list, x₁: list :: (append(map(y₀, y₁), x₁) == append(map(y₀, y₁), drop(zero, x₁)))
forall x₀: list, y₀: nat, y₁: list :: (append(x₀, drop(y₀, y₁)) == append(drop(zero, x₀), drop(y₀, y₁)))
forall y₀: nat, y₁: list, x₁: list :: (append(take(y₀, y₁), x₁) == append(take(y₀, y₁), drop(zero, x₁)))
forall y₀: nat, x₁: nat :: (leq(succ(y₀), x₁) <==> lt(y₀, x₁))
forall y₀: list, x₁: list :: (drop(length(y₀), x₁) == drop(length(y₀), drop(zero, x₁)))
forall y₀: list, x₁: list :: (take(length(y₀), x₁) == take(length(y₀), drop(zero, x₁)))
forall y₀: list, y₁: list :: (append(y₀, y₁) == append(y₀, drop(zero, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall y₀: nat, x₁: list :: (take(succ(y₀), x₁) == take(succ(y₀), drop(zero, x₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(drop(zero, y₁)))
  9  nontrivial
forall x₁: list :: (x₁ == append(x₁, nil))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), append(y₁, nil)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), y₁))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(drop(zero, y₀), append(y₁, x₁)))
forall x₀: nat, y₀: nat, y₁: list :: (take(x₀, take(y₀, y₁)) == take(y₀, take(x₀, y₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(append(y₀, y₁), drop(zero, x₁)))
forall y₀: [nat]nat, y₁: list, x₁: list :: (append(map(y₀, y₁), x₁) == append(map(y₀, y₁), drop(zero, x₁)))
forall x₀: list, y₀: nat, y₁: list :: (append(x₀, drop(y₀, y₁)) == append(drop(zero, x₀), drop(y₀, y₁)))
forall y₀: nat, y₁: list, x₁: list :: (append(take(y₀, y₁), x₁) == append(take(y₀, y₁), drop(zero, x₁)))
forall y₀: nat, x₁: nat :: (leq(succ(y₀), x₁) <==> lt(y₀, x₁))
forall y₀: list, x₁: list :: (drop(length(y₀), x₁) == drop(length(y₀), drop(zero, x₁)))
forall y₀: list, x₁: list :: (take(length(y₀), x₁) == take(length(y₀), drop(zero, x₁)))
forall y₀: list, y₁: list :: (append(y₀, y₁) == append(y₀, drop(zero, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall y₀: nat, x₁: list :: (take(succ(y₀), x₁) == take(succ(y₀), drop(zero, x₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(drop(zero, y₁)))
  17  reduced greedily
forall x₁: list :: (x₁ == append(x₁, nil))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), append(y₁, nil)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), y₁))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(drop(zero, y₀), append(y₁, x₁)))
forall x₀: nat, y₀: nat, y₁: list :: (take(x₀, take(y₀, y₁)) == take(y₀, take(x₀, y₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(append(y₀, y₁), drop(zero, x₁)))
forall y₀: [nat]nat, y₁: list, x₁: list :: (append(map(y₀, y₁), x₁) == append(map(y₀, y₁), drop(zero, x₁)))
forall x₀: list, y₀: nat, y₁: list :: (append(x₀, drop(y₀, y₁)) == append(drop(zero, x₀), drop(y₀, y₁)))
forall y₀: nat, y₁: list, x₁: list :: (append(take(y₀, y₁), x₁) == append(take(y₀, y₁), drop(zero, x₁)))
forall y₀: nat, x₁: nat :: (leq(succ(y₀), x₁) <==> lt(y₀, x₁))
forall y₀: list, x₁: list :: (drop(length(y₀), x₁) == drop(length(y₀), drop(zero, x₁)))
forall y₀: list, x₁: list :: (take(length(y₀), x₁) == take(length(y₀), drop(zero, x₁)))
forall y₀: list, y₁: list :: (append(y₀, y₁) == append(y₀, drop(zero, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall y₀: nat, x₁: list :: (take(succ(y₀), x₁) == take(succ(y₀), drop(zero, x₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(drop(zero, y₁)))
  10  independent
forall x₁: list :: (x₁ == append(x₁, nil))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), append(y₁, nil)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), y₁))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(drop(zero, y₀), append(y₁, x₁)))
forall x₀: nat, y₀: nat, y₁: list :: (take(x₀, take(y₀, y₁)) == take(y₀, take(x₀, y₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(append(y₀, y₁), drop(zero, x₁)))
forall y₀: [nat]nat, y₁: list, x₁: list :: (append(map(y₀, y₁), x₁) == append(map(y₀, y₁), drop(zero, x₁)))
forall x₀: list, y₀: nat, y₁: list :: (append(x₀, drop(y₀, y₁)) == append(drop(zero, x₀), drop(y₀, y₁)))
forall y₀: nat, y₁: list, x₁: list :: (append(take(y₀, y₁), x₁) == append(take(y₀, y₁), drop(zero, x₁)))
forall y₀: nat, x₁: nat :: (leq(succ(y₀), x₁) <==> lt(y₀, x₁))
forall y₀: list, x₁: list :: (drop(length(y₀), x₁) == drop(length(y₀), drop(zero, x₁)))
forall y₀: list, x₁: list :: (take(length(y₀), x₁) == take(length(y₀), drop(zero, x₁)))
forall y₀: list, y₁: list :: (append(y₀, y₁) == append(y₀, drop(zero, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall y₀: nat, x₁: list :: (take(succ(y₀), x₁) == take(succ(y₀), drop(zero, x₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(drop(zero, y₁)))
  3  evaluation/lemmas/list/map.structural.bpl
forall x₁: list :: (x₁ == append(x₁, nil))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), append(y₁, nil)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), y₁))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(drop(zero, y₀), append(y₁, x₁)))
forall x₀: nat, y₀: nat, y₁: list :: (take(x₀, take(y₀, y₁)) == take(y₀, take(x₀, y₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(append(y₀, y₁), drop(zero, x₁)))
forall y₀: [nat]nat, y₁: list, x₁: list :: (append(map(y₀, y₁), x₁) == append(map(y₀, y₁), drop(zero, x₁)))
forall x₀: list, y₀: nat, y₁: list :: (append(x₀, drop(y₀, y₁)) == append(drop(zero, x₀), drop(y₀, y₁)))
forall y₀: nat, y₁: list, x₁: list :: (append(take(y₀, y₁), x₁) == append(take(y₀, y₁), drop(zero, x₁)))
forall y₀: nat, x₁: nat :: (leq(succ(y₀), x₁) <==> lt(y₀, x₁))
forall y₀: list, x₁: list :: (drop(length(y₀), x₁) == drop(length(y₀), drop(zero, x₁)))
forall y₀: list, x₁: list :: (take(length(y₀), x₁) == take(length(y₀), drop(zero, x₁)))
forall y₀: list, y₁: list :: (append(y₀, y₁) == append(y₀, drop(zero, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall y₀: nat, x₁: list :: (take(succ(y₀), x₁) == take(succ(y₀), drop(zero, x₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(drop(zero, y₁)))
  6  evaluation/lemmas/list/map.conditional.bpl
forall x₁: list :: (x₁ == append(x₁, nil))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), append(y₁, nil)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), y₁))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(drop(zero, y₀), append(y₁, x₁)))
forall x₀: nat, y₀: nat, y₁: list :: (take(x₀, take(y₀, y₁)) == take(y₀, take(x₀, y₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(append(y₀, y₁), drop(zero, x₁)))
forall y₀: [nat]nat, y₁: list, x₁: list :: (append(map(y₀, y₁), x₁) == append(map(y₀, y₁), drop(zero, x₁)))
forall x₀: list, y₀: nat, y₁: list :: (append(x₀, drop(y₀, y₁)) == append(drop(zero, x₀), drop(y₀, y₁)))
forall y₀: nat, y₁: list, x₁: list :: (append(take(y₀, y₁), x₁) == append(take(y₀, y₁), drop(zero, x₁)))
forall y₀: nat, x₁: nat :: (leq(succ(y₀), x₁) <==> lt(y₀, x₁))
forall y₀: list, x₁: list :: (drop(length(y₀), x₁) == drop(length(y₀), drop(zero, x₁)))
forall y₀: list, x₁: list :: (take(length(y₀), x₁) == take(length(y₀), drop(zero, x₁)))
forall y₀: list, y₁: list :: (append(y₀, y₁) == append(y₀, drop(zero, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall y₀: nat, x₁: list :: (take(succ(y₀), x₁) == take(succ(y₀), drop(zero, x₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(drop(zero, y₁)))
  1  evaluation/lemmas/list/map.th.log
