data nat = zero | succ(pred: nat);
data list = nil | cons(head: nat, tail: list);
function not_(x₀: Bool): Bool;
axiom (not_(false) <==> true);
axiom (not_(true) <==> false);
function add(x₀: nat, x₁: nat): nat;
axiom forall n: nat :: (add(zero, n) == n);
axiom forall m: nat, n: nat :: (add(succ(m), n) == succ(add(m, n)));
function length(x₀: list): nat;
axiom (length(nil) == zero);
axiom forall x: nat, xs: list :: (length(cons(x, xs)) == succ(length(xs)));
function append(x₀: list, x₁: list): list;
axiom forall ys: list :: (append(nil, ys) == ys);
axiom forall x: nat, xs: list, ys: list :: (append(cons(x, xs), ys) == cons(x, append(xs, ys)));
function map(x₀: [nat]nat, x₁: list): list;
axiom forall f: [nat]nat :: (map(f, nil) == nil);
axiom forall f: [nat]nat, y: nat, ys: list :: (map(f, cons(y, ys)) == cons(f[y], map(f, ys)));
function all(x₀: [nat]Bool, x₁: list): Bool;
axiom forall p: [nat]Bool :: (all(p, nil) <==> true);
axiom forall p: [nat]Bool, y: nat, ys: list :: (all(p, cons(y, ys)) <==> (p[y] && all(p, ys)));
function ex(x₀: [nat]Bool, x₁: list): Bool;
axiom forall p: [nat]Bool :: (ex(p, nil) <==> false);
axiom forall p: [nat]Bool, y: nat, ys: list :: (ex(p, cons(y, ys)) <==> (p[y] || ex(p, ys)));
function contains(x₀: nat, x₁: list): Bool;
axiom forall x: nat :: (contains(x, nil) <==> false);
axiom forall x: nat, y: nat, ys: list :: (contains(x, cons(y, ys)) <==> ((x == y) || contains(x, ys)));
function count(x₀: nat, x₁: list): nat;
axiom forall x: nat :: (count(x, nil) == zero);
axiom forall x: nat, y: nat, ys: list :: (count(x, cons(y, ys)) == (if (x == y) then succ(count(x, ys)) else count(x, ys)));
function countif(x₀: [nat]Bool, x₁: list): nat;
axiom forall p: [nat]Bool :: (countif(p, nil) == zero);
axiom forall p: [nat]Bool, y: nat, ys: list :: (countif(p, cons(y, ys)) == (if p[y] then succ(countif(p, ys)) else countif(p, ys)));
function snoc(x₀: list, x₁: nat): list;
axiom forall z: nat :: (snoc(nil, z) == cons(z, nil));
axiom forall z: nat, y: nat, ys: list :: (snoc(cons(y, ys), z) == cons(y, snoc(ys, z)));
function rotate(x₀: nat, x₁: list): list;
axiom forall n: nat :: (rotate(n, nil) == nil);
axiom forall y: nat, ys: list :: (rotate(zero, cons(y, ys)) == cons(y, ys));
axiom forall n: nat, y: nat, ys: list :: (rotate(succ(n), cons(y, ys)) == snoc(rotate(n, ys), y));
function take(x₀: nat, x₁: list): list;
axiom forall n: nat :: (take(n, nil) == nil);
axiom forall y: nat, ys: list :: (take(zero, cons(y, ys)) == nil);
axiom forall n: nat, y: nat, ys: list :: (take(succ(n), cons(y, ys)) == cons(y, take(n, ys)));
function drop(x₀: nat, x₁: list): list;
axiom forall n: nat :: (drop(n, nil) == nil);
axiom forall y: nat, ys: list :: (drop(zero, cons(y, ys)) == cons(y, ys));
axiom forall n: nat, y: nat, ys: list :: (drop(succ(n), cons(y, ys)) == drop(n, ys));
function reverse(x₀: list): list;
axiom (reverse(nil) == nil);
axiom forall y: nat, ys: list :: (reverse(cons(y, ys)) == snoc(reverse(ys), y));
function remove(x₀: nat, x₁: list): list;
axiom forall x: nat :: (remove(x, nil) == nil);
axiom forall x: nat, y: nat, ys: list :: (remove(x, cons(y, ys)) == (if (x == y) then remove(x, ys) else cons(y, remove(x, ys))));
function filter(x₀: [nat]Bool, x₁: list): list;
axiom forall p: [nat]Bool :: (filter(p, nil) == nil);
axiom forall p: [nat]Bool, y: nat, ys: list :: (filter(p, cons(y, ys)) == (if p[y] then cons(y, filter(p, ys)) else filter(p, ys)));
lemma forall y₀: list :: (reverse(reverse(y₀)) == y₀);
lemma forall x₀: [nat]nat, y₀: list :: (map(x₀, reverse(y₀)) == reverse(map(x₀, y₀)));
lemma forall x₀: [nat]nat, y₀: nat, y₁: list :: (map(x₀, rotate(y₀, y₁)) == rotate(y₀, map(x₀, y₁)));
lemma forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == append(reverse(y₁), reverse(y₀)));
lemma forall x₀: nat, y₀: list, y₁: list :: (count(x₀, append(y₀, y₁)) == add(count(x₀, y₀), count(x₀, y₁)));
lemma forall x₀: nat, y₀: list, y₁: nat :: (count(x₀, snoc(y₀, y₁)) == add(count(x₀, y₀), count(x₀, cons(y₁, nil))));
lemma forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)));
lemma forall y₀: list, y₁: nat, x₁: list :: (append(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, x₁)));
lemma forall y₀: list, y₁: nat :: (reverse(snoc(y₀, y₁)) == cons(y₁, reverse(y₀)));
lemma forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)));
lemma forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)));
lemma forall x₀: [nat]nat, y₀: list, y₁: nat :: (map(x₀, snoc(y₀, y₁)) == append(map(x₀, y₀), cons(x₀[y₁], nil)));
lemma forall x₀: nat, y₀: list, y₁: list :: (remove(x₀, append(y₀, y₁)) == append(remove(x₀, y₀), remove(x₀, y₁)));
lemma forall x₀: nat, y₀: list, y₁: nat :: (remove(x₀, snoc(y₀, y₁)) == append(remove(x₀, y₀), remove(x₀, cons(y₁, nil))));
lemma forall y₀: nat, y₁: list, x₁: nat :: (snoc(take(y₀, y₁), x₁) == append(take(y₀, y₁), cons(x₁, nil)));
lemma forall y₀: list, y₁: list, x₁: nat :: (snoc(append(y₀, y₁), x₁) == append(y₀, append(y₁, cons(x₁, nil))));
lemma forall y₀: [nat]nat, y₁: list, x₁: nat :: (snoc(map(y₀, y₁), x₁) == append(map(y₀, y₁), cons(x₁, nil)));
lemma forall y₀: nat, y₁: list, x₁: nat :: (snoc(remove(y₀, y₁), x₁) == append(remove(y₀, y₁), cons(x₁, nil)));
lemma forall y₀: list, y₁: nat, x₁: nat :: (snoc(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, cons(x₁, nil))));
lemma forall y₀: [nat]Bool, y₁: list, x₁: nat :: (snoc(filter(y₀, y₁), x₁) == append(filter(y₀, y₁), cons(x₁, nil)));
lemma forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)));
lemma forall x₀: [nat]Bool, y₀: list, y₁: list :: (filter(x₀, append(y₀, y₁)) == append(filter(x₀, y₀), filter(x₀, y₁)));
lemma forall x₀: [nat]Bool, y₀: list, y₁: nat :: (filter(x₀, snoc(y₀, y₁)) == append(filter(x₀, y₀), filter(x₀, cons(y₁, nil))));
lemma forall x₀: [nat]Bool, y₀: list, y₁: list :: (countif(x₀, append(y₀, y₁)) == add(countif(x₀, y₀), countif(x₀, y₁)));
lemma forall x₀: [nat]Bool, y₀: list, y₁: nat :: (countif(x₀, snoc(y₀, y₁)) == add(countif(x₀, y₀), countif(x₀, cons(y₁, nil))));
lemma forall x₀: nat, y₀: [nat]nat, y₁: list :: (take(x₀, map(y₀, y₁)) == map(y₀, take(x₀, y₁)));
lemma forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁));
lemma forall y₀: [nat]Bool, y₁: list :: (length(filter(y₀, y₁)) == countif(y₀, y₁));
lemma forall y₀: Bool :: (not_(not_(y₀)) <==> y₀);
lemma forall x₀: nat, y₀: [nat]nat, y₁: list :: (drop(x₀, map(y₀, y₁)) == map(y₀, drop(x₀, y₁)));
lemma forall x₀: list, x₁: nat :: (snoc(x₀, x₁) == append(x₀, cons(x₁, nil)));
lemma forall x: list :: (append(x, nil) == x);
lemma forall x: nat :: (add(x, zero) == x);
