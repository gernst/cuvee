evaluation/lemmas/tree.enumerate.bpl
  26  number of lemmas
forall y₀: nat :: (y₀ == add(y₀, zero))
forall x₁: list :: (x₁ == append(x₁, nil))
forall y₀: nat, y₁: nat :: (succ(add(y₀, y₁)) == add(y₀, succ(y₁)))
forall y₀: list, x₁: nat :: (add(length(y₀), x₁) == add(add(x₁, zero), length(y₀)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(add(y₁, y₀), add(x₁, zero)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), append(y₁, nil)))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(y₀, add(y₁, x₀)))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(y₁, add(y₀, x₀)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), y₁))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(add(y₀, x₁), y₁))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(x₁, add(y₁, y₀)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall y₀: [nat]nat, y₁: tree :: (size(maptree(y₀, y₁)) == add(size(y₁), zero))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall y₀: nat, y₁: tree :: (size(insert(y₀, y₁)) == size(insert(zero, y₁)))
forall y₀: [nat]nat, y₁: tree :: (elems(maptree(y₀, y₁)) == map(y₀, elems(y₁)))
forall y₀: nat, x₁: nat :: (succ(add(y₀, x₁)) == add(x₁, succ(y₀)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall y₀: [nat]nat, y₁: tree :: (size(maptree(y₀, y₁)) == length(elems(y₁)))
forall y₀: tree :: (succ(size(y₀)) == size(insert(zero, y₀)))
forall x₀: nat, y₀: nat :: (add(x₀, succ(y₀)) == add(add(y₀, x₀), succ(zero)))
forall y₀: tree :: (length(elems(y₀)) == size(y₀))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(add(x₁, y₁), add(y₀, zero)))
forall y₀: nat :: (succ(y₀) == add(y₀, succ(zero)))
forall y₀: tree :: (mirror(mirror(y₀)) == y₀)
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₁), length(y₀)))
  14  evaluation/lemmas/tree.structural.bpl
forall y₀: nat :: (y₀ == add(y₀, zero))
forall x₁: list :: (x₁ == append(x₁, nil))
forall y₀: nat, y₁: nat :: (succ(add(y₀, y₁)) == add(y₀, succ(y₁)))
forall y₀: list, x₁: nat :: (add(length(y₀), x₁) == add(add(x₁, zero), length(y₀)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(add(y₁, y₀), add(x₁, zero)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), append(y₁, nil)))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(y₀, add(y₁, x₀)))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(y₁, add(y₀, x₀)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), y₁))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(add(y₀, x₁), y₁))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(x₁, add(y₁, y₀)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall y₀: [nat]nat, y₁: tree :: (size(maptree(y₀, y₁)) == add(size(y₁), zero))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall y₀: nat, y₁: tree :: (size(insert(y₀, y₁)) == size(insert(zero, y₁)))
forall y₀: [nat]nat, y₁: tree :: (elems(maptree(y₀, y₁)) == map(y₀, elems(y₁)))
forall y₀: nat, x₁: nat :: (succ(add(y₀, x₁)) == add(x₁, succ(y₀)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall y₀: [nat]nat, y₁: tree :: (size(maptree(y₀, y₁)) == length(elems(y₁)))
forall y₀: tree :: (succ(size(y₀)) == size(insert(zero, y₀)))
forall x₀: nat, y₀: nat :: (add(x₀, succ(y₀)) == add(add(y₀, x₀), succ(zero)))
forall y₀: tree :: (length(elems(y₀)) == size(y₀))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(add(x₁, y₁), add(y₀, zero)))
forall y₀: nat :: (succ(y₀) == add(y₀, succ(zero)))
forall y₀: tree :: (mirror(mirror(y₀)) == y₀)
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₁), length(y₀)))
  14  evaluation/lemmas/tree.conditional.bpl
forall y₀: nat :: (y₀ == add(y₀, zero))
forall x₁: list :: (x₁ == append(x₁, nil))
forall y₀: nat, y₁: nat :: (succ(add(y₀, y₁)) == add(y₀, succ(y₁)))
forall y₀: list, x₁: nat :: (add(length(y₀), x₁) == add(add(x₁, zero), length(y₀)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(add(y₁, y₀), add(x₁, zero)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), append(y₁, nil)))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(y₀, add(y₁, x₀)))
forall x₀: nat, y₀: nat, y₁: nat :: (add(x₀, add(y₀, y₁)) == add(y₁, add(y₀, x₀)))
forall x₀: list, y₀: list, y₁: list :: (append(x₀, append(y₀, y₁)) == append(append(x₀, y₀), y₁))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(add(y₀, x₁), y₁))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(x₁, add(y₁, y₀)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall y₀: [nat]nat, y₁: tree :: (size(maptree(y₀, y₁)) == add(size(y₁), zero))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall y₀: nat, y₁: tree :: (size(insert(y₀, y₁)) == size(insert(zero, y₁)))
forall y₀: [nat]nat, y₁: tree :: (elems(maptree(y₀, y₁)) == map(y₀, elems(y₁)))
forall y₀: nat, x₁: nat :: (succ(add(y₀, x₁)) == add(x₁, succ(y₀)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall y₀: [nat]nat, y₁: tree :: (size(maptree(y₀, y₁)) == length(elems(y₁)))
forall y₀: tree :: (succ(size(y₀)) == size(insert(zero, y₀)))
forall x₀: nat, y₀: nat :: (add(x₀, succ(y₀)) == add(add(y₀, x₀), succ(zero)))
forall y₀: tree :: (length(elems(y₀)) == size(y₀))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(add(x₁, y₁), add(y₀, zero)))
forall y₀: nat :: (succ(y₀) == add(y₀, succ(zero)))
forall y₀: tree :: (mirror(mirror(y₀)) == y₀)
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₁), length(y₀)))
  23  evaluation/lemmas/tree.th.log
