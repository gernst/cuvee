evaluation/lemmas/list.structural.bpl
  33  number of lemmas
  0  wrong
forall y₀: list :: (reverse(reverse(y₀)) == y₀)
forall x₀: [nat]nat, y₀: list :: (map(x₀, reverse(y₀)) == reverse(map(x₀, y₀)))
forall x₀: [nat]nat, y₀: nat, y₁: list :: (map(x₀, rotate(y₀, y₁)) == rotate(y₀, map(x₀, y₁)))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == append(reverse(y₁), reverse(y₀)))
forall x₀: nat, y₀: list, y₁: list :: (count(x₀, append(y₀, y₁)) == add(count(x₀, y₀), count(x₀, y₁)))
forall x₀: nat, y₀: list, y₁: nat :: (count(x₀, snoc(y₀, y₁)) == add(count(x₀, y₀), count(x₀, cons(y₁, nil))))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: nat, x₁: list :: (append(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, x₁)))
forall y₀: list, y₁: nat :: (reverse(snoc(y₀, y₁)) == cons(y₁, reverse(y₀)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall x₀: [nat]nat, y₀: list, y₁: nat :: (map(x₀, snoc(y₀, y₁)) == append(map(x₀, y₀), cons(x₀[y₁], nil)))
forall x₀: nat, y₀: list, y₁: list :: (remove(x₀, append(y₀, y₁)) == append(remove(x₀, y₀), remove(x₀, y₁)))
forall x₀: nat, y₀: list, y₁: nat :: (remove(x₀, snoc(y₀, y₁)) == append(remove(x₀, y₀), remove(x₀, cons(y₁, nil))))
forall y₀: nat, y₁: list, x₁: nat :: (snoc(take(y₀, y₁), x₁) == append(take(y₀, y₁), cons(x₁, nil)))
forall y₀: list, y₁: list, x₁: nat :: (snoc(append(y₀, y₁), x₁) == append(y₀, append(y₁, cons(x₁, nil))))
forall y₀: [nat]nat, y₁: list, x₁: nat :: (snoc(map(y₀, y₁), x₁) == append(map(y₀, y₁), cons(x₁, nil)))
forall y₀: nat, y₁: list, x₁: nat :: (snoc(remove(y₀, y₁), x₁) == append(remove(y₀, y₁), cons(x₁, nil)))
forall y₀: list, y₁: nat, x₁: nat :: (snoc(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, cons(x₁, nil))))
forall y₀: [nat]Bool, y₁: list, x₁: nat :: (snoc(filter(y₀, y₁), x₁) == append(filter(y₀, y₁), cons(x₁, nil)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x₀: [nat]Bool, y₀: list, y₁: list :: (filter(x₀, append(y₀, y₁)) == append(filter(x₀, y₀), filter(x₀, y₁)))
forall x₀: [nat]Bool, y₀: list, y₁: nat :: (filter(x₀, snoc(y₀, y₁)) == append(filter(x₀, y₀), filter(x₀, cons(y₁, nil))))
forall x₀: [nat]Bool, y₀: list, y₁: list :: (countif(x₀, append(y₀, y₁)) == add(countif(x₀, y₀), countif(x₀, y₁)))
forall x₀: [nat]Bool, y₀: list, y₁: nat :: (countif(x₀, snoc(y₀, y₁)) == add(countif(x₀, y₀), countif(x₀, cons(y₁, nil))))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (take(x₀, map(y₀, y₁)) == map(y₀, take(x₀, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall y₀: [nat]Bool, y₁: list :: (length(filter(y₀, y₁)) == countif(y₀, y₁))
forall y₀: Bool :: (not_(not_(y₀)) <==> y₀)
forall x₀: nat, y₀: [nat]nat, y₁: list :: (drop(x₀, map(y₀, y₁)) == map(y₀, drop(x₀, y₁)))
forall x₀: list, x₁: nat :: (snoc(x₀, x₁) == append(x₀, cons(x₁, nil)))
forall x: list :: (append(x, nil) == x)
forall x: nat :: (add(x, zero) == x)
  32  nontrivial
forall y₀: list :: (reverse(reverse(y₀)) == y₀)
forall x₀: [nat]nat, y₀: list :: (map(x₀, reverse(y₀)) == reverse(map(x₀, y₀)))
forall x₀: [nat]nat, y₀: nat, y₁: list :: (map(x₀, rotate(y₀, y₁)) == rotate(y₀, map(x₀, y₁)))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == append(reverse(y₁), reverse(y₀)))
forall x₀: nat, y₀: list, y₁: list :: (count(x₀, append(y₀, y₁)) == add(count(x₀, y₀), count(x₀, y₁)))
forall x₀: nat, y₀: list, y₁: nat :: (count(x₀, snoc(y₀, y₁)) == add(count(x₀, y₀), count(x₀, cons(y₁, nil))))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: nat, x₁: list :: (append(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, x₁)))
forall y₀: list, y₁: nat :: (reverse(snoc(y₀, y₁)) == cons(y₁, reverse(y₀)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall x₀: [nat]nat, y₀: list, y₁: nat :: (map(x₀, snoc(y₀, y₁)) == append(map(x₀, y₀), cons(x₀[y₁], nil)))
forall x₀: nat, y₀: list, y₁: list :: (remove(x₀, append(y₀, y₁)) == append(remove(x₀, y₀), remove(x₀, y₁)))
forall x₀: nat, y₀: list, y₁: nat :: (remove(x₀, snoc(y₀, y₁)) == append(remove(x₀, y₀), remove(x₀, cons(y₁, nil))))
forall y₀: nat, y₁: list, x₁: nat :: (snoc(take(y₀, y₁), x₁) == append(take(y₀, y₁), cons(x₁, nil)))
forall y₀: list, y₁: list, x₁: nat :: (snoc(append(y₀, y₁), x₁) == append(y₀, append(y₁, cons(x₁, nil))))
forall y₀: [nat]nat, y₁: list, x₁: nat :: (snoc(map(y₀, y₁), x₁) == append(map(y₀, y₁), cons(x₁, nil)))
forall y₀: nat, y₁: list, x₁: nat :: (snoc(remove(y₀, y₁), x₁) == append(remove(y₀, y₁), cons(x₁, nil)))
forall y₀: list, y₁: nat, x₁: nat :: (snoc(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, cons(x₁, nil))))
forall y₀: [nat]Bool, y₁: list, x₁: nat :: (snoc(filter(y₀, y₁), x₁) == append(filter(y₀, y₁), cons(x₁, nil)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x₀: [nat]Bool, y₀: list, y₁: list :: (filter(x₀, append(y₀, y₁)) == append(filter(x₀, y₀), filter(x₀, y₁)))
forall x₀: [nat]Bool, y₀: list, y₁: nat :: (filter(x₀, snoc(y₀, y₁)) == append(filter(x₀, y₀), filter(x₀, cons(y₁, nil))))
forall x₀: [nat]Bool, y₀: list, y₁: list :: (countif(x₀, append(y₀, y₁)) == add(countif(x₀, y₀), countif(x₀, y₁)))
forall x₀: [nat]Bool, y₀: list, y₁: nat :: (countif(x₀, snoc(y₀, y₁)) == add(countif(x₀, y₀), countif(x₀, cons(y₁, nil))))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (take(x₀, map(y₀, y₁)) == map(y₀, take(x₀, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall y₀: [nat]Bool, y₁: list :: (length(filter(y₀, y₁)) == countif(y₀, y₁))
forall y₀: Bool :: (not_(not_(y₀)) <==> y₀)
forall x₀: nat, y₀: [nat]nat, y₁: list :: (drop(x₀, map(y₀, y₁)) == map(y₀, drop(x₀, y₁)))
forall x₀: list, x₁: nat :: (snoc(x₀, x₁) == append(x₀, cons(x₁, nil)))
forall x: list :: (append(x, nil) == x)
forall x: nat :: (add(x, zero) == x)
  22  reduced greedily
forall y₀: list :: (reverse(reverse(y₀)) == y₀)
forall x₀: [nat]nat, y₀: list :: (map(x₀, reverse(y₀)) == reverse(map(x₀, y₀)))
forall x₀: [nat]nat, y₀: nat, y₁: list :: (map(x₀, rotate(y₀, y₁)) == rotate(y₀, map(x₀, y₁)))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == append(reverse(y₁), reverse(y₀)))
forall x₀: nat, y₀: list, y₁: list :: (count(x₀, append(y₀, y₁)) == add(count(x₀, y₀), count(x₀, y₁)))
forall x₀: nat, y₀: list, y₁: nat :: (count(x₀, snoc(y₀, y₁)) == add(count(x₀, y₀), count(x₀, cons(y₁, nil))))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: nat, x₁: list :: (append(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, x₁)))
forall y₀: list, y₁: nat :: (reverse(snoc(y₀, y₁)) == cons(y₁, reverse(y₀)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall x₀: [nat]nat, y₀: list, y₁: nat :: (map(x₀, snoc(y₀, y₁)) == append(map(x₀, y₀), cons(x₀[y₁], nil)))
forall x₀: nat, y₀: list, y₁: list :: (remove(x₀, append(y₀, y₁)) == append(remove(x₀, y₀), remove(x₀, y₁)))
forall x₀: nat, y₀: list, y₁: nat :: (remove(x₀, snoc(y₀, y₁)) == append(remove(x₀, y₀), remove(x₀, cons(y₁, nil))))
forall y₀: nat, y₁: list, x₁: nat :: (snoc(take(y₀, y₁), x₁) == append(take(y₀, y₁), cons(x₁, nil)))
forall y₀: list, y₁: list, x₁: nat :: (snoc(append(y₀, y₁), x₁) == append(y₀, append(y₁, cons(x₁, nil))))
forall y₀: [nat]nat, y₁: list, x₁: nat :: (snoc(map(y₀, y₁), x₁) == append(map(y₀, y₁), cons(x₁, nil)))
forall y₀: nat, y₁: list, x₁: nat :: (snoc(remove(y₀, y₁), x₁) == append(remove(y₀, y₁), cons(x₁, nil)))
forall y₀: list, y₁: nat, x₁: nat :: (snoc(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, cons(x₁, nil))))
forall y₀: [nat]Bool, y₁: list, x₁: nat :: (snoc(filter(y₀, y₁), x₁) == append(filter(y₀, y₁), cons(x₁, nil)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x₀: [nat]Bool, y₀: list, y₁: list :: (filter(x₀, append(y₀, y₁)) == append(filter(x₀, y₀), filter(x₀, y₁)))
forall x₀: [nat]Bool, y₀: list, y₁: nat :: (filter(x₀, snoc(y₀, y₁)) == append(filter(x₀, y₀), filter(x₀, cons(y₁, nil))))
forall x₀: [nat]Bool, y₀: list, y₁: list :: (countif(x₀, append(y₀, y₁)) == add(countif(x₀, y₀), countif(x₀, y₁)))
forall x₀: [nat]Bool, y₀: list, y₁: nat :: (countif(x₀, snoc(y₀, y₁)) == add(countif(x₀, y₀), countif(x₀, cons(y₁, nil))))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (take(x₀, map(y₀, y₁)) == map(y₀, take(x₀, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall y₀: [nat]Bool, y₁: list :: (length(filter(y₀, y₁)) == countif(y₀, y₁))
forall y₀: Bool :: (not_(not_(y₀)) <==> y₀)
forall x₀: nat, y₀: [nat]nat, y₁: list :: (drop(x₀, map(y₀, y₁)) == map(y₀, drop(x₀, y₁)))
forall x₀: list, x₁: nat :: (snoc(x₀, x₁) == append(x₀, cons(x₁, nil)))
forall x: list :: (append(x, nil) == x)
forall x: nat :: (add(x, zero) == x)
  16  independent
forall y₀: list :: (reverse(reverse(y₀)) == y₀)
forall x₀: [nat]nat, y₀: list :: (map(x₀, reverse(y₀)) == reverse(map(x₀, y₀)))
forall x₀: [nat]nat, y₀: nat, y₁: list :: (map(x₀, rotate(y₀, y₁)) == rotate(y₀, map(x₀, y₁)))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == append(reverse(y₁), reverse(y₀)))
forall x₀: nat, y₀: list, y₁: list :: (count(x₀, append(y₀, y₁)) == add(count(x₀, y₀), count(x₀, y₁)))
forall x₀: nat, y₀: list, y₁: nat :: (count(x₀, snoc(y₀, y₁)) == add(count(x₀, y₀), count(x₀, cons(y₁, nil))))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: nat, x₁: list :: (append(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, x₁)))
forall y₀: list, y₁: nat :: (reverse(snoc(y₀, y₁)) == cons(y₁, reverse(y₀)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall x₀: [nat]nat, y₀: list, y₁: nat :: (map(x₀, snoc(y₀, y₁)) == append(map(x₀, y₀), cons(x₀[y₁], nil)))
forall x₀: nat, y₀: list, y₁: list :: (remove(x₀, append(y₀, y₁)) == append(remove(x₀, y₀), remove(x₀, y₁)))
forall x₀: nat, y₀: list, y₁: nat :: (remove(x₀, snoc(y₀, y₁)) == append(remove(x₀, y₀), remove(x₀, cons(y₁, nil))))
forall y₀: nat, y₁: list, x₁: nat :: (snoc(take(y₀, y₁), x₁) == append(take(y₀, y₁), cons(x₁, nil)))
forall y₀: list, y₁: list, x₁: nat :: (snoc(append(y₀, y₁), x₁) == append(y₀, append(y₁, cons(x₁, nil))))
forall y₀: [nat]nat, y₁: list, x₁: nat :: (snoc(map(y₀, y₁), x₁) == append(map(y₀, y₁), cons(x₁, nil)))
forall y₀: nat, y₁: list, x₁: nat :: (snoc(remove(y₀, y₁), x₁) == append(remove(y₀, y₁), cons(x₁, nil)))
forall y₀: list, y₁: nat, x₁: nat :: (snoc(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, cons(x₁, nil))))
forall y₀: [nat]Bool, y₁: list, x₁: nat :: (snoc(filter(y₀, y₁), x₁) == append(filter(y₀, y₁), cons(x₁, nil)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x₀: [nat]Bool, y₀: list, y₁: list :: (filter(x₀, append(y₀, y₁)) == append(filter(x₀, y₀), filter(x₀, y₁)))
forall x₀: [nat]Bool, y₀: list, y₁: nat :: (filter(x₀, snoc(y₀, y₁)) == append(filter(x₀, y₀), filter(x₀, cons(y₁, nil))))
forall x₀: [nat]Bool, y₀: list, y₁: list :: (countif(x₀, append(y₀, y₁)) == add(countif(x₀, y₀), countif(x₀, y₁)))
forall x₀: [nat]Bool, y₀: list, y₁: nat :: (countif(x₀, snoc(y₀, y₁)) == add(countif(x₀, y₀), countif(x₀, cons(y₁, nil))))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (take(x₀, map(y₀, y₁)) == map(y₀, take(x₀, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall y₀: [nat]Bool, y₁: list :: (length(filter(y₀, y₁)) == countif(y₀, y₁))
forall y₀: Bool :: (not_(not_(y₀)) <==> y₀)
forall x₀: nat, y₀: [nat]nat, y₁: list :: (drop(x₀, map(y₀, y₁)) == map(y₀, drop(x₀, y₁)))
forall x₀: list, x₁: nat :: (snoc(x₀, x₁) == append(x₀, cons(x₁, nil)))
forall x: list :: (append(x, nil) == x)
forall x: nat :: (add(x, zero) == x)
  0  evaluation/lemmas/list.conditional.bpl
forall y₀: list :: (reverse(reverse(y₀)) == y₀)
forall x₀: [nat]nat, y₀: list :: (map(x₀, reverse(y₀)) == reverse(map(x₀, y₀)))
forall x₀: [nat]nat, y₀: nat, y₁: list :: (map(x₀, rotate(y₀, y₁)) == rotate(y₀, map(x₀, y₁)))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == append(reverse(y₁), reverse(y₀)))
forall x₀: nat, y₀: list, y₁: list :: (count(x₀, append(y₀, y₁)) == add(count(x₀, y₀), count(x₀, y₁)))
forall x₀: nat, y₀: list, y₁: nat :: (count(x₀, snoc(y₀, y₁)) == add(count(x₀, y₀), count(x₀, cons(y₁, nil))))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: nat, x₁: list :: (append(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, x₁)))
forall y₀: list, y₁: nat :: (reverse(snoc(y₀, y₁)) == cons(y₁, reverse(y₀)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall x₀: [nat]nat, y₀: list, y₁: nat :: (map(x₀, snoc(y₀, y₁)) == append(map(x₀, y₀), cons(x₀[y₁], nil)))
forall x₀: nat, y₀: list, y₁: list :: (remove(x₀, append(y₀, y₁)) == append(remove(x₀, y₀), remove(x₀, y₁)))
forall x₀: nat, y₀: list, y₁: nat :: (remove(x₀, snoc(y₀, y₁)) == append(remove(x₀, y₀), remove(x₀, cons(y₁, nil))))
forall y₀: nat, y₁: list, x₁: nat :: (snoc(take(y₀, y₁), x₁) == append(take(y₀, y₁), cons(x₁, nil)))
forall y₀: list, y₁: list, x₁: nat :: (snoc(append(y₀, y₁), x₁) == append(y₀, append(y₁, cons(x₁, nil))))
forall y₀: [nat]nat, y₁: list, x₁: nat :: (snoc(map(y₀, y₁), x₁) == append(map(y₀, y₁), cons(x₁, nil)))
forall y₀: nat, y₁: list, x₁: nat :: (snoc(remove(y₀, y₁), x₁) == append(remove(y₀, y₁), cons(x₁, nil)))
forall y₀: list, y₁: nat, x₁: nat :: (snoc(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, cons(x₁, nil))))
forall y₀: [nat]Bool, y₁: list, x₁: nat :: (snoc(filter(y₀, y₁), x₁) == append(filter(y₀, y₁), cons(x₁, nil)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x₀: [nat]Bool, y₀: list, y₁: list :: (filter(x₀, append(y₀, y₁)) == append(filter(x₀, y₀), filter(x₀, y₁)))
forall x₀: [nat]Bool, y₀: list, y₁: nat :: (filter(x₀, snoc(y₀, y₁)) == append(filter(x₀, y₀), filter(x₀, cons(y₁, nil))))
forall x₀: [nat]Bool, y₀: list, y₁: list :: (countif(x₀, append(y₀, y₁)) == add(countif(x₀, y₀), countif(x₀, y₁)))
forall x₀: [nat]Bool, y₀: list, y₁: nat :: (countif(x₀, snoc(y₀, y₁)) == add(countif(x₀, y₀), countif(x₀, cons(y₁, nil))))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (take(x₀, map(y₀, y₁)) == map(y₀, take(x₀, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall y₀: [nat]Bool, y₁: list :: (length(filter(y₀, y₁)) == countif(y₀, y₁))
forall y₀: Bool :: (not_(not_(y₀)) <==> y₀)
forall x₀: nat, y₀: [nat]nat, y₁: list :: (drop(x₀, map(y₀, y₁)) == map(y₀, drop(x₀, y₁)))
forall x₀: list, x₁: nat :: (snoc(x₀, x₁) == append(x₀, cons(x₁, nil)))
forall x: list :: (append(x, nil) == x)
forall x: nat :: (add(x, zero) == x)
  22  evaluation/lemmas/list.enumerate.bpl
forall y₀: list :: (reverse(reverse(y₀)) == y₀)
forall x₀: [nat]nat, y₀: list :: (map(x₀, reverse(y₀)) == reverse(map(x₀, y₀)))
forall x₀: [nat]nat, y₀: nat, y₁: list :: (map(x₀, rotate(y₀, y₁)) == rotate(y₀, map(x₀, y₁)))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == append(reverse(y₁), reverse(y₀)))
forall x₀: nat, y₀: list, y₁: list :: (count(x₀, append(y₀, y₁)) == add(count(x₀, y₀), count(x₀, y₁)))
forall x₀: nat, y₀: list, y₁: nat :: (count(x₀, snoc(y₀, y₁)) == add(count(x₀, y₀), count(x₀, cons(y₁, nil))))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: nat, x₁: list :: (append(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, x₁)))
forall y₀: list, y₁: nat :: (reverse(snoc(y₀, y₁)) == cons(y₁, reverse(y₀)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall x₀: [nat]nat, y₀: list, y₁: nat :: (map(x₀, snoc(y₀, y₁)) == append(map(x₀, y₀), cons(x₀[y₁], nil)))
forall x₀: nat, y₀: list, y₁: list :: (remove(x₀, append(y₀, y₁)) == append(remove(x₀, y₀), remove(x₀, y₁)))
forall x₀: nat, y₀: list, y₁: nat :: (remove(x₀, snoc(y₀, y₁)) == append(remove(x₀, y₀), remove(x₀, cons(y₁, nil))))
forall y₀: nat, y₁: list, x₁: nat :: (snoc(take(y₀, y₁), x₁) == append(take(y₀, y₁), cons(x₁, nil)))
forall y₀: list, y₁: list, x₁: nat :: (snoc(append(y₀, y₁), x₁) == append(y₀, append(y₁, cons(x₁, nil))))
forall y₀: [nat]nat, y₁: list, x₁: nat :: (snoc(map(y₀, y₁), x₁) == append(map(y₀, y₁), cons(x₁, nil)))
forall y₀: nat, y₁: list, x₁: nat :: (snoc(remove(y₀, y₁), x₁) == append(remove(y₀, y₁), cons(x₁, nil)))
forall y₀: list, y₁: nat, x₁: nat :: (snoc(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, cons(x₁, nil))))
forall y₀: [nat]Bool, y₁: list, x₁: nat :: (snoc(filter(y₀, y₁), x₁) == append(filter(y₀, y₁), cons(x₁, nil)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x₀: [nat]Bool, y₀: list, y₁: list :: (filter(x₀, append(y₀, y₁)) == append(filter(x₀, y₀), filter(x₀, y₁)))
forall x₀: [nat]Bool, y₀: list, y₁: nat :: (filter(x₀, snoc(y₀, y₁)) == append(filter(x₀, y₀), filter(x₀, cons(y₁, nil))))
forall x₀: [nat]Bool, y₀: list, y₁: list :: (countif(x₀, append(y₀, y₁)) == add(countif(x₀, y₀), countif(x₀, y₁)))
forall x₀: [nat]Bool, y₀: list, y₁: nat :: (countif(x₀, snoc(y₀, y₁)) == add(countif(x₀, y₀), countif(x₀, cons(y₁, nil))))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (take(x₀, map(y₀, y₁)) == map(y₀, take(x₀, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall y₀: [nat]Bool, y₁: list :: (length(filter(y₀, y₁)) == countif(y₀, y₁))
forall y₀: Bool :: (not_(not_(y₀)) <==> y₀)
forall x₀: nat, y₀: [nat]nat, y₁: list :: (drop(x₀, map(y₀, y₁)) == map(y₀, drop(x₀, y₁)))
forall x₀: list, x₁: nat :: (snoc(x₀, x₁) == append(x₀, cons(x₁, nil)))
forall x: list :: (append(x, nil) == x)
forall x: nat :: (add(x, zero) == x)
  30  evaluation/lemmas/list.th.log
