evaluation/lemmas/list/append.conditional.bpl
  12  number of lemmas
  0  wrong
forall x₀: nat, y₀: list, y₁: list :: (count(x₀, append(y₀, y₁)) == add(count(x₀, y₀), count(x₀, y₁)))
forall x₀: nat, y₀: list, y₁: nat :: (count(x₀, snoc(y₀, y₁)) == add(count(x₀, y₀), count(x₀, cons(y₁, nil))))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: nat, x₁: list :: (append(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, x₁)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall y₀: list, y₁: list, x₁: nat :: (snoc(append(y₀, y₁), x₁) == append(y₀, append(y₁, cons(x₁, nil))))
forall y₀: list, y₁: nat, x₁: nat :: (snoc(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, cons(x₁, nil))))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x₀: list, x₁: nat :: (snoc(x₀, x₁) == append(x₀, cons(x₁, nil)))
forall x: list :: (append(x, nil) == x)
forall x: nat :: (add(x, zero) == x)
forall x: list, y₀: list, z₀: nat :: ((y₀ == cons(z₀, nil)) ==> (append(x, y₀) == append(x, cons(z₀, nil))))
  11  nontrivial
forall x₀: nat, y₀: list, y₁: list :: (count(x₀, append(y₀, y₁)) == add(count(x₀, y₀), count(x₀, y₁)))
forall x₀: nat, y₀: list, y₁: nat :: (count(x₀, snoc(y₀, y₁)) == add(count(x₀, y₀), count(x₀, cons(y₁, nil))))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: nat, x₁: list :: (append(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, x₁)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall y₀: list, y₁: list, x₁: nat :: (snoc(append(y₀, y₁), x₁) == append(y₀, append(y₁, cons(x₁, nil))))
forall y₀: list, y₁: nat, x₁: nat :: (snoc(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, cons(x₁, nil))))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x₀: list, x₁: nat :: (snoc(x₀, x₁) == append(x₀, cons(x₁, nil)))
forall x: list :: (append(x, nil) == x)
forall x: nat :: (add(x, zero) == x)
forall x: list, y₀: list, z₀: nat :: ((y₀ == cons(z₀, nil)) ==> (append(x, y₀) == append(x, cons(z₀, nil))))
  10  reduced greedily
forall x₀: nat, y₀: list, y₁: list :: (count(x₀, append(y₀, y₁)) == add(count(x₀, y₀), count(x₀, y₁)))
forall x₀: nat, y₀: list, y₁: nat :: (count(x₀, snoc(y₀, y₁)) == add(count(x₀, y₀), count(x₀, cons(y₁, nil))))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: nat, x₁: list :: (append(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, x₁)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall y₀: list, y₁: list, x₁: nat :: (snoc(append(y₀, y₁), x₁) == append(y₀, append(y₁, cons(x₁, nil))))
forall y₀: list, y₁: nat, x₁: nat :: (snoc(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, cons(x₁, nil))))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x₀: list, x₁: nat :: (snoc(x₀, x₁) == append(x₀, cons(x₁, nil)))
forall x: list :: (append(x, nil) == x)
forall x: nat :: (add(x, zero) == x)
forall x: list, y₀: list, z₀: nat :: ((y₀ == cons(z₀, nil)) ==> (append(x, y₀) == append(x, cons(z₀, nil))))
  6  independent
forall x₀: nat, y₀: list, y₁: list :: (count(x₀, append(y₀, y₁)) == add(count(x₀, y₀), count(x₀, y₁)))
forall x₀: nat, y₀: list, y₁: nat :: (count(x₀, snoc(y₀, y₁)) == add(count(x₀, y₀), count(x₀, cons(y₁, nil))))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: nat, x₁: list :: (append(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, x₁)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall y₀: list, y₁: list, x₁: nat :: (snoc(append(y₀, y₁), x₁) == append(y₀, append(y₁, cons(x₁, nil))))
forall y₀: list, y₁: nat, x₁: nat :: (snoc(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, cons(x₁, nil))))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x₀: list, x₁: nat :: (snoc(x₀, x₁) == append(x₀, cons(x₁, nil)))
forall x: list :: (append(x, nil) == x)
forall x: nat :: (add(x, zero) == x)
forall x: list, y₀: list, z₀: nat :: ((y₀ == cons(z₀, nil)) ==> (append(x, y₀) == append(x, cons(z₀, nil))))
  0  evaluation/lemmas/list/append.structural.bpl
forall x₀: nat, y₀: list, y₁: list :: (count(x₀, append(y₀, y₁)) == add(count(x₀, y₀), count(x₀, y₁)))
forall x₀: nat, y₀: list, y₁: nat :: (count(x₀, snoc(y₀, y₁)) == add(count(x₀, y₀), count(x₀, cons(y₁, nil))))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: nat, x₁: list :: (append(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, x₁)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall y₀: list, y₁: list, x₁: nat :: (snoc(append(y₀, y₁), x₁) == append(y₀, append(y₁, cons(x₁, nil))))
forall y₀: list, y₁: nat, x₁: nat :: (snoc(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, cons(x₁, nil))))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x₀: list, x₁: nat :: (snoc(x₀, x₁) == append(x₀, cons(x₁, nil)))
forall x: list :: (append(x, nil) == x)
forall x: nat :: (add(x, zero) == x)
forall x: list, y₀: list, z₀: nat :: ((y₀ == cons(z₀, nil)) ==> (append(x, y₀) == append(x, cons(z₀, nil))))
  5  evaluation/lemmas/list/append.enumerate.bpl
forall x₀: nat, y₀: list, y₁: list :: (count(x₀, append(y₀, y₁)) == add(count(x₀, y₀), count(x₀, y₁)))
forall x₀: nat, y₀: list, y₁: nat :: (count(x₀, snoc(y₀, y₁)) == add(count(x₀, y₀), count(x₀, cons(y₁, nil))))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: nat, x₁: list :: (append(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, x₁)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall y₀: list, y₁: list, x₁: nat :: (snoc(append(y₀, y₁), x₁) == append(y₀, append(y₁, cons(x₁, nil))))
forall y₀: list, y₁: nat, x₁: nat :: (snoc(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, cons(x₁, nil))))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x₀: list, x₁: nat :: (snoc(x₀, x₁) == append(x₀, cons(x₁, nil)))
forall x: list :: (append(x, nil) == x)
forall x: nat :: (add(x, zero) == x)
forall x: list, y₀: list, z₀: nat :: ((y₀ == cons(z₀, nil)) ==> (append(x, y₀) == append(x, cons(z₀, nil))))
  4  evaluation/lemmas/list/append.th.log
evaluation/lemmas/list/filter.conditional.bpl
  6  number of lemmas
  0  wrong
forall y₀: [nat]Bool, y₁: list :: (length(filter(y₀, y₁)) == countif(y₀, y₁))
forall y₀: Bool :: (not_(not_(y₀)) <==> y₀)
forall x₀: [nat]Bool, x₁: list :: (not_(ex(x₀, x₁)) ==> (filter(x₀, x₁) == nil))
forall x₀: [nat]Bool, x₁: list :: (all(x₀, x₁) ==> (filter(x₀, x₁) == x₁))
forall x₀: [nat]Bool, x₁: list :: (not_(ex(x₀, x₁)) ==> (countif(x₀, x₁) == zero))
forall x: list, y₀: [nat]Bool :: (all(y₀, x) ==> (countif(y₀, x) == length(x)))
  5  nontrivial
forall y₀: [nat]Bool, y₁: list :: (length(filter(y₀, y₁)) == countif(y₀, y₁))
forall y₀: Bool :: (not_(not_(y₀)) <==> y₀)
forall x₀: [nat]Bool, x₁: list :: (not_(ex(x₀, x₁)) ==> (filter(x₀, x₁) == nil))
forall x₀: [nat]Bool, x₁: list :: (all(x₀, x₁) ==> (filter(x₀, x₁) == x₁))
forall x₀: [nat]Bool, x₁: list :: (not_(ex(x₀, x₁)) ==> (countif(x₀, x₁) == zero))
forall x: list, y₀: [nat]Bool :: (all(y₀, x) ==> (countif(y₀, x) == length(x)))
  3  reduced greedily
forall y₀: [nat]Bool, y₁: list :: (length(filter(y₀, y₁)) == countif(y₀, y₁))
forall y₀: Bool :: (not_(not_(y₀)) <==> y₀)
forall x₀: [nat]Bool, x₁: list :: (not_(ex(x₀, x₁)) ==> (filter(x₀, x₁) == nil))
forall x₀: [nat]Bool, x₁: list :: (all(x₀, x₁) ==> (filter(x₀, x₁) == x₁))
forall x₀: [nat]Bool, x₁: list :: (not_(ex(x₀, x₁)) ==> (countif(x₀, x₁) == zero))
forall x: list, y₀: [nat]Bool :: (all(y₀, x) ==> (countif(y₀, x) == length(x)))
  2  independent
forall y₀: [nat]Bool, y₁: list :: (length(filter(y₀, y₁)) == countif(y₀, y₁))
forall y₀: Bool :: (not_(not_(y₀)) <==> y₀)
forall x₀: [nat]Bool, x₁: list :: (not_(ex(x₀, x₁)) ==> (filter(x₀, x₁) == nil))
forall x₀: [nat]Bool, x₁: list :: (all(x₀, x₁) ==> (filter(x₀, x₁) == x₁))
forall x₀: [nat]Bool, x₁: list :: (not_(ex(x₀, x₁)) ==> (countif(x₀, x₁) == zero))
forall x: list, y₀: [nat]Bool :: (all(y₀, x) ==> (countif(y₀, x) == length(x)))
  4  evaluation/lemmas/list/filter.structural.bpl
forall y₀: [nat]Bool, y₁: list :: (length(filter(y₀, y₁)) == countif(y₀, y₁))
forall y₀: Bool :: (not_(not_(y₀)) <==> y₀)
forall x₀: [nat]Bool, x₁: list :: (not_(ex(x₀, x₁)) ==> (filter(x₀, x₁) == nil))
forall x₀: [nat]Bool, x₁: list :: (all(x₀, x₁) ==> (filter(x₀, x₁) == x₁))
forall x₀: [nat]Bool, x₁: list :: (not_(ex(x₀, x₁)) ==> (countif(x₀, x₁) == zero))
forall x: list, y₀: [nat]Bool :: (all(y₀, x) ==> (countif(y₀, x) == length(x)))
  4  evaluation/lemmas/list/filter.enumerate.bpl
forall y₀: [nat]Bool, y₁: list :: (length(filter(y₀, y₁)) == countif(y₀, y₁))
forall y₀: Bool :: (not_(not_(y₀)) <==> y₀)
forall x₀: [nat]Bool, x₁: list :: (not_(ex(x₀, x₁)) ==> (filter(x₀, x₁) == nil))
forall x₀: [nat]Bool, x₁: list :: (all(x₀, x₁) ==> (filter(x₀, x₁) == x₁))
forall x₀: [nat]Bool, x₁: list :: (not_(ex(x₀, x₁)) ==> (countif(x₀, x₁) == zero))
forall x: list, y₀: [nat]Bool :: (all(y₀, x) ==> (countif(y₀, x) == length(x)))
  2  evaluation/lemmas/list/filter.th.log
evaluation/lemmas/list/length.conditional.bpl
  5  number of lemmas
  0  wrong
forall y₀: list, y₁: nat, x₁: nat :: (add(nlength(y₀, y₁), x₁) == nlength(y₀, add(y₁, x₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall y₀: list, x₁: nat :: (add(length(y₀), x₁) == nlength(y₀, x₁))
forall x: nat :: (add(x, zero) == x)
forall x: list, z₀: nat :: ((zero == z₀) ==> (length(x) == nlength(x, z₀)))
  5  nontrivial
forall y₀: list, y₁: nat, x₁: nat :: (add(nlength(y₀, y₁), x₁) == nlength(y₀, add(y₁, x₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall y₀: list, x₁: nat :: (add(length(y₀), x₁) == nlength(y₀, x₁))
forall x: nat :: (add(x, zero) == x)
forall x: list, z₀: nat :: ((zero == z₀) ==> (length(x) == nlength(x, z₀)))
  4  reduced greedily
forall y₀: list, y₁: nat, x₁: nat :: (add(nlength(y₀, y₁), x₁) == nlength(y₀, add(y₁, x₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall y₀: list, x₁: nat :: (add(length(y₀), x₁) == nlength(y₀, x₁))
forall x: nat :: (add(x, zero) == x)
forall x: list, z₀: nat :: ((zero == z₀) ==> (length(x) == nlength(x, z₀)))
  2  independent
forall y₀: list, y₁: nat, x₁: nat :: (add(nlength(y₀, y₁), x₁) == nlength(y₀, add(y₁, x₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall y₀: list, x₁: nat :: (add(length(y₀), x₁) == nlength(y₀, x₁))
forall x: nat :: (add(x, zero) == x)
forall x: list, z₀: nat :: ((zero == z₀) ==> (length(x) == nlength(x, z₀)))
  0  evaluation/lemmas/list/length.structural.bpl
forall y₀: list, y₁: nat, x₁: nat :: (add(nlength(y₀, y₁), x₁) == nlength(y₀, add(y₁, x₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall y₀: list, x₁: nat :: (add(length(y₀), x₁) == nlength(y₀, x₁))
forall x: nat :: (add(x, zero) == x)
forall x: list, z₀: nat :: ((zero == z₀) ==> (length(x) == nlength(x, z₀)))
  0  evaluation/lemmas/list/length.enumerate.bpl
forall y₀: list, y₁: nat, x₁: nat :: (add(nlength(y₀, y₁), x₁) == nlength(y₀, add(y₁, x₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall y₀: list, x₁: nat :: (add(length(y₀), x₁) == nlength(y₀, x₁))
forall x: nat :: (add(x, zero) == x)
forall x: list, z₀: nat :: ((zero == z₀) ==> (length(x) == nlength(x, z₀)))
  4  evaluation/lemmas/list/length.th.log
evaluation/lemmas/list/map.conditional.bpl
  16  number of lemmas
  0  wrong
forall x₀: nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (take(x₀, drop(x₁, x₂)) == nil))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall x₀: nat, x₁: list, x₂: list :: (leq(length(x₁), x₀) ==> (append(drop(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: list :: (lt(x₀, length(x₁)) ==> (length(take(x₀, x₁)) == x₀))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (length(drop(x₀, x₁)) == zero))
forall x₀: nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (drop(x₀, drop(x₁, x₂)) == nil))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall x₀: [nat]nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (map(x₀, drop(x₁, x₂)) == nil))
forall x₀: nat, x₁: list :: (lt(x₀, length(x₁)) ==> (leq(x₀, length(x₁)) <==> true))
forall x₀: list, x₁: nat :: (lt(x₁, length(x₀)) ==> (lt(length(x₀), x₁) <==> false))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (take(x₀, map(y₀, y₁)) == map(y₀, take(x₀, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (drop(x₀, map(y₀, y₁)) == map(y₀, drop(x₀, y₁)))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (take(x₀, x₁) == x₁))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (drop(x₀, x₁) == nil))
forall x: list :: (append(x, nil) == x)
  16  nontrivial
forall x₀: nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (take(x₀, drop(x₁, x₂)) == nil))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall x₀: nat, x₁: list, x₂: list :: (leq(length(x₁), x₀) ==> (append(drop(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: list :: (lt(x₀, length(x₁)) ==> (length(take(x₀, x₁)) == x₀))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (length(drop(x₀, x₁)) == zero))
forall x₀: nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (drop(x₀, drop(x₁, x₂)) == nil))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall x₀: [nat]nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (map(x₀, drop(x₁, x₂)) == nil))
forall x₀: nat, x₁: list :: (lt(x₀, length(x₁)) ==> (leq(x₀, length(x₁)) <==> true))
forall x₀: list, x₁: nat :: (lt(x₁, length(x₀)) ==> (lt(length(x₀), x₁) <==> false))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (take(x₀, map(y₀, y₁)) == map(y₀, take(x₀, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (drop(x₀, map(y₀, y₁)) == map(y₀, drop(x₀, y₁)))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (take(x₀, x₁) == x₁))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (drop(x₀, x₁) == nil))
forall x: list :: (append(x, nil) == x)
  11  reduced greedily
forall x₀: nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (take(x₀, drop(x₁, x₂)) == nil))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall x₀: nat, x₁: list, x₂: list :: (leq(length(x₁), x₀) ==> (append(drop(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: list :: (lt(x₀, length(x₁)) ==> (length(take(x₀, x₁)) == x₀))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (length(drop(x₀, x₁)) == zero))
forall x₀: nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (drop(x₀, drop(x₁, x₂)) == nil))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall x₀: [nat]nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (map(x₀, drop(x₁, x₂)) == nil))
forall x₀: nat, x₁: list :: (lt(x₀, length(x₁)) ==> (leq(x₀, length(x₁)) <==> true))
forall x₀: list, x₁: nat :: (lt(x₁, length(x₀)) ==> (lt(length(x₀), x₁) <==> false))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (take(x₀, map(y₀, y₁)) == map(y₀, take(x₀, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (drop(x₀, map(y₀, y₁)) == map(y₀, drop(x₀, y₁)))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (take(x₀, x₁) == x₁))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (drop(x₀, x₁) == nil))
forall x: list :: (append(x, nil) == x)
  10  independent
forall x₀: nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (take(x₀, drop(x₁, x₂)) == nil))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall x₀: nat, x₁: list, x₂: list :: (leq(length(x₁), x₀) ==> (append(drop(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: list :: (lt(x₀, length(x₁)) ==> (length(take(x₀, x₁)) == x₀))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (length(drop(x₀, x₁)) == zero))
forall x₀: nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (drop(x₀, drop(x₁, x₂)) == nil))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall x₀: [nat]nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (map(x₀, drop(x₁, x₂)) == nil))
forall x₀: nat, x₁: list :: (lt(x₀, length(x₁)) ==> (leq(x₀, length(x₁)) <==> true))
forall x₀: list, x₁: nat :: (lt(x₁, length(x₀)) ==> (lt(length(x₀), x₁) <==> false))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (take(x₀, map(y₀, y₁)) == map(y₀, take(x₀, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (drop(x₀, map(y₀, y₁)) == map(y₀, drop(x₀, y₁)))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (take(x₀, x₁) == x₁))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (drop(x₀, x₁) == nil))
forall x: list :: (append(x, nil) == x)
  10  evaluation/lemmas/list/map.structural.bpl
forall x₀: nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (take(x₀, drop(x₁, x₂)) == nil))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall x₀: nat, x₁: list, x₂: list :: (leq(length(x₁), x₀) ==> (append(drop(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: list :: (lt(x₀, length(x₁)) ==> (length(take(x₀, x₁)) == x₀))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (length(drop(x₀, x₁)) == zero))
forall x₀: nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (drop(x₀, drop(x₁, x₂)) == nil))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall x₀: [nat]nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (map(x₀, drop(x₁, x₂)) == nil))
forall x₀: nat, x₁: list :: (lt(x₀, length(x₁)) ==> (leq(x₀, length(x₁)) <==> true))
forall x₀: list, x₁: nat :: (lt(x₁, length(x₀)) ==> (lt(length(x₀), x₁) <==> false))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (take(x₀, map(y₀, y₁)) == map(y₀, take(x₀, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (drop(x₀, map(y₀, y₁)) == map(y₀, drop(x₀, y₁)))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (take(x₀, x₁) == x₁))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (drop(x₀, x₁) == nil))
forall x: list :: (append(x, nil) == x)
  12  evaluation/lemmas/list/map.enumerate.bpl
forall x₀: nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (take(x₀, drop(x₁, x₂)) == nil))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall x₀: nat, x₁: list, x₂: list :: (leq(length(x₁), x₀) ==> (append(drop(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: list :: (lt(x₀, length(x₁)) ==> (length(take(x₀, x₁)) == x₀))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (length(drop(x₀, x₁)) == zero))
forall x₀: nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (drop(x₀, drop(x₁, x₂)) == nil))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall x₀: [nat]nat, x₁: nat, x₂: list :: (leq(length(x₂), x₁) ==> (map(x₀, drop(x₁, x₂)) == nil))
forall x₀: nat, x₁: list :: (lt(x₀, length(x₁)) ==> (leq(x₀, length(x₁)) <==> true))
forall x₀: list, x₁: nat :: (lt(x₁, length(x₀)) ==> (lt(length(x₀), x₁) <==> false))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (take(x₀, map(y₀, y₁)) == map(y₀, take(x₀, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (drop(x₀, map(y₀, y₁)) == map(y₀, drop(x₀, y₁)))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (take(x₀, x₁) == x₁))
forall x₀: nat, x₁: list :: (leq(length(x₁), x₀) ==> (drop(x₀, x₁) == nil))
forall x: list :: (append(x, nil) == x)
  10  evaluation/lemmas/list/map.th.log
evaluation/lemmas/list/remove.conditional.bpl
  6  number of lemmas
  0  wrong
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x₀: nat, x₁: list, x₂: nat :: (not_(contains(x₀, x₁)) ==> (add(count(x₀, x₁), x₂) == x₂))
forall y₀: Bool :: (not_(not_(y₀)) <==> y₀)
forall x₀: nat, x₁: list :: (not_(contains(x₀, x₁)) ==> (remove(x₀, x₁) == x₁))
forall x₀: nat, x₁: list :: (not_(contains(x₀, x₁)) ==> (count(x₀, x₁) == zero))
forall x: nat :: (add(x, zero) == x)
  5  nontrivial
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x₀: nat, x₁: list, x₂: nat :: (not_(contains(x₀, x₁)) ==> (add(count(x₀, x₁), x₂) == x₂))
forall y₀: Bool :: (not_(not_(y₀)) <==> y₀)
forall x₀: nat, x₁: list :: (not_(contains(x₀, x₁)) ==> (remove(x₀, x₁) == x₁))
forall x₀: nat, x₁: list :: (not_(contains(x₀, x₁)) ==> (count(x₀, x₁) == zero))
forall x: nat :: (add(x, zero) == x)
  5  reduced greedily
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x₀: nat, x₁: list, x₂: nat :: (not_(contains(x₀, x₁)) ==> (add(count(x₀, x₁), x₂) == x₂))
forall y₀: Bool :: (not_(not_(y₀)) <==> y₀)
forall x₀: nat, x₁: list :: (not_(contains(x₀, x₁)) ==> (remove(x₀, x₁) == x₁))
forall x₀: nat, x₁: list :: (not_(contains(x₀, x₁)) ==> (count(x₀, x₁) == zero))
forall x: nat :: (add(x, zero) == x)
  4  independent
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x₀: nat, x₁: list, x₂: nat :: (not_(contains(x₀, x₁)) ==> (add(count(x₀, x₁), x₂) == x₂))
forall y₀: Bool :: (not_(not_(y₀)) <==> y₀)
forall x₀: nat, x₁: list :: (not_(contains(x₀, x₁)) ==> (remove(x₀, x₁) == x₁))
forall x₀: nat, x₁: list :: (not_(contains(x₀, x₁)) ==> (count(x₀, x₁) == zero))
forall x: nat :: (add(x, zero) == x)
  3  evaluation/lemmas/list/remove.structural.bpl
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x₀: nat, x₁: list, x₂: nat :: (not_(contains(x₀, x₁)) ==> (add(count(x₀, x₁), x₂) == x₂))
forall y₀: Bool :: (not_(not_(y₀)) <==> y₀)
forall x₀: nat, x₁: list :: (not_(contains(x₀, x₁)) ==> (remove(x₀, x₁) == x₁))
forall x₀: nat, x₁: list :: (not_(contains(x₀, x₁)) ==> (count(x₀, x₁) == zero))
forall x: nat :: (add(x, zero) == x)
  3  evaluation/lemmas/list/remove.enumerate.bpl
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x₀: nat, x₁: list, x₂: nat :: (not_(contains(x₀, x₁)) ==> (add(count(x₀, x₁), x₂) == x₂))
forall y₀: Bool :: (not_(not_(y₀)) <==> y₀)
forall x₀: nat, x₁: list :: (not_(contains(x₀, x₁)) ==> (remove(x₀, x₁) == x₁))
forall x₀: nat, x₁: list :: (not_(contains(x₀, x₁)) ==> (count(x₀, x₁) == zero))
forall x: nat :: (add(x, zero) == x)
  3  evaluation/lemmas/list/remove.th.log
evaluation/lemmas/list/reverse.conditional.bpl
  11  number of lemmas
  0  wrong
forall y₀: list :: (reverse(reverse(y₀)) == y₀)
forall y₀: list, x₁: list :: (append(reverse(y₀), x₁) == qreverse(y₀, x₁))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == qreverse(y₁, reverse(y₀)))
forall y₀: list, y₁: list :: (reverse(qreverse(y₀, y₁)) == qreverse(y₁, y₀))
forall y₀: list, y₁: list, x₁: list :: (nreverse(append(y₀, y₁), x₁) == append(x₁, qreverse(y₁, reverse(y₀))))
forall y₀: list, y₁: list, x₁: list :: (nreverse(qreverse(y₀, y₁), x₁) == append(x₁, qreverse(y₁, y₀)))
forall x₀: list, x₁: list :: (nreverse(x₀, x₁) == append(x₁, reverse(x₀)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(qreverse(y₀, y₁), x₁) == qreverse(y₀, append(y₁, x₁)))
forall x: list :: (append(x, nil) == x)
forall x: list, y₀: list :: ((y₀ == nil) ==> (append(y₀, reverse(x)) == reverse(x)))
  10  nontrivial
forall y₀: list :: (reverse(reverse(y₀)) == y₀)
forall y₀: list, x₁: list :: (append(reverse(y₀), x₁) == qreverse(y₀, x₁))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == qreverse(y₁, reverse(y₀)))
forall y₀: list, y₁: list :: (reverse(qreverse(y₀, y₁)) == qreverse(y₁, y₀))
forall y₀: list, y₁: list, x₁: list :: (nreverse(append(y₀, y₁), x₁) == append(x₁, qreverse(y₁, reverse(y₀))))
forall y₀: list, y₁: list, x₁: list :: (nreverse(qreverse(y₀, y₁), x₁) == append(x₁, qreverse(y₁, y₀)))
forall x₀: list, x₁: list :: (nreverse(x₀, x₁) == append(x₁, reverse(x₀)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(qreverse(y₀, y₁), x₁) == qreverse(y₀, append(y₁, x₁)))
forall x: list :: (append(x, nil) == x)
forall x: list, y₀: list :: ((y₀ == nil) ==> (append(y₀, reverse(x)) == reverse(x)))
  5  reduced greedily
forall y₀: list :: (reverse(reverse(y₀)) == y₀)
forall y₀: list, x₁: list :: (append(reverse(y₀), x₁) == qreverse(y₀, x₁))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == qreverse(y₁, reverse(y₀)))
forall y₀: list, y₁: list :: (reverse(qreverse(y₀, y₁)) == qreverse(y₁, y₀))
forall y₀: list, y₁: list, x₁: list :: (nreverse(append(y₀, y₁), x₁) == append(x₁, qreverse(y₁, reverse(y₀))))
forall y₀: list, y₁: list, x₁: list :: (nreverse(qreverse(y₀, y₁), x₁) == append(x₁, qreverse(y₁, y₀)))
forall x₀: list, x₁: list :: (nreverse(x₀, x₁) == append(x₁, reverse(x₀)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(qreverse(y₀, y₁), x₁) == qreverse(y₀, append(y₁, x₁)))
forall x: list :: (append(x, nil) == x)
forall x: list, y₀: list :: ((y₀ == nil) ==> (append(y₀, reverse(x)) == reverse(x)))
  0  independent
forall y₀: list :: (reverse(reverse(y₀)) == y₀)
forall y₀: list, x₁: list :: (append(reverse(y₀), x₁) == qreverse(y₀, x₁))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == qreverse(y₁, reverse(y₀)))
forall y₀: list, y₁: list :: (reverse(qreverse(y₀, y₁)) == qreverse(y₁, y₀))
forall y₀: list, y₁: list, x₁: list :: (nreverse(append(y₀, y₁), x₁) == append(x₁, qreverse(y₁, reverse(y₀))))
forall y₀: list, y₁: list, x₁: list :: (nreverse(qreverse(y₀, y₁), x₁) == append(x₁, qreverse(y₁, y₀)))
forall x₀: list, x₁: list :: (nreverse(x₀, x₁) == append(x₁, reverse(x₀)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(qreverse(y₀, y₁), x₁) == qreverse(y₀, append(y₁, x₁)))
forall x: list :: (append(x, nil) == x)
forall x: list, y₀: list :: ((y₀ == nil) ==> (append(y₀, reverse(x)) == reverse(x)))
  0  evaluation/lemmas/list/reverse.structural.bpl
forall y₀: list :: (reverse(reverse(y₀)) == y₀)
forall y₀: list, x₁: list :: (append(reverse(y₀), x₁) == qreverse(y₀, x₁))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == qreverse(y₁, reverse(y₀)))
forall y₀: list, y₁: list :: (reverse(qreverse(y₀, y₁)) == qreverse(y₁, y₀))
forall y₀: list, y₁: list, x₁: list :: (nreverse(append(y₀, y₁), x₁) == append(x₁, qreverse(y₁, reverse(y₀))))
forall y₀: list, y₁: list, x₁: list :: (nreverse(qreverse(y₀, y₁), x₁) == append(x₁, qreverse(y₁, y₀)))
forall x₀: list, x₁: list :: (nreverse(x₀, x₁) == append(x₁, reverse(x₀)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(qreverse(y₀, y₁), x₁) == qreverse(y₀, append(y₁, x₁)))
forall x: list :: (append(x, nil) == x)
forall x: list, y₀: list :: ((y₀ == nil) ==> (append(y₀, reverse(x)) == reverse(x)))
  0  evaluation/lemmas/list/reverse.enumerate.bpl
forall y₀: list :: (reverse(reverse(y₀)) == y₀)
forall y₀: list, x₁: list :: (append(reverse(y₀), x₁) == qreverse(y₀, x₁))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == qreverse(y₁, reverse(y₀)))
forall y₀: list, y₁: list :: (reverse(qreverse(y₀, y₁)) == qreverse(y₁, y₀))
forall y₀: list, y₁: list, x₁: list :: (nreverse(append(y₀, y₁), x₁) == append(x₁, qreverse(y₁, reverse(y₀))))
forall y₀: list, y₁: list, x₁: list :: (nreverse(qreverse(y₀, y₁), x₁) == append(x₁, qreverse(y₁, y₀)))
forall x₀: list, x₁: list :: (nreverse(x₀, x₁) == append(x₁, reverse(x₀)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(qreverse(y₀, y₁), x₁) == qreverse(y₀, append(y₁, x₁)))
forall x: list :: (append(x, nil) == x)
forall x: list, y₀: list :: ((y₀ == nil) ==> (append(y₀, reverse(x)) == reverse(x)))
  0  evaluation/lemmas/list/reverse.th.log
evaluation/lemmas/list/rotate.conditional.bpl
  8  number of lemmas
  0  wrong
forall y₀: list :: (reverse(reverse(y₀)) == y₀)
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == append(reverse(y₁), reverse(y₀)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall x: nat :: (add(x, zero) == x)
forall x: list :: (append(x, nil) == x)
forall x: list, z₀: nat :: (leq(length(x), z₀) ==> (reverse(x) == rotate(z₀, x)))
  8  nontrivial
forall y₀: list :: (reverse(reverse(y₀)) == y₀)
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == append(reverse(y₁), reverse(y₀)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall x: nat :: (add(x, zero) == x)
forall x: list :: (append(x, nil) == x)
forall x: list, z₀: nat :: (leq(length(x), z₀) ==> (reverse(x) == rotate(z₀, x)))
  7  reduced greedily
forall y₀: list :: (reverse(reverse(y₀)) == y₀)
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == append(reverse(y₁), reverse(y₀)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall x: nat :: (add(x, zero) == x)
forall x: list :: (append(x, nil) == x)
forall x: list, z₀: nat :: (leq(length(x), z₀) ==> (reverse(x) == rotate(z₀, x)))
  7  independent
forall y₀: list :: (reverse(reverse(y₀)) == y₀)
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == append(reverse(y₁), reverse(y₀)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall x: nat :: (add(x, zero) == x)
forall x: list :: (append(x, nil) == x)
forall x: list, z₀: nat :: (leq(length(x), z₀) ==> (reverse(x) == rotate(z₀, x)))
  1  evaluation/lemmas/list/rotate.structural.bpl
forall y₀: list :: (reverse(reverse(y₀)) == y₀)
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == append(reverse(y₁), reverse(y₀)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall x: nat :: (add(x, zero) == x)
forall x: list :: (append(x, nil) == x)
forall x: list, z₀: nat :: (leq(length(x), z₀) ==> (reverse(x) == rotate(z₀, x)))
  1  evaluation/lemmas/list/rotate.enumerate.bpl
forall y₀: list :: (reverse(reverse(y₀)) == y₀)
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == append(reverse(y₁), reverse(y₀)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall x: nat :: (add(x, zero) == x)
forall x: list :: (append(x, nil) == x)
forall x: list, z₀: nat :: (leq(length(x), z₀) ==> (reverse(x) == rotate(z₀, x)))
  3  evaluation/lemmas/list/rotate.th.log
evaluation/lemmas/list/runlength.conditional.bpl
  6  number of lemmas
  0  wrong
forall y₀: list, y₁: list :: (sum(append(y₀, y₁)) == add(sum(y₀), sum(y₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (mul(add(y₀, y₁), x₁) == add(mul(y₀, x₁), mul(y₁, x₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall x: nat :: (add(x, zero) == x)
forall x: list :: (append(x, nil) == x)
  6  nontrivial
forall y₀: list, y₁: list :: (sum(append(y₀, y₁)) == add(sum(y₀), sum(y₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (mul(add(y₀, y₁), x₁) == add(mul(y₀, x₁), mul(y₁, x₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall x: nat :: (add(x, zero) == x)
forall x: list :: (append(x, nil) == x)
  6  reduced greedily
forall y₀: list, y₁: list :: (sum(append(y₀, y₁)) == add(sum(y₀), sum(y₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (mul(add(y₀, y₁), x₁) == add(mul(y₀, x₁), mul(y₁, x₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall x: nat :: (add(x, zero) == x)
forall x: list :: (append(x, nil) == x)
  6  independent
forall y₀: list, y₁: list :: (sum(append(y₀, y₁)) == add(sum(y₀), sum(y₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (mul(add(y₀, y₁), x₁) == add(mul(y₀, x₁), mul(y₁, x₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall x: nat :: (add(x, zero) == x)
forall x: list :: (append(x, nil) == x)
  0  evaluation/lemmas/list/runlength.structural.bpl
forall y₀: list, y₁: list :: (sum(append(y₀, y₁)) == add(sum(y₀), sum(y₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (mul(add(y₀, y₁), x₁) == add(mul(y₀, x₁), mul(y₁, x₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall x: nat :: (add(x, zero) == x)
forall x: list :: (append(x, nil) == x)
  1  evaluation/lemmas/list/runlength.enumerate.bpl
forall y₀: list, y₁: list :: (sum(append(y₀, y₁)) == add(sum(y₀), sum(y₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (mul(add(y₀, y₁), x₁) == add(mul(y₀, x₁), mul(y₁, x₁)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall x: nat :: (add(x, zero) == x)
forall x: list :: (append(x, nil) == x)
  4  evaluation/lemmas/list/runlength.th.log
evaluation/lemmas/nat.conditional.bpl
  45  number of lemmas
  0  wrong
forall y₀: nat, y₁: nat, x₁: nat :: (mul(add(y₀, y₁), x₁) == add(mul(y₀, x₁), mul(y₁, x₁)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₁, x₂) ==> (sub(x₀, sub(x₁, x₂)) == x₀))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (sub(sub(x₀, x₁), x₂) == sub(zero, x₂)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (sub(x₀, max(x₁, x₂)) == zero))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (sub(x₀, add(x₁, x₂)) == zero))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (sub(x₀, min(x₁, x₂)) == zero))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₁, x₂) ==> (max(x₀, sub(x₁, x₂)) == x₀))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (max(sub(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: nat, x₂: nat :: (leq(min(x₀, x₁), x₂) ==> (max(min(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₁, x₂) ==> (leq(x₀, sub(x₁, x₂)) <==> leq(x₀, zero)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (leq(x₀, max(x₁, x₂)) <==> true))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, min(x₀, x₁)) ==> (leq(max(x₀, x₁), x₂) <==> false))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (leq(x₀, add(x₁, x₂)) <==> true))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, x₀) ==> (leq(add(x₀, x₁), x₂) <==> false))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (leq(x₀, min(x₁, x₂)) <==> true))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (mul(sub(x₀, x₁), x₂) == zero))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (add(sub(x₀, x₁), x₂) == x₂))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₁, x₂) ==> (min(x₀, sub(x₁, x₂)) == min(x₀, zero)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (min(sub(x₀, x₁), x₂) == zero))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (min(x₀, max(x₁, x₂)) == x₀))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, min(x₀, x₁)) ==> (min(max(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (min(x₀, add(x₁, x₂)) == x₀))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, x₀) ==> (min(add(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (min(x₀, min(x₁, x₂)) == x₀))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, min(x₀, x₁)) ==> (min(min(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (lt(sub(x₀, x₁), x₂) <==> lt(zero, x₂)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (lt(x₀, max(x₁, x₂)) <==> true))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, min(x₀, x₁)) ==> (lt(max(x₀, x₁), x₂) <==> false))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (lt(x₀, add(x₁, x₂)) <==> true))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, x₀) ==> (lt(add(x₀, x₁), x₂) <==> false))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, min(x₀, x₁)) ==> (lt(min(x₀, x₁), x₂) <==> false))
forall y₀: Bool :: (not_(not_(y₀)) <==> y₀)
forall y₀: nat, y₁: nat :: (not_(leq(y₀, y₁)) <==> lt(y₁, y₀))
forall y₀: nat, y₁: nat :: (not_(lt(y₀, y₁)) <==> leq(y₁, y₀))
forall x₀: nat, y₀: nat, y₁: nat :: (max(x₀, min(y₀, y₁)) == max(min(y₀, y₁), x₀))
forall y₀: nat, y₁: nat, x₁: nat :: (leq(sub(y₀, y₁), x₁) <==> leq(y₀, add(y₁, x₁)))
forall x₀: nat, y₀: nat, y₁: nat :: (lt(x₀, sub(y₀, y₁)) <==> lt(add(y₁, x₀), y₀))
forall x₀: nat, x₁: nat :: (lt(x₀, x₁) ==> (sub(x₀, x₁) == zero))
forall x₀: nat, x₁: nat :: (leq(x₀, x₁) ==> (max(x₀, x₁) == x₁))
forall x₀: nat, x₁: nat :: (lt(x₁, x₀) ==> (max(x₀, x₁) == x₀))
forall x₀: nat, x₁: nat :: (lt(x₁, x₀) ==> (min(x₀, x₁) == x₁))
forall x₀: nat, x₁: nat :: (leq(x₀, x₁) ==> (min(x₀, x₁) == x₀))
forall x: nat :: (max(x, zero) == x)
forall x: nat :: (add(x, zero) == x)
  43  nontrivial
forall y₀: nat, y₁: nat, x₁: nat :: (mul(add(y₀, y₁), x₁) == add(mul(y₀, x₁), mul(y₁, x₁)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₁, x₂) ==> (sub(x₀, sub(x₁, x₂)) == x₀))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (sub(sub(x₀, x₁), x₂) == sub(zero, x₂)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (sub(x₀, max(x₁, x₂)) == zero))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (sub(x₀, add(x₁, x₂)) == zero))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (sub(x₀, min(x₁, x₂)) == zero))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₁, x₂) ==> (max(x₀, sub(x₁, x₂)) == x₀))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (max(sub(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: nat, x₂: nat :: (leq(min(x₀, x₁), x₂) ==> (max(min(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₁, x₂) ==> (leq(x₀, sub(x₁, x₂)) <==> leq(x₀, zero)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (leq(x₀, max(x₁, x₂)) <==> true))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, min(x₀, x₁)) ==> (leq(max(x₀, x₁), x₂) <==> false))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (leq(x₀, add(x₁, x₂)) <==> true))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, x₀) ==> (leq(add(x₀, x₁), x₂) <==> false))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (leq(x₀, min(x₁, x₂)) <==> true))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (mul(sub(x₀, x₁), x₂) == zero))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (add(sub(x₀, x₁), x₂) == x₂))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₁, x₂) ==> (min(x₀, sub(x₁, x₂)) == min(x₀, zero)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (min(sub(x₀, x₁), x₂) == zero))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (min(x₀, max(x₁, x₂)) == x₀))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, min(x₀, x₁)) ==> (min(max(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (min(x₀, add(x₁, x₂)) == x₀))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, x₀) ==> (min(add(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (min(x₀, min(x₁, x₂)) == x₀))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, min(x₀, x₁)) ==> (min(min(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (lt(sub(x₀, x₁), x₂) <==> lt(zero, x₂)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (lt(x₀, max(x₁, x₂)) <==> true))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, min(x₀, x₁)) ==> (lt(max(x₀, x₁), x₂) <==> false))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (lt(x₀, add(x₁, x₂)) <==> true))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, x₀) ==> (lt(add(x₀, x₁), x₂) <==> false))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, min(x₀, x₁)) ==> (lt(min(x₀, x₁), x₂) <==> false))
forall y₀: Bool :: (not_(not_(y₀)) <==> y₀)
forall y₀: nat, y₁: nat :: (not_(leq(y₀, y₁)) <==> lt(y₁, y₀))
forall y₀: nat, y₁: nat :: (not_(lt(y₀, y₁)) <==> leq(y₁, y₀))
forall x₀: nat, y₀: nat, y₁: nat :: (max(x₀, min(y₀, y₁)) == max(min(y₀, y₁), x₀))
forall y₀: nat, y₁: nat, x₁: nat :: (leq(sub(y₀, y₁), x₁) <==> leq(y₀, add(y₁, x₁)))
forall x₀: nat, y₀: nat, y₁: nat :: (lt(x₀, sub(y₀, y₁)) <==> lt(add(y₁, x₀), y₀))
forall x₀: nat, x₁: nat :: (lt(x₀, x₁) ==> (sub(x₀, x₁) == zero))
forall x₀: nat, x₁: nat :: (leq(x₀, x₁) ==> (max(x₀, x₁) == x₁))
forall x₀: nat, x₁: nat :: (lt(x₁, x₀) ==> (max(x₀, x₁) == x₀))
forall x₀: nat, x₁: nat :: (lt(x₁, x₀) ==> (min(x₀, x₁) == x₁))
forall x₀: nat, x₁: nat :: (leq(x₀, x₁) ==> (min(x₀, x₁) == x₀))
forall x: nat :: (max(x, zero) == x)
forall x: nat :: (add(x, zero) == x)
  35  reduced greedily
forall y₀: nat, y₁: nat, x₁: nat :: (mul(add(y₀, y₁), x₁) == add(mul(y₀, x₁), mul(y₁, x₁)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₁, x₂) ==> (sub(x₀, sub(x₁, x₂)) == x₀))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (sub(sub(x₀, x₁), x₂) == sub(zero, x₂)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (sub(x₀, max(x₁, x₂)) == zero))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (sub(x₀, add(x₁, x₂)) == zero))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (sub(x₀, min(x₁, x₂)) == zero))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₁, x₂) ==> (max(x₀, sub(x₁, x₂)) == x₀))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (max(sub(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: nat, x₂: nat :: (leq(min(x₀, x₁), x₂) ==> (max(min(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₁, x₂) ==> (leq(x₀, sub(x₁, x₂)) <==> leq(x₀, zero)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (leq(x₀, max(x₁, x₂)) <==> true))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, min(x₀, x₁)) ==> (leq(max(x₀, x₁), x₂) <==> false))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (leq(x₀, add(x₁, x₂)) <==> true))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, x₀) ==> (leq(add(x₀, x₁), x₂) <==> false))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (leq(x₀, min(x₁, x₂)) <==> true))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (mul(sub(x₀, x₁), x₂) == zero))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (add(sub(x₀, x₁), x₂) == x₂))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₁, x₂) ==> (min(x₀, sub(x₁, x₂)) == min(x₀, zero)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (min(sub(x₀, x₁), x₂) == zero))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (min(x₀, max(x₁, x₂)) == x₀))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, min(x₀, x₁)) ==> (min(max(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (min(x₀, add(x₁, x₂)) == x₀))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, x₀) ==> (min(add(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (min(x₀, min(x₁, x₂)) == x₀))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, min(x₀, x₁)) ==> (min(min(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (lt(sub(x₀, x₁), x₂) <==> lt(zero, x₂)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (lt(x₀, max(x₁, x₂)) <==> true))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, min(x₀, x₁)) ==> (lt(max(x₀, x₁), x₂) <==> false))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (lt(x₀, add(x₁, x₂)) <==> true))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, x₀) ==> (lt(add(x₀, x₁), x₂) <==> false))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, min(x₀, x₁)) ==> (lt(min(x₀, x₁), x₂) <==> false))
forall y₀: Bool :: (not_(not_(y₀)) <==> y₀)
forall y₀: nat, y₁: nat :: (not_(leq(y₀, y₁)) <==> lt(y₁, y₀))
forall y₀: nat, y₁: nat :: (not_(lt(y₀, y₁)) <==> leq(y₁, y₀))
forall x₀: nat, y₀: nat, y₁: nat :: (max(x₀, min(y₀, y₁)) == max(min(y₀, y₁), x₀))
forall y₀: nat, y₁: nat, x₁: nat :: (leq(sub(y₀, y₁), x₁) <==> leq(y₀, add(y₁, x₁)))
forall x₀: nat, y₀: nat, y₁: nat :: (lt(x₀, sub(y₀, y₁)) <==> lt(add(y₁, x₀), y₀))
forall x₀: nat, x₁: nat :: (lt(x₀, x₁) ==> (sub(x₀, x₁) == zero))
forall x₀: nat, x₁: nat :: (leq(x₀, x₁) ==> (max(x₀, x₁) == x₁))
forall x₀: nat, x₁: nat :: (lt(x₁, x₀) ==> (max(x₀, x₁) == x₀))
forall x₀: nat, x₁: nat :: (lt(x₁, x₀) ==> (min(x₀, x₁) == x₁))
forall x₀: nat, x₁: nat :: (leq(x₀, x₁) ==> (min(x₀, x₁) == x₀))
forall x: nat :: (max(x, zero) == x)
forall x: nat :: (add(x, zero) == x)
  11  independent
forall y₀: nat, y₁: nat, x₁: nat :: (mul(add(y₀, y₁), x₁) == add(mul(y₀, x₁), mul(y₁, x₁)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₁, x₂) ==> (sub(x₀, sub(x₁, x₂)) == x₀))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (sub(sub(x₀, x₁), x₂) == sub(zero, x₂)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (sub(x₀, max(x₁, x₂)) == zero))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (sub(x₀, add(x₁, x₂)) == zero))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (sub(x₀, min(x₁, x₂)) == zero))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₁, x₂) ==> (max(x₀, sub(x₁, x₂)) == x₀))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (max(sub(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: nat, x₂: nat :: (leq(min(x₀, x₁), x₂) ==> (max(min(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₁, x₂) ==> (leq(x₀, sub(x₁, x₂)) <==> leq(x₀, zero)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (leq(x₀, max(x₁, x₂)) <==> true))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, min(x₀, x₁)) ==> (leq(max(x₀, x₁), x₂) <==> false))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (leq(x₀, add(x₁, x₂)) <==> true))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, x₀) ==> (leq(add(x₀, x₁), x₂) <==> false))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (leq(x₀, min(x₁, x₂)) <==> true))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (mul(sub(x₀, x₁), x₂) == zero))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (add(sub(x₀, x₁), x₂) == x₂))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₁, x₂) ==> (min(x₀, sub(x₁, x₂)) == min(x₀, zero)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (min(sub(x₀, x₁), x₂) == zero))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (min(x₀, max(x₁, x₂)) == x₀))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, min(x₀, x₁)) ==> (min(max(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (min(x₀, add(x₁, x₂)) == x₀))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, x₀) ==> (min(add(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (min(x₀, min(x₁, x₂)) == x₀))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, min(x₀, x₁)) ==> (min(min(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (lt(sub(x₀, x₁), x₂) <==> lt(zero, x₂)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (lt(x₀, max(x₁, x₂)) <==> true))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, min(x₀, x₁)) ==> (lt(max(x₀, x₁), x₂) <==> false))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (lt(x₀, add(x₁, x₂)) <==> true))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, x₀) ==> (lt(add(x₀, x₁), x₂) <==> false))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, min(x₀, x₁)) ==> (lt(min(x₀, x₁), x₂) <==> false))
forall y₀: Bool :: (not_(not_(y₀)) <==> y₀)
forall y₀: nat, y₁: nat :: (not_(leq(y₀, y₁)) <==> lt(y₁, y₀))
forall y₀: nat, y₁: nat :: (not_(lt(y₀, y₁)) <==> leq(y₁, y₀))
forall x₀: nat, y₀: nat, y₁: nat :: (max(x₀, min(y₀, y₁)) == max(min(y₀, y₁), x₀))
forall y₀: nat, y₁: nat, x₁: nat :: (leq(sub(y₀, y₁), x₁) <==> leq(y₀, add(y₁, x₁)))
forall x₀: nat, y₀: nat, y₁: nat :: (lt(x₀, sub(y₀, y₁)) <==> lt(add(y₁, x₀), y₀))
forall x₀: nat, x₁: nat :: (lt(x₀, x₁) ==> (sub(x₀, x₁) == zero))
forall x₀: nat, x₁: nat :: (leq(x₀, x₁) ==> (max(x₀, x₁) == x₁))
forall x₀: nat, x₁: nat :: (lt(x₁, x₀) ==> (max(x₀, x₁) == x₀))
forall x₀: nat, x₁: nat :: (lt(x₁, x₀) ==> (min(x₀, x₁) == x₁))
forall x₀: nat, x₁: nat :: (leq(x₀, x₁) ==> (min(x₀, x₁) == x₀))
forall x: nat :: (max(x, zero) == x)
forall x: nat :: (add(x, zero) == x)
  35  evaluation/lemmas/nat.structural.bpl
forall y₀: nat, y₁: nat, x₁: nat :: (mul(add(y₀, y₁), x₁) == add(mul(y₀, x₁), mul(y₁, x₁)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₁, x₂) ==> (sub(x₀, sub(x₁, x₂)) == x₀))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (sub(sub(x₀, x₁), x₂) == sub(zero, x₂)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (sub(x₀, max(x₁, x₂)) == zero))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (sub(x₀, add(x₁, x₂)) == zero))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (sub(x₀, min(x₁, x₂)) == zero))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₁, x₂) ==> (max(x₀, sub(x₁, x₂)) == x₀))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (max(sub(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: nat, x₂: nat :: (leq(min(x₀, x₁), x₂) ==> (max(min(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₁, x₂) ==> (leq(x₀, sub(x₁, x₂)) <==> leq(x₀, zero)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (leq(x₀, max(x₁, x₂)) <==> true))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, min(x₀, x₁)) ==> (leq(max(x₀, x₁), x₂) <==> false))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (leq(x₀, add(x₁, x₂)) <==> true))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, x₀) ==> (leq(add(x₀, x₁), x₂) <==> false))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (leq(x₀, min(x₁, x₂)) <==> true))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (mul(sub(x₀, x₁), x₂) == zero))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (add(sub(x₀, x₁), x₂) == x₂))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₁, x₂) ==> (min(x₀, sub(x₁, x₂)) == min(x₀, zero)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (min(sub(x₀, x₁), x₂) == zero))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (min(x₀, max(x₁, x₂)) == x₀))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, min(x₀, x₁)) ==> (min(max(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (min(x₀, add(x₁, x₂)) == x₀))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, x₀) ==> (min(add(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (min(x₀, min(x₁, x₂)) == x₀))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, min(x₀, x₁)) ==> (min(min(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (lt(sub(x₀, x₁), x₂) <==> lt(zero, x₂)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (lt(x₀, max(x₁, x₂)) <==> true))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, min(x₀, x₁)) ==> (lt(max(x₀, x₁), x₂) <==> false))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (lt(x₀, add(x₁, x₂)) <==> true))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, x₀) ==> (lt(add(x₀, x₁), x₂) <==> false))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, min(x₀, x₁)) ==> (lt(min(x₀, x₁), x₂) <==> false))
forall y₀: Bool :: (not_(not_(y₀)) <==> y₀)
forall y₀: nat, y₁: nat :: (not_(leq(y₀, y₁)) <==> lt(y₁, y₀))
forall y₀: nat, y₁: nat :: (not_(lt(y₀, y₁)) <==> leq(y₁, y₀))
forall x₀: nat, y₀: nat, y₁: nat :: (max(x₀, min(y₀, y₁)) == max(min(y₀, y₁), x₀))
forall y₀: nat, y₁: nat, x₁: nat :: (leq(sub(y₀, y₁), x₁) <==> leq(y₀, add(y₁, x₁)))
forall x₀: nat, y₀: nat, y₁: nat :: (lt(x₀, sub(y₀, y₁)) <==> lt(add(y₁, x₀), y₀))
forall x₀: nat, x₁: nat :: (lt(x₀, x₁) ==> (sub(x₀, x₁) == zero))
forall x₀: nat, x₁: nat :: (leq(x₀, x₁) ==> (max(x₀, x₁) == x₁))
forall x₀: nat, x₁: nat :: (lt(x₁, x₀) ==> (max(x₀, x₁) == x₀))
forall x₀: nat, x₁: nat :: (lt(x₁, x₀) ==> (min(x₀, x₁) == x₁))
forall x₀: nat, x₁: nat :: (leq(x₀, x₁) ==> (min(x₀, x₁) == x₀))
forall x: nat :: (max(x, zero) == x)
forall x: nat :: (add(x, zero) == x)
  41  evaluation/lemmas/nat.enumerate.bpl
forall y₀: nat, y₁: nat, x₁: nat :: (mul(add(y₀, y₁), x₁) == add(mul(y₀, x₁), mul(y₁, x₁)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₁, x₂) ==> (sub(x₀, sub(x₁, x₂)) == x₀))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (sub(sub(x₀, x₁), x₂) == sub(zero, x₂)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (sub(x₀, max(x₁, x₂)) == zero))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (sub(x₀, add(x₁, x₂)) == zero))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (sub(x₀, min(x₁, x₂)) == zero))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₁, x₂) ==> (max(x₀, sub(x₁, x₂)) == x₀))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (max(sub(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: nat, x₂: nat :: (leq(min(x₀, x₁), x₂) ==> (max(min(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₁, x₂) ==> (leq(x₀, sub(x₁, x₂)) <==> leq(x₀, zero)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (leq(x₀, max(x₁, x₂)) <==> true))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, min(x₀, x₁)) ==> (leq(max(x₀, x₁), x₂) <==> false))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (leq(x₀, add(x₁, x₂)) <==> true))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, x₀) ==> (leq(add(x₀, x₁), x₂) <==> false))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (leq(x₀, min(x₁, x₂)) <==> true))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (mul(sub(x₀, x₁), x₂) == zero))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (add(sub(x₀, x₁), x₂) == x₂))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₁, x₂) ==> (min(x₀, sub(x₁, x₂)) == min(x₀, zero)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (min(sub(x₀, x₁), x₂) == zero))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (min(x₀, max(x₁, x₂)) == x₀))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, min(x₀, x₁)) ==> (min(max(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (min(x₀, add(x₁, x₂)) == x₀))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, x₀) ==> (min(add(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (min(x₀, min(x₁, x₂)) == x₀))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, min(x₀, x₁)) ==> (min(min(x₀, x₁), x₂) == x₂))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (lt(sub(x₀, x₁), x₂) <==> lt(zero, x₂)))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, min(x₁, x₂)) ==> (lt(x₀, max(x₁, x₂)) <==> true))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, min(x₀, x₁)) ==> (lt(max(x₀, x₁), x₂) <==> false))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₀, x₁) ==> (lt(x₀, add(x₁, x₂)) <==> true))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, x₀) ==> (lt(add(x₀, x₁), x₂) <==> false))
forall x₀: nat, x₁: nat, x₂: nat :: (lt(x₂, min(x₀, x₁)) ==> (lt(min(x₀, x₁), x₂) <==> false))
forall y₀: Bool :: (not_(not_(y₀)) <==> y₀)
forall y₀: nat, y₁: nat :: (not_(leq(y₀, y₁)) <==> lt(y₁, y₀))
forall y₀: nat, y₁: nat :: (not_(lt(y₀, y₁)) <==> leq(y₁, y₀))
forall x₀: nat, y₀: nat, y₁: nat :: (max(x₀, min(y₀, y₁)) == max(min(y₀, y₁), x₀))
forall y₀: nat, y₁: nat, x₁: nat :: (leq(sub(y₀, y₁), x₁) <==> leq(y₀, add(y₁, x₁)))
forall x₀: nat, y₀: nat, y₁: nat :: (lt(x₀, sub(y₀, y₁)) <==> lt(add(y₁, x₀), y₀))
forall x₀: nat, x₁: nat :: (lt(x₀, x₁) ==> (sub(x₀, x₁) == zero))
forall x₀: nat, x₁: nat :: (leq(x₀, x₁) ==> (max(x₀, x₁) == x₁))
forall x₀: nat, x₁: nat :: (lt(x₁, x₀) ==> (max(x₀, x₁) == x₀))
forall x₀: nat, x₁: nat :: (lt(x₁, x₀) ==> (min(x₀, x₁) == x₁))
forall x₀: nat, x₁: nat :: (leq(x₀, x₁) ==> (min(x₀, x₁) == x₀))
forall x: nat :: (max(x, zero) == x)
forall x: nat :: (add(x, zero) == x)
  41  evaluation/lemmas/nat.th.log
evaluation/lemmas/list.conditional.bpl
  52  number of lemmas
  0  wrong
forall y₀: list :: (reverse(reverse(y₀)) == y₀)
forall x₀: [nat]nat, y₀: list :: (map(x₀, reverse(y₀)) == reverse(map(x₀, y₀)))
forall x₀: [nat]nat, y₀: nat, y₁: list :: (map(x₀, rotate(y₀, y₁)) == rotate(y₀, map(x₀, y₁)))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == append(reverse(y₁), reverse(y₀)))
forall x₀: nat, y₀: list, y₁: list :: (count(x₀, append(y₀, y₁)) == add(count(x₀, y₀), count(x₀, y₁)))
forall x₀: nat, x₁: list, x₂: list :: (not_(contains(x₀, x₁)) ==> (count(x₀, append(x₁, x₂)) == count(x₀, x₂)))
forall x₀: nat, y₀: list, y₁: nat :: (count(x₀, snoc(y₀, y₁)) == add(count(x₀, y₀), count(x₀, cons(y₁, nil))))
forall x₀: nat, x₁: list, x₂: nat :: (not_(contains(x₀, x₁)) ==> (count(x₀, snoc(x₁, x₂)) == count(x₀, cons(x₂, nil))))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: nat, x₁: list :: (append(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, x₁)))
forall x₀: [nat]Bool, x₁: list, x₂: list :: (not_(ex(x₀, x₁)) ==> (append(filter(x₀, x₁), x₂) == x₂))
forall y₀: list, y₁: nat :: (reverse(snoc(y₀, y₁)) == cons(y₁, reverse(y₀)))
forall x₀: [nat]Bool, x₁: list :: (not_(ex(x₀, x₁)) ==> (reverse(filter(x₀, x₁)) == nil))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall x₀: [nat]nat, y₀: list, y₁: nat :: (map(x₀, snoc(y₀, y₁)) == append(map(x₀, y₀), cons(x₀[y₁], nil)))
forall x₀: [nat]nat, x₁: [nat]Bool, x₂: list :: (not_(ex(x₁, x₂)) ==> (map(x₀, filter(x₁, x₂)) == nil))
forall x₀: nat, y₀: list, y₁: list :: (remove(x₀, append(y₀, y₁)) == append(remove(x₀, y₀), remove(x₀, y₁)))
forall x₀: nat, y₀: list, y₁: nat :: (remove(x₀, snoc(y₀, y₁)) == append(remove(x₀, y₀), remove(x₀, cons(y₁, nil))))
forall y₀: nat, y₁: list, x₁: nat :: (snoc(take(y₀, y₁), x₁) == append(take(y₀, y₁), cons(x₁, nil)))
forall y₀: list, y₁: list, x₁: nat :: (snoc(append(y₀, y₁), x₁) == append(y₀, append(y₁, cons(x₁, nil))))
forall y₀: [nat]nat, y₁: list, x₁: nat :: (snoc(map(y₀, y₁), x₁) == append(map(y₀, y₁), cons(x₁, nil)))
forall y₀: nat, y₁: list, x₁: nat :: (snoc(remove(y₀, y₁), x₁) == append(remove(y₀, y₁), cons(x₁, nil)))
forall y₀: list, y₁: nat, x₁: nat :: (snoc(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, cons(x₁, nil))))
forall y₀: [nat]Bool, y₁: list, x₁: nat :: (snoc(filter(y₀, y₁), x₁) == append(filter(y₀, y₁), cons(x₁, nil)))
forall x₀: [nat]Bool, x₁: list, x₂: nat :: (not_(ex(x₀, x₁)) ==> (snoc(filter(x₀, x₁), x₂) == cons(x₂, nil)))
forall x₀: nat, x₁: list, x₂: nat :: (not_(contains(x₀, x₁)) ==> (add(count(x₀, x₁), x₂) == x₂))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x₀: [nat]Bool, x₁: list, x₂: nat :: (not_(ex(x₀, x₁)) ==> (add(countif(x₀, x₁), x₂) == x₂))
forall x₀: [nat]Bool, y₀: list, y₁: list :: (filter(x₀, append(y₀, y₁)) == append(filter(x₀, y₀), filter(x₀, y₁)))
forall x₀: [nat]Bool, x₁: list, x₂: list :: (not_(ex(x₀, x₁)) ==> (filter(x₀, append(x₁, x₂)) == filter(x₀, x₂)))
forall x₀: [nat]Bool, y₀: list, y₁: nat :: (filter(x₀, snoc(y₀, y₁)) == append(filter(x₀, y₀), filter(x₀, cons(y₁, nil))))
forall x₀: [nat]Bool, x₁: list, x₂: nat :: (not_(ex(x₀, x₁)) ==> (filter(x₀, snoc(x₁, x₂)) == filter(x₀, cons(x₂, nil))))
forall x₀: [nat]Bool, y₀: list, y₁: list :: (countif(x₀, append(y₀, y₁)) == add(countif(x₀, y₀), countif(x₀, y₁)))
forall x₀: [nat]Bool, x₁: list, x₂: list :: (not_(ex(x₀, x₁)) ==> (countif(x₀, append(x₁, x₂)) == countif(x₀, x₂)))
forall x₀: [nat]Bool, y₀: list, y₁: nat :: (countif(x₀, snoc(y₀, y₁)) == add(countif(x₀, y₀), countif(x₀, cons(y₁, nil))))
forall x₀: [nat]Bool, x₁: list, x₂: nat :: (not_(ex(x₀, x₁)) ==> (countif(x₀, snoc(x₁, x₂)) == countif(x₀, cons(x₂, nil))))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (take(x₀, map(y₀, y₁)) == map(y₀, take(x₀, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall y₀: [nat]Bool, y₁: list :: (length(filter(y₀, y₁)) == countif(y₀, y₁))
forall y₀: Bool :: (not_(not_(y₀)) <==> y₀)
forall x₀: nat, y₀: [nat]nat, y₁: list :: (drop(x₀, map(y₀, y₁)) == map(y₀, drop(x₀, y₁)))
forall x₀: nat, x₁: list :: (not_(contains(x₀, x₁)) ==> (count(x₀, x₁) == zero))
forall x₀: nat, x₁: list :: (not_(contains(x₀, x₁)) ==> (remove(x₀, x₁) == x₁))
forall x₀: list, x₁: nat :: (snoc(x₀, x₁) == append(x₀, cons(x₁, nil)))
forall x₀: [nat]Bool, x₁: list :: (not_(ex(x₀, x₁)) ==> (filter(x₀, x₁) == nil))
forall x₀: [nat]Bool, x₁: list :: (all(x₀, x₁) ==> (filter(x₀, x₁) == x₁))
forall x₀: [nat]Bool, x₁: list :: (not_(ex(x₀, x₁)) ==> (countif(x₀, x₁) == zero))
forall x: list :: (append(x, nil) == x)
forall x: nat :: (add(x, zero) == x)
forall x: list, y₀: list, z₀: nat :: ((y₀ == cons(z₀, nil)) ==> (append(x, y₀) == append(x, cons(z₀, nil))))
forall x: list, y₀: [nat]Bool :: (all(y₀, x) ==> (countif(y₀, x) == length(x)))
  50  nontrivial
forall y₀: list :: (reverse(reverse(y₀)) == y₀)
forall x₀: [nat]nat, y₀: list :: (map(x₀, reverse(y₀)) == reverse(map(x₀, y₀)))
forall x₀: [nat]nat, y₀: nat, y₁: list :: (map(x₀, rotate(y₀, y₁)) == rotate(y₀, map(x₀, y₁)))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == append(reverse(y₁), reverse(y₀)))
forall x₀: nat, y₀: list, y₁: list :: (count(x₀, append(y₀, y₁)) == add(count(x₀, y₀), count(x₀, y₁)))
forall x₀: nat, x₁: list, x₂: list :: (not_(contains(x₀, x₁)) ==> (count(x₀, append(x₁, x₂)) == count(x₀, x₂)))
forall x₀: nat, y₀: list, y₁: nat :: (count(x₀, snoc(y₀, y₁)) == add(count(x₀, y₀), count(x₀, cons(y₁, nil))))
forall x₀: nat, x₁: list, x₂: nat :: (not_(contains(x₀, x₁)) ==> (count(x₀, snoc(x₁, x₂)) == count(x₀, cons(x₂, nil))))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: nat, x₁: list :: (append(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, x₁)))
forall x₀: [nat]Bool, x₁: list, x₂: list :: (not_(ex(x₀, x₁)) ==> (append(filter(x₀, x₁), x₂) == x₂))
forall y₀: list, y₁: nat :: (reverse(snoc(y₀, y₁)) == cons(y₁, reverse(y₀)))
forall x₀: [nat]Bool, x₁: list :: (not_(ex(x₀, x₁)) ==> (reverse(filter(x₀, x₁)) == nil))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall x₀: [nat]nat, y₀: list, y₁: nat :: (map(x₀, snoc(y₀, y₁)) == append(map(x₀, y₀), cons(x₀[y₁], nil)))
forall x₀: [nat]nat, x₁: [nat]Bool, x₂: list :: (not_(ex(x₁, x₂)) ==> (map(x₀, filter(x₁, x₂)) == nil))
forall x₀: nat, y₀: list, y₁: list :: (remove(x₀, append(y₀, y₁)) == append(remove(x₀, y₀), remove(x₀, y₁)))
forall x₀: nat, y₀: list, y₁: nat :: (remove(x₀, snoc(y₀, y₁)) == append(remove(x₀, y₀), remove(x₀, cons(y₁, nil))))
forall y₀: nat, y₁: list, x₁: nat :: (snoc(take(y₀, y₁), x₁) == append(take(y₀, y₁), cons(x₁, nil)))
forall y₀: list, y₁: list, x₁: nat :: (snoc(append(y₀, y₁), x₁) == append(y₀, append(y₁, cons(x₁, nil))))
forall y₀: [nat]nat, y₁: list, x₁: nat :: (snoc(map(y₀, y₁), x₁) == append(map(y₀, y₁), cons(x₁, nil)))
forall y₀: nat, y₁: list, x₁: nat :: (snoc(remove(y₀, y₁), x₁) == append(remove(y₀, y₁), cons(x₁, nil)))
forall y₀: list, y₁: nat, x₁: nat :: (snoc(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, cons(x₁, nil))))
forall y₀: [nat]Bool, y₁: list, x₁: nat :: (snoc(filter(y₀, y₁), x₁) == append(filter(y₀, y₁), cons(x₁, nil)))
forall x₀: [nat]Bool, x₁: list, x₂: nat :: (not_(ex(x₀, x₁)) ==> (snoc(filter(x₀, x₁), x₂) == cons(x₂, nil)))
forall x₀: nat, x₁: list, x₂: nat :: (not_(contains(x₀, x₁)) ==> (add(count(x₀, x₁), x₂) == x₂))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x₀: [nat]Bool, x₁: list, x₂: nat :: (not_(ex(x₀, x₁)) ==> (add(countif(x₀, x₁), x₂) == x₂))
forall x₀: [nat]Bool, y₀: list, y₁: list :: (filter(x₀, append(y₀, y₁)) == append(filter(x₀, y₀), filter(x₀, y₁)))
forall x₀: [nat]Bool, x₁: list, x₂: list :: (not_(ex(x₀, x₁)) ==> (filter(x₀, append(x₁, x₂)) == filter(x₀, x₂)))
forall x₀: [nat]Bool, y₀: list, y₁: nat :: (filter(x₀, snoc(y₀, y₁)) == append(filter(x₀, y₀), filter(x₀, cons(y₁, nil))))
forall x₀: [nat]Bool, x₁: list, x₂: nat :: (not_(ex(x₀, x₁)) ==> (filter(x₀, snoc(x₁, x₂)) == filter(x₀, cons(x₂, nil))))
forall x₀: [nat]Bool, y₀: list, y₁: list :: (countif(x₀, append(y₀, y₁)) == add(countif(x₀, y₀), countif(x₀, y₁)))
forall x₀: [nat]Bool, x₁: list, x₂: list :: (not_(ex(x₀, x₁)) ==> (countif(x₀, append(x₁, x₂)) == countif(x₀, x₂)))
forall x₀: [nat]Bool, y₀: list, y₁: nat :: (countif(x₀, snoc(y₀, y₁)) == add(countif(x₀, y₀), countif(x₀, cons(y₁, nil))))
forall x₀: [nat]Bool, x₁: list, x₂: nat :: (not_(ex(x₀, x₁)) ==> (countif(x₀, snoc(x₁, x₂)) == countif(x₀, cons(x₂, nil))))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (take(x₀, map(y₀, y₁)) == map(y₀, take(x₀, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall y₀: [nat]Bool, y₁: list :: (length(filter(y₀, y₁)) == countif(y₀, y₁))
forall y₀: Bool :: (not_(not_(y₀)) <==> y₀)
forall x₀: nat, y₀: [nat]nat, y₁: list :: (drop(x₀, map(y₀, y₁)) == map(y₀, drop(x₀, y₁)))
forall x₀: nat, x₁: list :: (not_(contains(x₀, x₁)) ==> (count(x₀, x₁) == zero))
forall x₀: nat, x₁: list :: (not_(contains(x₀, x₁)) ==> (remove(x₀, x₁) == x₁))
forall x₀: list, x₁: nat :: (snoc(x₀, x₁) == append(x₀, cons(x₁, nil)))
forall x₀: [nat]Bool, x₁: list :: (not_(ex(x₀, x₁)) ==> (filter(x₀, x₁) == nil))
forall x₀: [nat]Bool, x₁: list :: (all(x₀, x₁) ==> (filter(x₀, x₁) == x₁))
forall x₀: [nat]Bool, x₁: list :: (not_(ex(x₀, x₁)) ==> (countif(x₀, x₁) == zero))
forall x: list :: (append(x, nil) == x)
forall x: nat :: (add(x, zero) == x)
forall x: list, y₀: list, z₀: nat :: ((y₀ == cons(z₀, nil)) ==> (append(x, y₀) == append(x, cons(z₀, nil))))
forall x: list, y₀: [nat]Bool :: (all(y₀, x) ==> (countif(y₀, x) == length(x)))
  30  reduced greedily
forall y₀: list :: (reverse(reverse(y₀)) == y₀)
forall x₀: [nat]nat, y₀: list :: (map(x₀, reverse(y₀)) == reverse(map(x₀, y₀)))
forall x₀: [nat]nat, y₀: nat, y₁: list :: (map(x₀, rotate(y₀, y₁)) == rotate(y₀, map(x₀, y₁)))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == append(reverse(y₁), reverse(y₀)))
forall x₀: nat, y₀: list, y₁: list :: (count(x₀, append(y₀, y₁)) == add(count(x₀, y₀), count(x₀, y₁)))
forall x₀: nat, x₁: list, x₂: list :: (not_(contains(x₀, x₁)) ==> (count(x₀, append(x₁, x₂)) == count(x₀, x₂)))
forall x₀: nat, y₀: list, y₁: nat :: (count(x₀, snoc(y₀, y₁)) == add(count(x₀, y₀), count(x₀, cons(y₁, nil))))
forall x₀: nat, x₁: list, x₂: nat :: (not_(contains(x₀, x₁)) ==> (count(x₀, snoc(x₁, x₂)) == count(x₀, cons(x₂, nil))))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: nat, x₁: list :: (append(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, x₁)))
forall x₀: [nat]Bool, x₁: list, x₂: list :: (not_(ex(x₀, x₁)) ==> (append(filter(x₀, x₁), x₂) == x₂))
forall y₀: list, y₁: nat :: (reverse(snoc(y₀, y₁)) == cons(y₁, reverse(y₀)))
forall x₀: [nat]Bool, x₁: list :: (not_(ex(x₀, x₁)) ==> (reverse(filter(x₀, x₁)) == nil))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall x₀: [nat]nat, y₀: list, y₁: nat :: (map(x₀, snoc(y₀, y₁)) == append(map(x₀, y₀), cons(x₀[y₁], nil)))
forall x₀: [nat]nat, x₁: [nat]Bool, x₂: list :: (not_(ex(x₁, x₂)) ==> (map(x₀, filter(x₁, x₂)) == nil))
forall x₀: nat, y₀: list, y₁: list :: (remove(x₀, append(y₀, y₁)) == append(remove(x₀, y₀), remove(x₀, y₁)))
forall x₀: nat, y₀: list, y₁: nat :: (remove(x₀, snoc(y₀, y₁)) == append(remove(x₀, y₀), remove(x₀, cons(y₁, nil))))
forall y₀: nat, y₁: list, x₁: nat :: (snoc(take(y₀, y₁), x₁) == append(take(y₀, y₁), cons(x₁, nil)))
forall y₀: list, y₁: list, x₁: nat :: (snoc(append(y₀, y₁), x₁) == append(y₀, append(y₁, cons(x₁, nil))))
forall y₀: [nat]nat, y₁: list, x₁: nat :: (snoc(map(y₀, y₁), x₁) == append(map(y₀, y₁), cons(x₁, nil)))
forall y₀: nat, y₁: list, x₁: nat :: (snoc(remove(y₀, y₁), x₁) == append(remove(y₀, y₁), cons(x₁, nil)))
forall y₀: list, y₁: nat, x₁: nat :: (snoc(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, cons(x₁, nil))))
forall y₀: [nat]Bool, y₁: list, x₁: nat :: (snoc(filter(y₀, y₁), x₁) == append(filter(y₀, y₁), cons(x₁, nil)))
forall x₀: [nat]Bool, x₁: list, x₂: nat :: (not_(ex(x₀, x₁)) ==> (snoc(filter(x₀, x₁), x₂) == cons(x₂, nil)))
forall x₀: nat, x₁: list, x₂: nat :: (not_(contains(x₀, x₁)) ==> (add(count(x₀, x₁), x₂) == x₂))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x₀: [nat]Bool, x₁: list, x₂: nat :: (not_(ex(x₀, x₁)) ==> (add(countif(x₀, x₁), x₂) == x₂))
forall x₀: [nat]Bool, y₀: list, y₁: list :: (filter(x₀, append(y₀, y₁)) == append(filter(x₀, y₀), filter(x₀, y₁)))
forall x₀: [nat]Bool, x₁: list, x₂: list :: (not_(ex(x₀, x₁)) ==> (filter(x₀, append(x₁, x₂)) == filter(x₀, x₂)))
forall x₀: [nat]Bool, y₀: list, y₁: nat :: (filter(x₀, snoc(y₀, y₁)) == append(filter(x₀, y₀), filter(x₀, cons(y₁, nil))))
forall x₀: [nat]Bool, x₁: list, x₂: nat :: (not_(ex(x₀, x₁)) ==> (filter(x₀, snoc(x₁, x₂)) == filter(x₀, cons(x₂, nil))))
forall x₀: [nat]Bool, y₀: list, y₁: list :: (countif(x₀, append(y₀, y₁)) == add(countif(x₀, y₀), countif(x₀, y₁)))
forall x₀: [nat]Bool, x₁: list, x₂: list :: (not_(ex(x₀, x₁)) ==> (countif(x₀, append(x₁, x₂)) == countif(x₀, x₂)))
forall x₀: [nat]Bool, y₀: list, y₁: nat :: (countif(x₀, snoc(y₀, y₁)) == add(countif(x₀, y₀), countif(x₀, cons(y₁, nil))))
forall x₀: [nat]Bool, x₁: list, x₂: nat :: (not_(ex(x₀, x₁)) ==> (countif(x₀, snoc(x₁, x₂)) == countif(x₀, cons(x₂, nil))))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (take(x₀, map(y₀, y₁)) == map(y₀, take(x₀, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall y₀: [nat]Bool, y₁: list :: (length(filter(y₀, y₁)) == countif(y₀, y₁))
forall y₀: Bool :: (not_(not_(y₀)) <==> y₀)
forall x₀: nat, y₀: [nat]nat, y₁: list :: (drop(x₀, map(y₀, y₁)) == map(y₀, drop(x₀, y₁)))
forall x₀: nat, x₁: list :: (not_(contains(x₀, x₁)) ==> (count(x₀, x₁) == zero))
forall x₀: nat, x₁: list :: (not_(contains(x₀, x₁)) ==> (remove(x₀, x₁) == x₁))
forall x₀: list, x₁: nat :: (snoc(x₀, x₁) == append(x₀, cons(x₁, nil)))
forall x₀: [nat]Bool, x₁: list :: (not_(ex(x₀, x₁)) ==> (filter(x₀, x₁) == nil))
forall x₀: [nat]Bool, x₁: list :: (all(x₀, x₁) ==> (filter(x₀, x₁) == x₁))
forall x₀: [nat]Bool, x₁: list :: (not_(ex(x₀, x₁)) ==> (countif(x₀, x₁) == zero))
forall x: list :: (append(x, nil) == x)
forall x: nat :: (add(x, zero) == x)
forall x: list, y₀: list, z₀: nat :: ((y₀ == cons(z₀, nil)) ==> (append(x, y₀) == append(x, cons(z₀, nil))))
forall x: list, y₀: [nat]Bool :: (all(y₀, x) ==> (countif(y₀, x) == length(x)))
  19  independent
forall y₀: list :: (reverse(reverse(y₀)) == y₀)
forall x₀: [nat]nat, y₀: list :: (map(x₀, reverse(y₀)) == reverse(map(x₀, y₀)))
forall x₀: [nat]nat, y₀: nat, y₁: list :: (map(x₀, rotate(y₀, y₁)) == rotate(y₀, map(x₀, y₁)))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == append(reverse(y₁), reverse(y₀)))
forall x₀: nat, y₀: list, y₁: list :: (count(x₀, append(y₀, y₁)) == add(count(x₀, y₀), count(x₀, y₁)))
forall x₀: nat, x₁: list, x₂: list :: (not_(contains(x₀, x₁)) ==> (count(x₀, append(x₁, x₂)) == count(x₀, x₂)))
forall x₀: nat, y₀: list, y₁: nat :: (count(x₀, snoc(y₀, y₁)) == add(count(x₀, y₀), count(x₀, cons(y₁, nil))))
forall x₀: nat, x₁: list, x₂: nat :: (not_(contains(x₀, x₁)) ==> (count(x₀, snoc(x₁, x₂)) == count(x₀, cons(x₂, nil))))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: nat, x₁: list :: (append(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, x₁)))
forall x₀: [nat]Bool, x₁: list, x₂: list :: (not_(ex(x₀, x₁)) ==> (append(filter(x₀, x₁), x₂) == x₂))
forall y₀: list, y₁: nat :: (reverse(snoc(y₀, y₁)) == cons(y₁, reverse(y₀)))
forall x₀: [nat]Bool, x₁: list :: (not_(ex(x₀, x₁)) ==> (reverse(filter(x₀, x₁)) == nil))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall x₀: [nat]nat, y₀: list, y₁: nat :: (map(x₀, snoc(y₀, y₁)) == append(map(x₀, y₀), cons(x₀[y₁], nil)))
forall x₀: [nat]nat, x₁: [nat]Bool, x₂: list :: (not_(ex(x₁, x₂)) ==> (map(x₀, filter(x₁, x₂)) == nil))
forall x₀: nat, y₀: list, y₁: list :: (remove(x₀, append(y₀, y₁)) == append(remove(x₀, y₀), remove(x₀, y₁)))
forall x₀: nat, y₀: list, y₁: nat :: (remove(x₀, snoc(y₀, y₁)) == append(remove(x₀, y₀), remove(x₀, cons(y₁, nil))))
forall y₀: nat, y₁: list, x₁: nat :: (snoc(take(y₀, y₁), x₁) == append(take(y₀, y₁), cons(x₁, nil)))
forall y₀: list, y₁: list, x₁: nat :: (snoc(append(y₀, y₁), x₁) == append(y₀, append(y₁, cons(x₁, nil))))
forall y₀: [nat]nat, y₁: list, x₁: nat :: (snoc(map(y₀, y₁), x₁) == append(map(y₀, y₁), cons(x₁, nil)))
forall y₀: nat, y₁: list, x₁: nat :: (snoc(remove(y₀, y₁), x₁) == append(remove(y₀, y₁), cons(x₁, nil)))
forall y₀: list, y₁: nat, x₁: nat :: (snoc(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, cons(x₁, nil))))
forall y₀: [nat]Bool, y₁: list, x₁: nat :: (snoc(filter(y₀, y₁), x₁) == append(filter(y₀, y₁), cons(x₁, nil)))
forall x₀: [nat]Bool, x₁: list, x₂: nat :: (not_(ex(x₀, x₁)) ==> (snoc(filter(x₀, x₁), x₂) == cons(x₂, nil)))
forall x₀: nat, x₁: list, x₂: nat :: (not_(contains(x₀, x₁)) ==> (add(count(x₀, x₁), x₂) == x₂))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x₀: [nat]Bool, x₁: list, x₂: nat :: (not_(ex(x₀, x₁)) ==> (add(countif(x₀, x₁), x₂) == x₂))
forall x₀: [nat]Bool, y₀: list, y₁: list :: (filter(x₀, append(y₀, y₁)) == append(filter(x₀, y₀), filter(x₀, y₁)))
forall x₀: [nat]Bool, x₁: list, x₂: list :: (not_(ex(x₀, x₁)) ==> (filter(x₀, append(x₁, x₂)) == filter(x₀, x₂)))
forall x₀: [nat]Bool, y₀: list, y₁: nat :: (filter(x₀, snoc(y₀, y₁)) == append(filter(x₀, y₀), filter(x₀, cons(y₁, nil))))
forall x₀: [nat]Bool, x₁: list, x₂: nat :: (not_(ex(x₀, x₁)) ==> (filter(x₀, snoc(x₁, x₂)) == filter(x₀, cons(x₂, nil))))
forall x₀: [nat]Bool, y₀: list, y₁: list :: (countif(x₀, append(y₀, y₁)) == add(countif(x₀, y₀), countif(x₀, y₁)))
forall x₀: [nat]Bool, x₁: list, x₂: list :: (not_(ex(x₀, x₁)) ==> (countif(x₀, append(x₁, x₂)) == countif(x₀, x₂)))
forall x₀: [nat]Bool, y₀: list, y₁: nat :: (countif(x₀, snoc(y₀, y₁)) == add(countif(x₀, y₀), countif(x₀, cons(y₁, nil))))
forall x₀: [nat]Bool, x₁: list, x₂: nat :: (not_(ex(x₀, x₁)) ==> (countif(x₀, snoc(x₁, x₂)) == countif(x₀, cons(x₂, nil))))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (take(x₀, map(y₀, y₁)) == map(y₀, take(x₀, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall y₀: [nat]Bool, y₁: list :: (length(filter(y₀, y₁)) == countif(y₀, y₁))
forall y₀: Bool :: (not_(not_(y₀)) <==> y₀)
forall x₀: nat, y₀: [nat]nat, y₁: list :: (drop(x₀, map(y₀, y₁)) == map(y₀, drop(x₀, y₁)))
forall x₀: nat, x₁: list :: (not_(contains(x₀, x₁)) ==> (count(x₀, x₁) == zero))
forall x₀: nat, x₁: list :: (not_(contains(x₀, x₁)) ==> (remove(x₀, x₁) == x₁))
forall x₀: list, x₁: nat :: (snoc(x₀, x₁) == append(x₀, cons(x₁, nil)))
forall x₀: [nat]Bool, x₁: list :: (not_(ex(x₀, x₁)) ==> (filter(x₀, x₁) == nil))
forall x₀: [nat]Bool, x₁: list :: (all(x₀, x₁) ==> (filter(x₀, x₁) == x₁))
forall x₀: [nat]Bool, x₁: list :: (not_(ex(x₀, x₁)) ==> (countif(x₀, x₁) == zero))
forall x: list :: (append(x, nil) == x)
forall x: nat :: (add(x, zero) == x)
forall x: list, y₀: list, z₀: nat :: ((y₀ == cons(z₀, nil)) ==> (append(x, y₀) == append(x, cons(z₀, nil))))
forall x: list, y₀: [nat]Bool :: (all(y₀, x) ==> (countif(y₀, x) == length(x)))
  18  evaluation/lemmas/list.structural.bpl
forall y₀: list :: (reverse(reverse(y₀)) == y₀)
forall x₀: [nat]nat, y₀: list :: (map(x₀, reverse(y₀)) == reverse(map(x₀, y₀)))
forall x₀: [nat]nat, y₀: nat, y₁: list :: (map(x₀, rotate(y₀, y₁)) == rotate(y₀, map(x₀, y₁)))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == append(reverse(y₁), reverse(y₀)))
forall x₀: nat, y₀: list, y₁: list :: (count(x₀, append(y₀, y₁)) == add(count(x₀, y₀), count(x₀, y₁)))
forall x₀: nat, x₁: list, x₂: list :: (not_(contains(x₀, x₁)) ==> (count(x₀, append(x₁, x₂)) == count(x₀, x₂)))
forall x₀: nat, y₀: list, y₁: nat :: (count(x₀, snoc(y₀, y₁)) == add(count(x₀, y₀), count(x₀, cons(y₁, nil))))
forall x₀: nat, x₁: list, x₂: nat :: (not_(contains(x₀, x₁)) ==> (count(x₀, snoc(x₁, x₂)) == count(x₀, cons(x₂, nil))))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: nat, x₁: list :: (append(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, x₁)))
forall x₀: [nat]Bool, x₁: list, x₂: list :: (not_(ex(x₀, x₁)) ==> (append(filter(x₀, x₁), x₂) == x₂))
forall y₀: list, y₁: nat :: (reverse(snoc(y₀, y₁)) == cons(y₁, reverse(y₀)))
forall x₀: [nat]Bool, x₁: list :: (not_(ex(x₀, x₁)) ==> (reverse(filter(x₀, x₁)) == nil))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall x₀: [nat]nat, y₀: list, y₁: nat :: (map(x₀, snoc(y₀, y₁)) == append(map(x₀, y₀), cons(x₀[y₁], nil)))
forall x₀: [nat]nat, x₁: [nat]Bool, x₂: list :: (not_(ex(x₁, x₂)) ==> (map(x₀, filter(x₁, x₂)) == nil))
forall x₀: nat, y₀: list, y₁: list :: (remove(x₀, append(y₀, y₁)) == append(remove(x₀, y₀), remove(x₀, y₁)))
forall x₀: nat, y₀: list, y₁: nat :: (remove(x₀, snoc(y₀, y₁)) == append(remove(x₀, y₀), remove(x₀, cons(y₁, nil))))
forall y₀: nat, y₁: list, x₁: nat :: (snoc(take(y₀, y₁), x₁) == append(take(y₀, y₁), cons(x₁, nil)))
forall y₀: list, y₁: list, x₁: nat :: (snoc(append(y₀, y₁), x₁) == append(y₀, append(y₁, cons(x₁, nil))))
forall y₀: [nat]nat, y₁: list, x₁: nat :: (snoc(map(y₀, y₁), x₁) == append(map(y₀, y₁), cons(x₁, nil)))
forall y₀: nat, y₁: list, x₁: nat :: (snoc(remove(y₀, y₁), x₁) == append(remove(y₀, y₁), cons(x₁, nil)))
forall y₀: list, y₁: nat, x₁: nat :: (snoc(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, cons(x₁, nil))))
forall y₀: [nat]Bool, y₁: list, x₁: nat :: (snoc(filter(y₀, y₁), x₁) == append(filter(y₀, y₁), cons(x₁, nil)))
forall x₀: [nat]Bool, x₁: list, x₂: nat :: (not_(ex(x₀, x₁)) ==> (snoc(filter(x₀, x₁), x₂) == cons(x₂, nil)))
forall x₀: nat, x₁: list, x₂: nat :: (not_(contains(x₀, x₁)) ==> (add(count(x₀, x₁), x₂) == x₂))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x₀: [nat]Bool, x₁: list, x₂: nat :: (not_(ex(x₀, x₁)) ==> (add(countif(x₀, x₁), x₂) == x₂))
forall x₀: [nat]Bool, y₀: list, y₁: list :: (filter(x₀, append(y₀, y₁)) == append(filter(x₀, y₀), filter(x₀, y₁)))
forall x₀: [nat]Bool, x₁: list, x₂: list :: (not_(ex(x₀, x₁)) ==> (filter(x₀, append(x₁, x₂)) == filter(x₀, x₂)))
forall x₀: [nat]Bool, y₀: list, y₁: nat :: (filter(x₀, snoc(y₀, y₁)) == append(filter(x₀, y₀), filter(x₀, cons(y₁, nil))))
forall x₀: [nat]Bool, x₁: list, x₂: nat :: (not_(ex(x₀, x₁)) ==> (filter(x₀, snoc(x₁, x₂)) == filter(x₀, cons(x₂, nil))))
forall x₀: [nat]Bool, y₀: list, y₁: list :: (countif(x₀, append(y₀, y₁)) == add(countif(x₀, y₀), countif(x₀, y₁)))
forall x₀: [nat]Bool, x₁: list, x₂: list :: (not_(ex(x₀, x₁)) ==> (countif(x₀, append(x₁, x₂)) == countif(x₀, x₂)))
forall x₀: [nat]Bool, y₀: list, y₁: nat :: (countif(x₀, snoc(y₀, y₁)) == add(countif(x₀, y₀), countif(x₀, cons(y₁, nil))))
forall x₀: [nat]Bool, x₁: list, x₂: nat :: (not_(ex(x₀, x₁)) ==> (countif(x₀, snoc(x₁, x₂)) == countif(x₀, cons(x₂, nil))))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (take(x₀, map(y₀, y₁)) == map(y₀, take(x₀, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall y₀: [nat]Bool, y₁: list :: (length(filter(y₀, y₁)) == countif(y₀, y₁))
forall y₀: Bool :: (not_(not_(y₀)) <==> y₀)
forall x₀: nat, y₀: [nat]nat, y₁: list :: (drop(x₀, map(y₀, y₁)) == map(y₀, drop(x₀, y₁)))
forall x₀: nat, x₁: list :: (not_(contains(x₀, x₁)) ==> (count(x₀, x₁) == zero))
forall x₀: nat, x₁: list :: (not_(contains(x₀, x₁)) ==> (remove(x₀, x₁) == x₁))
forall x₀: list, x₁: nat :: (snoc(x₀, x₁) == append(x₀, cons(x₁, nil)))
forall x₀: [nat]Bool, x₁: list :: (not_(ex(x₀, x₁)) ==> (filter(x₀, x₁) == nil))
forall x₀: [nat]Bool, x₁: list :: (all(x₀, x₁) ==> (filter(x₀, x₁) == x₁))
forall x₀: [nat]Bool, x₁: list :: (not_(ex(x₀, x₁)) ==> (countif(x₀, x₁) == zero))
forall x: list :: (append(x, nil) == x)
forall x: nat :: (add(x, zero) == x)
forall x: list, y₀: list, z₀: nat :: ((y₀ == cons(z₀, nil)) ==> (append(x, y₀) == append(x, cons(z₀, nil))))
forall x: list, y₀: [nat]Bool :: (all(y₀, x) ==> (countif(y₀, x) == length(x)))
  41  evaluation/lemmas/list.enumerate.bpl
forall y₀: list :: (reverse(reverse(y₀)) == y₀)
forall x₀: [nat]nat, y₀: list :: (map(x₀, reverse(y₀)) == reverse(map(x₀, y₀)))
forall x₀: [nat]nat, y₀: nat, y₁: list :: (map(x₀, rotate(y₀, y₁)) == rotate(y₀, map(x₀, y₁)))
forall y₀: list, y₁: list :: (reverse(append(y₀, y₁)) == append(reverse(y₁), reverse(y₀)))
forall x₀: nat, y₀: list, y₁: list :: (count(x₀, append(y₀, y₁)) == add(count(x₀, y₀), count(x₀, y₁)))
forall x₀: nat, x₁: list, x₂: list :: (not_(contains(x₀, x₁)) ==> (count(x₀, append(x₁, x₂)) == count(x₀, x₂)))
forall x₀: nat, y₀: list, y₁: nat :: (count(x₀, snoc(y₀, y₁)) == add(count(x₀, y₀), count(x₀, cons(y₁, nil))))
forall x₀: nat, x₁: list, x₂: nat :: (not_(contains(x₀, x₁)) ==> (count(x₀, snoc(x₁, x₂)) == count(x₀, cons(x₂, nil))))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: nat, x₁: list :: (append(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, x₁)))
forall x₀: [nat]Bool, x₁: list, x₂: list :: (not_(ex(x₀, x₁)) ==> (append(filter(x₀, x₁), x₂) == x₂))
forall y₀: list, y₁: nat :: (reverse(snoc(y₀, y₁)) == cons(y₁, reverse(y₀)))
forall x₀: [nat]Bool, x₁: list :: (not_(ex(x₀, x₁)) ==> (reverse(filter(x₀, x₁)) == nil))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall x₀: [nat]nat, y₀: list, y₁: nat :: (map(x₀, snoc(y₀, y₁)) == append(map(x₀, y₀), cons(x₀[y₁], nil)))
forall x₀: [nat]nat, x₁: [nat]Bool, x₂: list :: (not_(ex(x₁, x₂)) ==> (map(x₀, filter(x₁, x₂)) == nil))
forall x₀: nat, y₀: list, y₁: list :: (remove(x₀, append(y₀, y₁)) == append(remove(x₀, y₀), remove(x₀, y₁)))
forall x₀: nat, y₀: list, y₁: nat :: (remove(x₀, snoc(y₀, y₁)) == append(remove(x₀, y₀), remove(x₀, cons(y₁, nil))))
forall y₀: nat, y₁: list, x₁: nat :: (snoc(take(y₀, y₁), x₁) == append(take(y₀, y₁), cons(x₁, nil)))
forall y₀: list, y₁: list, x₁: nat :: (snoc(append(y₀, y₁), x₁) == append(y₀, append(y₁, cons(x₁, nil))))
forall y₀: [nat]nat, y₁: list, x₁: nat :: (snoc(map(y₀, y₁), x₁) == append(map(y₀, y₁), cons(x₁, nil)))
forall y₀: nat, y₁: list, x₁: nat :: (snoc(remove(y₀, y₁), x₁) == append(remove(y₀, y₁), cons(x₁, nil)))
forall y₀: list, y₁: nat, x₁: nat :: (snoc(snoc(y₀, y₁), x₁) == append(y₀, cons(y₁, cons(x₁, nil))))
forall y₀: [nat]Bool, y₁: list, x₁: nat :: (snoc(filter(y₀, y₁), x₁) == append(filter(y₀, y₁), cons(x₁, nil)))
forall x₀: [nat]Bool, x₁: list, x₂: nat :: (not_(ex(x₀, x₁)) ==> (snoc(filter(x₀, x₁), x₂) == cons(x₂, nil)))
forall x₀: nat, x₁: list, x₂: nat :: (not_(contains(x₀, x₁)) ==> (add(count(x₀, x₁), x₂) == x₂))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall x₀: [nat]Bool, x₁: list, x₂: nat :: (not_(ex(x₀, x₁)) ==> (add(countif(x₀, x₁), x₂) == x₂))
forall x₀: [nat]Bool, y₀: list, y₁: list :: (filter(x₀, append(y₀, y₁)) == append(filter(x₀, y₀), filter(x₀, y₁)))
forall x₀: [nat]Bool, x₁: list, x₂: list :: (not_(ex(x₀, x₁)) ==> (filter(x₀, append(x₁, x₂)) == filter(x₀, x₂)))
forall x₀: [nat]Bool, y₀: list, y₁: nat :: (filter(x₀, snoc(y₀, y₁)) == append(filter(x₀, y₀), filter(x₀, cons(y₁, nil))))
forall x₀: [nat]Bool, x₁: list, x₂: nat :: (not_(ex(x₀, x₁)) ==> (filter(x₀, snoc(x₁, x₂)) == filter(x₀, cons(x₂, nil))))
forall x₀: [nat]Bool, y₀: list, y₁: list :: (countif(x₀, append(y₀, y₁)) == add(countif(x₀, y₀), countif(x₀, y₁)))
forall x₀: [nat]Bool, x₁: list, x₂: list :: (not_(ex(x₀, x₁)) ==> (countif(x₀, append(x₁, x₂)) == countif(x₀, x₂)))
forall x₀: [nat]Bool, y₀: list, y₁: nat :: (countif(x₀, snoc(y₀, y₁)) == add(countif(x₀, y₀), countif(x₀, cons(y₁, nil))))
forall x₀: [nat]Bool, x₁: list, x₂: nat :: (not_(ex(x₀, x₁)) ==> (countif(x₀, snoc(x₁, x₂)) == countif(x₀, cons(x₂, nil))))
forall x₀: nat, y₀: [nat]nat, y₁: list :: (take(x₀, map(y₀, y₁)) == map(y₀, take(x₀, y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall y₀: [nat]Bool, y₁: list :: (length(filter(y₀, y₁)) == countif(y₀, y₁))
forall y₀: Bool :: (not_(not_(y₀)) <==> y₀)
forall x₀: nat, y₀: [nat]nat, y₁: list :: (drop(x₀, map(y₀, y₁)) == map(y₀, drop(x₀, y₁)))
forall x₀: nat, x₁: list :: (not_(contains(x₀, x₁)) ==> (count(x₀, x₁) == zero))
forall x₀: nat, x₁: list :: (not_(contains(x₀, x₁)) ==> (remove(x₀, x₁) == x₁))
forall x₀: list, x₁: nat :: (snoc(x₀, x₁) == append(x₀, cons(x₁, nil)))
forall x₀: [nat]Bool, x₁: list :: (not_(ex(x₀, x₁)) ==> (filter(x₀, x₁) == nil))
forall x₀: [nat]Bool, x₁: list :: (all(x₀, x₁) ==> (filter(x₀, x₁) == x₁))
forall x₀: [nat]Bool, x₁: list :: (not_(ex(x₀, x₁)) ==> (countif(x₀, x₁) == zero))
forall x: list :: (append(x, nil) == x)
forall x: nat :: (add(x, zero) == x)
forall x: list, y₀: list, z₀: nat :: ((y₀ == cons(z₀, nil)) ==> (append(x, y₀) == append(x, cons(z₀, nil))))
forall x: list, y₀: [nat]Bool :: (all(y₀, x) ==> (countif(y₀, x) == length(x)))
  48  evaluation/lemmas/list.th.log
evaluation/lemmas/tree.conditional.bpl
  12  number of lemmas
  0  wrong
forall y₀: tree :: (length(elems(y₀)) == size(y₀))
forall x₀: [nat]nat, y₀: tree :: (map(x₀, elems(y₀)) == elems(maptree(x₀, y₀)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall y₀: tree :: (mirror(mirror(y₀)) == y₀)
forall y₀: [nat]nat, y₁: tree :: (mirror(maptree(y₀, y₁)) == maptree(y₀, mirror(y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall y₀: [nat]nat, y₁: tree :: (size(maptree(y₀, y₁)) == size(y₁))
forall x: nat :: (add(x, zero) == x)
forall x: list :: (append(x, nil) == x)
  10  nontrivial
forall y₀: tree :: (length(elems(y₀)) == size(y₀))
forall x₀: [nat]nat, y₀: tree :: (map(x₀, elems(y₀)) == elems(maptree(x₀, y₀)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall y₀: tree :: (mirror(mirror(y₀)) == y₀)
forall y₀: [nat]nat, y₁: tree :: (mirror(maptree(y₀, y₁)) == maptree(y₀, mirror(y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall y₀: [nat]nat, y₁: tree :: (size(maptree(y₀, y₁)) == size(y₁))
forall x: nat :: (add(x, zero) == x)
forall x: list :: (append(x, nil) == x)
  9  reduced greedily
forall y₀: tree :: (length(elems(y₀)) == size(y₀))
forall x₀: [nat]nat, y₀: tree :: (map(x₀, elems(y₀)) == elems(maptree(x₀, y₀)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall y₀: tree :: (mirror(mirror(y₀)) == y₀)
forall y₀: [nat]nat, y₁: tree :: (mirror(maptree(y₀, y₁)) == maptree(y₀, mirror(y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall y₀: [nat]nat, y₁: tree :: (size(maptree(y₀, y₁)) == size(y₁))
forall x: nat :: (add(x, zero) == x)
forall x: list :: (append(x, nil) == x)
  9  independent
forall y₀: tree :: (length(elems(y₀)) == size(y₀))
forall x₀: [nat]nat, y₀: tree :: (map(x₀, elems(y₀)) == elems(maptree(x₀, y₀)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall y₀: tree :: (mirror(mirror(y₀)) == y₀)
forall y₀: [nat]nat, y₁: tree :: (mirror(maptree(y₀, y₁)) == maptree(y₀, mirror(y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall y₀: [nat]nat, y₁: tree :: (size(maptree(y₀, y₁)) == size(y₁))
forall x: nat :: (add(x, zero) == x)
forall x: list :: (append(x, nil) == x)
  0  evaluation/lemmas/tree.structural.bpl
forall y₀: tree :: (length(elems(y₀)) == size(y₀))
forall x₀: [nat]nat, y₀: tree :: (map(x₀, elems(y₀)) == elems(maptree(x₀, y₀)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall y₀: tree :: (mirror(mirror(y₀)) == y₀)
forall y₀: [nat]nat, y₁: tree :: (mirror(maptree(y₀, y₁)) == maptree(y₀, mirror(y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall y₀: [nat]nat, y₁: tree :: (size(maptree(y₀, y₁)) == size(y₁))
forall x: nat :: (add(x, zero) == x)
forall x: list :: (append(x, nil) == x)
  2  evaluation/lemmas/tree.enumerate.bpl
forall y₀: tree :: (length(elems(y₀)) == size(y₀))
forall x₀: [nat]nat, y₀: tree :: (map(x₀, elems(y₀)) == elems(maptree(x₀, y₀)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall y₀: tree :: (mirror(mirror(y₀)) == y₀)
forall y₀: [nat]nat, y₁: tree :: (mirror(maptree(y₀, y₁)) == maptree(y₀, mirror(y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall y₀: [nat]nat, y₁: tree :: (size(maptree(y₀, y₁)) == size(y₁))
forall x: nat :: (add(x, zero) == x)
forall x: list :: (append(x, nil) == x)
  8  evaluation/lemmas/tree.th.log
