evaluation/lemmas/tree.conditional.bpl
  12  number of lemmas
  0  wrong
forall y₀: tree :: (length(elems(y₀)) == size(y₀))
forall x₀: [nat]nat, y₀: tree :: (map(x₀, elems(y₀)) == elems(maptree(x₀, y₀)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall y₀: tree :: (mirror(mirror(y₀)) == y₀)
forall y₀: [nat]nat, y₁: tree :: (mirror(maptree(y₀, y₁)) == maptree(y₀, mirror(y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall y₀: [nat]nat, y₁: tree :: (size(maptree(y₀, y₁)) == size(y₁))
forall x: nat :: (add(x, zero) == x)
forall x: list :: (append(x, nil) == x)
  10  nontrivial
forall y₀: tree :: (length(elems(y₀)) == size(y₀))
forall x₀: [nat]nat, y₀: tree :: (map(x₀, elems(y₀)) == elems(maptree(x₀, y₀)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall y₀: tree :: (mirror(mirror(y₀)) == y₀)
forall y₀: [nat]nat, y₁: tree :: (mirror(maptree(y₀, y₁)) == maptree(y₀, mirror(y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall y₀: [nat]nat, y₁: tree :: (size(maptree(y₀, y₁)) == size(y₁))
forall x: nat :: (add(x, zero) == x)
forall x: list :: (append(x, nil) == x)
  9  reduced greedily
forall y₀: tree :: (length(elems(y₀)) == size(y₀))
forall x₀: [nat]nat, y₀: tree :: (map(x₀, elems(y₀)) == elems(maptree(x₀, y₀)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall y₀: tree :: (mirror(mirror(y₀)) == y₀)
forall y₀: [nat]nat, y₁: tree :: (mirror(maptree(y₀, y₁)) == maptree(y₀, mirror(y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall y₀: [nat]nat, y₁: tree :: (size(maptree(y₀, y₁)) == size(y₁))
forall x: nat :: (add(x, zero) == x)
forall x: list :: (append(x, nil) == x)
  9  independent
forall y₀: tree :: (length(elems(y₀)) == size(y₀))
forall x₀: [nat]nat, y₀: tree :: (map(x₀, elems(y₀)) == elems(maptree(x₀, y₀)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall y₀: tree :: (mirror(mirror(y₀)) == y₀)
forall y₀: [nat]nat, y₁: tree :: (mirror(maptree(y₀, y₁)) == maptree(y₀, mirror(y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall y₀: [nat]nat, y₁: tree :: (size(maptree(y₀, y₁)) == size(y₁))
forall x: nat :: (add(x, zero) == x)
forall x: list :: (append(x, nil) == x)
  0  evaluation/lemmas/tree.structural.bpl
forall y₀: tree :: (length(elems(y₀)) == size(y₀))
forall x₀: [nat]nat, y₀: tree :: (map(x₀, elems(y₀)) == elems(maptree(x₀, y₀)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall y₀: tree :: (mirror(mirror(y₀)) == y₀)
forall y₀: [nat]nat, y₁: tree :: (mirror(maptree(y₀, y₁)) == maptree(y₀, mirror(y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall y₀: [nat]nat, y₁: tree :: (size(maptree(y₀, y₁)) == size(y₁))
forall x: nat :: (add(x, zero) == x)
forall x: list :: (append(x, nil) == x)
  2  evaluation/lemmas/tree.enumerate.bpl
forall y₀: tree :: (length(elems(y₀)) == size(y₀))
forall x₀: [nat]nat, y₀: tree :: (map(x₀, elems(y₀)) == elems(maptree(x₀, y₀)))
forall y₀: nat, y₁: nat, x₁: nat :: (add(add(y₀, y₁), x₁) == add(y₀, add(y₁, x₁)))
forall y₀: list, y₁: list, x₁: list :: (append(append(y₀, y₁), x₁) == append(y₀, append(y₁, x₁)))
forall y₀: list, y₁: list :: (length(append(y₀, y₁)) == add(length(y₀), length(y₁)))
forall x₀: [nat]nat, y₀: list, y₁: list :: (map(x₀, append(y₀, y₁)) == append(map(x₀, y₀), map(x₀, y₁)))
forall y₀: tree :: (mirror(mirror(y₀)) == y₀)
forall y₀: [nat]nat, y₁: tree :: (mirror(maptree(y₀, y₁)) == maptree(y₀, mirror(y₁)))
forall y₀: [nat]nat, y₁: list :: (length(map(y₀, y₁)) == length(y₁))
forall y₀: [nat]nat, y₁: tree :: (size(maptree(y₀, y₁)) == size(y₁))
forall x: nat :: (add(x, zero) == x)
forall x: list :: (append(x, nil) == x)
  8  evaluation/lemmas/tree.th.log
